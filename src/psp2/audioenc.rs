/* automatically generated by rust-bindgen 0.65.1 */

#[allow(unused_imports)]
use crate::psp2::types::*;
#[allow(unused_imports)]
use crate::psp2common::types::*;

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const SCE_AUDIOENC_WORD_LENGTH_16BITS: u32 = 16;
pub const SCE_AUDIOENC_TYPE_CELP: u32 = 8198;
pub const SCE_AUDIOENC_CELP_MAX_STREAMS: u32 = 1;
pub const SCE_AUDIOENC_CELP_MAX_SAMPLES: u32 = 320;
pub const SCE_AUDIOENC_CELP_MAX_ES_SIZE: u32 = 24;
pub const SCE_AUDIOENC_CELP_MPE: u32 = 0;
pub const SCE_AUDIOENC_CELP_SAMPLING_RATE_8KHZ: u32 = 8000;
pub mod SceAudioencErrorCode {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_AUDIOENC_ERROR_API_FAIL: Type = 2156265472;
    pub const SCE_AUDIOENC_ERROR_INVALID_TYPE: Type = 2156265473;
    pub const SCE_AUDIOENC_ERROR_INVALID_INIT_PARAM: Type = 2156265474;
    pub const SCE_AUDIOENC_ERROR_ALREADY_INITIALIZED: Type = 2156265475;
    pub const SCE_AUDIOENC_ERROR_OUT_OF_MEMORY: Type = 2156265476;
    pub const SCE_AUDIOENC_ERROR_NOT_INITIALIZED: Type = 2156265477;
    pub const SCE_AUDIOENC_ERROR_A_HANDLE_IN_USE: Type = 2156265478;
    pub const SCE_AUDIOENC_ERROR_ALL_HANDLES_IN_USE: Type = 2156265479;
    pub const SCE_AUDIOENC_ERROR_INVALID_PTR: Type = 2156265480;
    pub const SCE_AUDIOENC_ERROR_INVALID_HANDLE: Type = 2156265481;
    pub const SCE_AUDIOENC_ERROR_NOT_HANDLE_IN_USE: Type = 2156265482;
    pub const SCE_AUDIOENC_ERROR_CH_SHORTAGE: Type = 2156265483;
    pub const SCE_AUDIOENC_ERROR_INVALID_WORD_LENGTH: Type = 2156265484;
    pub const SCE_AUDIOENC_ERROR_INVALID_SIZE: Type = 2156265485;
    pub const SCE_AUDIOENC_ERROR_INVALID_ALIGNMENT: Type = 2156265486;
    pub const SCE_AUDIOENC_ERROR_UNSUPPORTED: Type = 2156265487;
}
pub mod SceAudioencCelpErrorCode {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_AUDIOENC_CELP_ERROR_INVALID_CONFIG: Type = 2156269569;
}
pub mod SceAudioencCelpBitrate {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_3850BPS: Type = 3850;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_4650BPS: Type = 4650;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_5700BPS: Type = 5700;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_6600BPS: Type = 6600;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_7300BPS: Type = 7300;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_8700BPS: Type = 8700;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_9900BPS: Type = 9900;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_10700BPS: Type = 10700;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_11800BPS: Type = 11800;
    pub const SCE_AUDIOENC_CELP_BIT_RATE_12200BPS: Type = 12200;
}
#[repr(C)]
pub struct SceAudioencInitStreamParam {
    pub size: SceSize,
    pub totalStreams: crate::ctypes::c_uint,
}
#[repr(C)]
pub struct SceAudioencInfoCelp {
    pub size: SceSize,
    pub excitationMode: crate::ctypes::c_uint,
    pub samplingRate: crate::ctypes::c_uint,
    pub bitRate: crate::ctypes::c_uint,
}
#[repr(C)]
pub struct SceAudioencOptInfoCelp {
    pub size: SceSize,
    pub header: [u8; 32usize],
    pub headerSize: SceSize,
    pub encoderVersion: crate::ctypes::c_uint,
}
#[repr(C)]
pub struct SceAudioencInitParam {
    pub size: __BindgenUnionField<SceSize>,
    pub celp: __BindgenUnionField<SceAudioencInitStreamParam>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct SceAudioencInfo {
    pub size: __BindgenUnionField<SceSize>,
    pub celp: __BindgenUnionField<SceAudioencInfoCelp>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
pub struct SceAudioencOptInfo {
    pub size: __BindgenUnionField<SceSize>,
    pub celp: __BindgenUnionField<SceAudioencOptInfoCelp>,
    pub bindgen_union_field: [u32; 11usize],
}
#[repr(C)]
pub struct SceAudioencCtrl {
    pub size: SceSize,
    pub handle: crate::ctypes::c_int,
    pub pInputPcm: *mut crate::ctypes::c_void,
    pub inputPcmSize: SceSize,
    pub maxPcmSize: SceSize,
    pub pOutputEs: *mut crate::ctypes::c_void,
    pub outputEsSize: SceSize,
    pub maxEsSize: SceSize,
    pub wordLength: SceSize,
    pub pInfo: *mut SceAudioencInfo,
    pub pOptInfo: *mut SceAudioencOptInfo,
}
extern "C" {
    pub fn sceAudioencInitLibrary(
        codecType: crate::ctypes::c_int,
        pInitParam: *mut SceAudioencInitParam,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencTermLibrary(codecType: crate::ctypes::c_uint) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencCreateEncoder(
        pCtrl: *mut SceAudioencCtrl,
        codecType: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencDeleteEncoder(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencEncode(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencClearContext(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencGetOptInfo(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceAudioencGetInternalError(
        pCtrl: *mut SceAudioencCtrl,
        pInternalError: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
