/* automatically generated by rust-bindgen 0.65.1 */

#[allow(unused_imports)]
use crate::psp2::kernel::cpu::*;
#[allow(unused_imports)]
use crate::psp2::types::*;
#[allow(unused_imports)]
use crate::psp2common::types::*;

pub const SCE_KERNEL_THREAD_CPU_AFFINITY_MASK_DEFAULT: u32 = 0;
pub type SceKernelThreadEntry = ::core::option::Option<
    unsafe extern "C" fn(args: SceSize, argp: *mut crate::ctypes::c_void) -> crate::ctypes::c_int,
>;
#[repr(C)]
pub struct SceKernelThreadOptParam {
    pub size: SceSize,
    pub attr: SceUInt32,
}
#[repr(C)]
pub struct SceKernelThreadInfo {
    pub size: SceSize,
    pub processId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt32,
    pub status: SceUInt32,
    pub entry: SceKernelThreadEntry,
    pub stack: *mut crate::ctypes::c_void,
    pub stackSize: SceInt32,
    pub initPriority: SceInt32,
    pub currentPriority: SceInt32,
    pub initCpuAffinityMask: SceInt32,
    pub currentCpuAffinityMask: SceInt32,
    pub currentCpuId: SceInt32,
    pub lastExecutedCpuId: SceInt32,
    pub waitType: SceUInt32,
    pub waitId: SceUID,
    pub exitStatus: SceInt32,
    pub runClocks: SceKernelSysClock,
    pub intrPreemptCount: SceUInt32,
    pub threadPreemptCount: SceUInt32,
    pub threadReleaseCount: SceUInt32,
    pub changeCpuCount: SceInt32,
    pub fNotifyCallback: SceInt32,
    pub reserved: SceInt32,
}
#[repr(C)]
pub struct SceKernelThreadRunStatus {
    pub size: SceSize,
    pub cpuInfo: [SceKernelThreadRunStatus__bindgen_ty_1; 4usize],
}
#[repr(C)]
pub struct SceKernelThreadRunStatus__bindgen_ty_1 {
    pub processId: SceUID,
    pub threadId: SceUID,
    pub priority: crate::ctypes::c_int,
}
pub mod SceThreadStatus {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_THREAD_RUNNING: Type = 1;
    pub const SCE_THREAD_READY: Type = 2;
    pub const SCE_THREAD_STANDBY: Type = 4;
    pub const SCE_THREAD_WAITING: Type = 8;
    pub const SCE_THREAD_SUSPEND: Type = 8;
    pub const SCE_THREAD_DORMANT: Type = 16;
    pub const SCE_THREAD_STOPPED: Type = 16;
    pub const SCE_THREAD_DELETED: Type = 32;
    pub const SCE_THREAD_KILLED: Type = 32;
    pub const SCE_THREAD_DEAD: Type = 64;
    pub const SCE_THREAD_STAGNANT: Type = 128;
    pub const SCE_THREAD_SUSPENDED: Type = 256;
}
pub mod SceKernelWaitableAttribute {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_KERNEL_ATTR_THREAD_FIFO: Type = 0;
    pub const SCE_KERNEL_ATTR_THREAD_PRIO: Type = 8192;
    pub const SCE_KERNEL_ATTR_OPENABLE: Type = 128;
}
pub mod SceEventFlagAttributes {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_EVENT_THREAD_FIFO: Type = 0;
    pub const SCE_EVENT_THREAD_PRIO: Type = 8192;
    pub const SCE_EVENT_WAITSINGLE: Type = 0;
    pub const SCE_EVENT_WAITMULTIPLE: Type = 4096;
    pub const SCE_EVENT_OPENABLE: Type = 128;
}
pub mod SceKernelMutexAttribute {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_KERNEL_MUTEX_ATTR_RECURSIVE: Type = 2;
    pub const SCE_KERNEL_MUTEX_ATTR_CEILING: Type = 4;
}
extern "C" {
    pub fn sceKernelCreateThread(
        name: *const crate::ctypes::c_char,
        entry: SceKernelThreadEntry,
        initPriority: crate::ctypes::c_int,
        stackSize: SceSize,
        attr: SceUInt,
        cpuAffinityMask: crate::ctypes::c_int,
        option: *const SceKernelThreadOptParam,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelDeleteThread(thid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelStartThread(
        thid: SceUID,
        arglen: SceSize,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelExitThread(status: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelExitDeleteThread(status: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitThreadEnd(
        thid: SceUID,
        stat: *mut crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitThreadEndCB(
        thid: SceUID,
        stat: *mut crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelDelayThread(delay: SceUInt) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelDelayThreadCB(delay: SceUInt) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelChangeCurrentThreadAttr(
        clearAttr: SceUInt,
        setAttr: SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelChangeThreadPriority(
        thid: SceUID,
        priority: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetThreadId() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetProcessId() -> SceUID;
}
extern "C" {
    pub fn sceKernelGetThreadCurrentPriority() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetThreadExitStatus(
        thid: SceUID,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCheckThreadStack() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetThreadStackFreeSize(thid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetThreadInfo(
        thid: SceUID,
        info: *mut SceKernelThreadInfo,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetThreadRunStatus(
        thid: SceUID,
        status: *mut SceKernelThreadRunStatus,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetThreadCpuAffinityMask(thid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelChangeThreadCpuAffinityMask(
        thid: SceUID,
        mask: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelSemaOptParam {
    pub size: SceSize,
}
#[repr(C)]
pub struct SceKernelSemaInfo {
    pub size: SceSize,
    pub semaId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub initCount: crate::ctypes::c_int,
    pub currentCount: crate::ctypes::c_int,
    pub maxCount: crate::ctypes::c_int,
    pub numWaitThreads: crate::ctypes::c_int,
}
extern "C" {
    pub fn sceKernelCreateSema(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        initVal: crate::ctypes::c_int,
        maxVal: crate::ctypes::c_int,
        option: *mut SceKernelSemaOptParam,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelDeleteSema(semaid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalSema(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitSema(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitSemaCB(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelPollSema(semaid: SceUID, signal: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCancelSema(
        semaid: SceUID,
        setCount: crate::ctypes::c_int,
        numWaitThreads: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetSemaInfo(
        semaid: SceUID,
        info: *mut SceKernelSemaInfo,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelOpenSema(name: *const crate::ctypes::c_char) -> SceUID;
}
extern "C" {
    pub fn sceKernelCloseSema(semaid: SceUID) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelMutexOptParam {
    pub size: SceSize,
    pub ceilingPriority: crate::ctypes::c_int,
}
#[repr(C)]
pub struct SceKernelMutexInfo {
    pub size: SceSize,
    pub mutexId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub initCount: crate::ctypes::c_int,
    pub currentCount: crate::ctypes::c_int,
    pub currentOwnerId: SceUID,
    pub numWaitThreads: crate::ctypes::c_int,
}
extern "C" {
    pub fn sceKernelCreateMutex(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        initCount: crate::ctypes::c_int,
        option: *mut SceKernelMutexOptParam,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelDeleteMutex(mutexid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelOpenMutex(name: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCloseMutex(mutexid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockMutex(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockMutexCB(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelTryLockMutex(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelUnlockMutex(
        mutexid: SceUID,
        unlockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCancelMutex(
        mutexid: SceUID,
        newCount: crate::ctypes::c_int,
        numWaitThreads: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetMutexInfo(
        mutexid: SceUID,
        info: *mut SceKernelMutexInfo,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelEventFlagInfo {
    pub size: SceSize,
    pub evfId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub initPattern: SceUInt,
    pub currentPattern: SceUInt,
    pub numWaitThreads: crate::ctypes::c_int,
}
#[repr(C)]
pub struct SceKernelEventFlagOptParam {
    pub size: SceSize,
}
pub mod SceEventFlagWaitTypes {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_EVENT_WAITAND: Type = 0;
    pub const SCE_EVENT_WAITOR: Type = 1;
    pub const SCE_EVENT_WAITCLEAR: Type = 2;
    pub const SCE_EVENT_WAITCLEAR_PAT: Type = 4;
}
extern "C" {
    pub fn sceKernelCreateEventFlag(
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_int,
        bits: crate::ctypes::c_int,
        opt: *mut SceKernelEventFlagOptParam,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelSetEventFlag(evid: SceUID, bits: crate::ctypes::c_uint)
        -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelClearEventFlag(
        evid: SceUID,
        bits: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelPollEventFlag(
        evid: crate::ctypes::c_int,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitEventFlag(
        evid: crate::ctypes::c_int,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitEventFlagCB(
        evid: crate::ctypes::c_int,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelDeleteEventFlag(evid: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetEventFlagInfo(
        event: SceUID,
        info: *mut SceKernelEventFlagInfo,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelCondOptParam {
    pub size: SceSize,
}
#[repr(C)]
pub struct SceKernelCondInfo {
    pub size: SceSize,
    pub condId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub mutexId: SceUID,
    pub numWaitThreads: crate::ctypes::c_int,
}
extern "C" {
    pub fn sceKernelCreateCond(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        mutexId: SceUID,
        option: *const SceKernelCondOptParam,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelDeleteCond(condId: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelOpenCond(name: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCloseCond(condId: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitCond(
        condId: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitCondCB(
        condId: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalCond(condId: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalCondAll(condId: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalCondTo(condId: SceUID, threadId: SceUID) -> crate::ctypes::c_int;
}
pub type SceKernelCallbackFunction = ::core::option::Option<
    unsafe extern "C" fn(
        notifyId: crate::ctypes::c_int,
        notifyCount: crate::ctypes::c_int,
        notifyArg: crate::ctypes::c_int,
        userData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
#[repr(C)]
pub struct SceKernelCallbackInfo {
    pub size: SceSize,
    pub callbackId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub threadId: SceUID,
    pub callback: SceKernelCallbackFunction,
    pub common: *mut crate::ctypes::c_void,
    pub notifyCount: crate::ctypes::c_int,
    pub notifyArg: crate::ctypes::c_int,
}
extern "C" {
    pub fn sceKernelCreateCallback(
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        func: SceKernelCallbackFunction,
        userData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetCallbackInfo(
        cb: SceUID,
        infop: *mut SceKernelCallbackInfo,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelDeleteCallback(cb: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelNotifyCallback(cb: SceUID, arg2: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCancelCallback(cb: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetCallbackCount(cb: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCheckCallback() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCreateMsgPipe(
        name: *const crate::ctypes::c_char,
        type_: crate::ctypes::c_int,
        attr: crate::ctypes::c_int,
        bufSize: crate::ctypes::c_uint,
        opt: *mut crate::ctypes::c_void,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelDeleteMsgPipe(uid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSendMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSendMsgPipeCB(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelTrySendMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelReceiveMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelReceiveMsgPipeCB(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelTryReceiveMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelCancelMsgPipe(
        uid: SceUID,
        psend: *mut crate::ctypes::c_int,
        precv: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelMppInfo {
    pub size: SceSize,
    pub mppId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub bufSize: crate::ctypes::c_int,
    pub freeSize: crate::ctypes::c_int,
    pub numSendWaitThreads: crate::ctypes::c_int,
    pub numReceiveWaitThreads: crate::ctypes::c_int,
}
extern "C" {
    pub fn sceKernelGetMsgPipeInfo(
        uid: SceUID,
        info: *mut SceKernelMppInfo,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelSystemInfo {
    pub size: SceSize,
    pub activeCpuMask: SceUInt32,
    pub cpuInfo: [SceKernelSystemInfo__bindgen_ty_1; 4usize],
}
#[repr(C)]
pub struct SceKernelSystemInfo__bindgen_ty_1 {
    pub idleClock: SceKernelSysClock,
    pub comesOutOfIdleCount: SceUInt32,
    pub threadSwitchCount: SceUInt32,
}
extern "C" {
    pub fn sceKernelGetSystemInfo(info: *mut SceKernelSystemInfo) -> crate::ctypes::c_int;
}
pub mod SceKernelIdListType {
    pub type Type = crate::ctypes::c_uint;
    pub const SCE_KERNEL_TMID_Thread: Type = 1;
    pub const SCE_KERNEL_TMID_Semaphore: Type = 2;
    pub const SCE_KERNEL_TMID_EventFlag: Type = 3;
    pub const SCE_KERNEL_TMID_Mbox: Type = 4;
    pub const SCE_KERNEL_TMID_Vpl: Type = 5;
    pub const SCE_KERNEL_TMID_Fpl: Type = 6;
    pub const SCE_KERNEL_TMID_Mpipe: Type = 7;
    pub const SCE_KERNEL_TMID_Callback: Type = 8;
    pub const SCE_KERNEL_TMID_ThreadEventHandler: Type = 9;
    pub const SCE_KERNEL_TMID_Alarm: Type = 10;
    pub const SCE_KERNEL_TMID_VTimer: Type = 11;
    pub const SCE_KERNEL_TMID_SleepThread: Type = 64;
    pub const SCE_KERNEL_TMID_DelayThread: Type = 65;
    pub const SCE_KERNEL_TMID_SuspendThread: Type = 66;
    pub const SCE_KERNEL_TMID_DormantThread: Type = 67;
}
extern "C" {
    pub fn sceKernelGetThreadmgrUIDClass(uid: SceUID) -> SceKernelIdListType::Type;
}
#[repr(C)]
pub struct SceKernelLwMutexWork {
    pub data: [SceInt64; 4usize],
}
#[repr(C)]
pub struct SceKernelLwMutexOptParam {
    pub size: SceSize,
}
extern "C" {
    pub fn sceKernelCreateLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        pName: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        initCount: crate::ctypes::c_int,
        pOptParam: *const SceKernelLwMutexOptParam,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelDeleteLwMutex(pWork: *mut SceKernelLwMutexWork) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        lockCount: crate::ctypes::c_int,
        pTimeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelTryLockLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        lockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelUnlockLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        unlockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
pub struct SceKernelLwCondWork {
    pub data: [SceInt32; 4usize],
}
#[repr(C)]
pub struct SceKernelLwCondOptParam {
    pub size: SceSize,
}
extern "C" {
    pub fn sceKernelCreateLwCond(
        pWork: *mut SceKernelLwCondWork,
        pName: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        pLwMutex: *mut SceKernelLwMutexWork,
        pOptParam: *const SceKernelLwCondOptParam,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelDeleteLwCond(pWork: *mut SceKernelLwCondWork) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalLwCond(pWork: *mut SceKernelLwCondWork) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalLwCondAll(pWork: *mut SceKernelLwCondWork) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSignalLwCondTo(
        pWork: *mut SceKernelLwCondWork,
        threadId: SceUID,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitLwCond(
        pWork: *mut SceKernelLwCondWork,
        pTimeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelWaitSignal(
        unk0: SceUInt32,
        delay: SceUInt32,
        timeout: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelSendSignal(thid: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetSystemTimeWide() -> SceInt64;
}
extern "C" {
    pub fn sceKernelGetThreadTLSAddr(
        thid: SceUID,
        key: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn sceKernelGetTLSAddr(key: crate::ctypes::c_int) -> *mut crate::ctypes::c_void;
}
#[repr(C)]
pub struct SceKernelRWLockOptParam {
    pub size: SceSize,
}
#[repr(C)]
pub struct SceKernelRWLockInfo {
    pub size: SceSize,
    pub rwLockId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt32,
    pub lockCount: SceInt32,
    pub writeOwnerId: SceUID,
    pub numReadWaitThreads: SceUInt32,
    pub numWriteWaitThreads: SceUInt32,
}
extern "C" {
    pub fn sceKernelCreateRWLock(
        name: *const crate::ctypes::c_char,
        attr: SceUInt32,
        opt_param: *const SceKernelRWLockOptParam,
    ) -> SceUID;
}
extern "C" {
    pub fn sceKernelDeleteRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelOpenRWLock(name: *const crate::ctypes::c_char) -> SceUID;
}
extern "C" {
    pub fn sceKernelCloseRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockReadRWLock(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockWriteRWLock(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockReadRWLockCB(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelLockWriteRWLockCB(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelTryLockReadRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelTryLockWriteRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelUnlockReadRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelUnlockWriteRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sceKernelGetRWLockInfo(
        rwlock_id: SceUID,
        info: *mut SceKernelRWLockInfo,
    ) -> crate::ctypes::c_int;
}
