#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type _bindgen_ty_1 = crate::ctypes::c_uint;
pub type _bindgen_ty_2 = crate::ctypes::c_uint;
pub use self::SceAppUtilSaveDataRemoveMode as SceAppUtilSaveDataDataRemoveMode;
pub use self::SceAppUtilSaveDataSaveMode as SceAppUtilSaveDataDataSaveMode;
pub use self::SceHttpStatusCode as SceHttpStatuscode;
pub use self::SceHttpVersion as SceHttpHttpVersion;
pub use self::SceImeDialogErrorCode as SceImeDialogError;
#[doc = "Error Codes"]
pub use self::SceNotificationUitlErrorCode as SceNotificationUtilErrorCode;
pub use self::_ScePerfArmPmonEventCode as ScePerfArmPmonEventCode;
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ksceUsbdIsochPswLen {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl ksceUsbdIsochPswLen {
    #[inline]
    pub fn len(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_len(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn PSW(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PSW(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(len: u16, PSW: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let len: u16 = unsafe { ::core::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PSW: u16 = unsafe { ::core::mem::transmute(PSW) };
            PSW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ksceUsbdIsochTransfer {
    pub buffer_base: *mut crate::ctypes::c_void,
    pub relative_start_frame: i32,
    pub num_packets: i32,
    pub packets: [ksceUsbdIsochPswLen; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::ctypes::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MsgPipeRecvData {
    pub message: *mut crate::ctypes::c_void,
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MsgPipeSendData {
    pub message: *const crate::ctypes::c_void,
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicExportParam {
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhotoExportParam {
    #[doc = "Version"]
    pub version: crate::ctypes::c_int,
    #[doc = "Photo title"]
    pub photoTitle: *const SceWChar32,
    #[doc = "Game title"]
    pub gameTitle: *const SceWChar32,
    #[doc = "Game description"]
    pub gameComment: *const SceWChar32,
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_int; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAesContext {
    pub data: [u8; 976usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAllocOpt {
    pub size: SceSize,
    pub data04: SceSize,
    pub align: SceSize,
    pub data0C: crate::ctypes::c_int,
    pub data10: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrAppInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrAppState {
    pub systemEventNum: SceUInt32,
    pub appEventNum: SceUInt32,
    pub isSystemUiOverlaid: SceBool,
    pub reserved: [SceUInt8; 116usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrBudgetInfo {
    #[doc = "Must be 0x88"]
    pub size: crate::ctypes::c_int,
    #[doc = "One of ::SceAppMgrApplicationMode"]
    pub app_mode: crate::ctypes::c_int,
    #[doc = "Unknown Data"]
    pub unk0: crate::ctypes::c_int,
    #[doc = "Total amount of accessible USER_RW memory"]
    pub total_user_rw_mem: crate::ctypes::c_uint,
    #[doc = "Free amount of accessible USER_RW memory"]
    pub free_user_rw: crate::ctypes::c_uint,
    #[doc = "Flag for extra memory accessibility"]
    pub extra_mem_allowed: SceBool,
    #[doc = "Unknown Data"]
    pub unk1: crate::ctypes::c_int,
    #[doc = "Total amount of accessible extra memory"]
    pub total_extra_mem: crate::ctypes::c_uint,
    #[doc = "Free amount of accessible extra memory"]
    pub free_extra_mem: crate::ctypes::c_uint,
    #[doc = "Unknown Data"]
    pub unk2: [crate::ctypes::c_int; 2usize],
    #[doc = "Total amount of accessible physically contiguous memory"]
    pub total_phycont_mem: crate::ctypes::c_uint,
    #[doc = "Free amount of accessible physically contiguous memory"]
    pub free_phycont_mem: crate::ctypes::c_uint,
    #[doc = "Unknown Data"]
    pub unk3: [crate::ctypes::c_int; 10usize],
    #[doc = "Total amount of accessible CDRAM memory"]
    pub total_cdram_mem: crate::ctypes::c_uint,
    #[doc = "Free amount of accessible CDRAM memory"]
    pub free_cdram_mem: crate::ctypes::c_uint,
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_int; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrCoredumpState {
    pub pid: SceUID,
    pub process_state: crate::ctypes::c_int,
    pub progress: crate::ctypes::c_int,
    pub is_coredump_completed: crate::ctypes::c_int,
    pub data_0x10: crate::ctypes::c_int,
    pub path_len: SceSize,
    pub path: [crate::ctypes::c_char; 1024usize],
    pub data_0x418: crate::ctypes::c_int,
    pub data_0x41C: crate::ctypes::c_int,
    pub data_0x420: crate::ctypes::c_int,
    pub data_0x424: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrDrmOpenParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrExecOptParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrLaunchAppOptParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrLaunchParam {
    pub size: SceSize,
    pub unk_4: crate::ctypes::c_uint,
    pub unk_8: crate::ctypes::c_uint,
    pub unk_C: crate::ctypes::c_uint,
    pub unk_10: crate::ctypes::c_uint,
    pub unk_14: crate::ctypes::c_uint,
    pub unk_18: crate::ctypes::c_uint,
    pub unk_1C: crate::ctypes::c_uint,
    pub unk_20: crate::ctypes::c_uint,
    pub unk_24: crate::ctypes::c_uint,
    pub unk_28: crate::ctypes::c_uint,
    pub unk_2C: crate::ctypes::c_uint,
    pub unk_30: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrLoadExecOptParam {
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_int; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrSaveDataData {
    #[doc = "Must be 0x4C"]
    pub size: crate::ctypes::c_int,
    #[doc = "Save slot to use"]
    pub slotId: crate::ctypes::c_uint,
    #[doc = "Save slot params"]
    pub slotParam: *mut SceAppUtilSaveDataSlotParam,
    #[doc = "Reserved data"]
    pub reserved: [u8; 32usize],
    #[doc = "Pointer to an array of files"]
    pub files: *mut SceAppUtilSaveDataFile,
    #[doc = "Number of files to save"]
    pub fileNum: crate::ctypes::c_int,
    #[doc = "Savedata mountpoint"]
    pub mountPoint: SceAppUtilSaveDataMountPoint,
    #[doc = "Required size in KBs"]
    pub requiredSizeKB: *mut crate::ctypes::c_uint,
    pub unk_0x48: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrSaveDataDataDelete {
    #[doc = "Must be 0x44"]
    pub size: crate::ctypes::c_int,
    #[doc = "Save slot to use"]
    pub slotId: crate::ctypes::c_uint,
    #[doc = "Save slot params"]
    pub slotParam: *mut SceAppUtilSaveDataSlotParam,
    #[doc = "Reserved data"]
    pub reserved: [u8; 32usize],
    #[doc = "Pointer to an array of files"]
    pub files: *mut SceAppUtilSaveDataFile,
    #[doc = "Number of files to delete"]
    pub fileNum: crate::ctypes::c_int,
    #[doc = "Savedata mountpoint"]
    pub mountPoint: SceAppUtilSaveDataMountPoint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrSaveDataSlot {
    #[doc = "Must be 0x418"]
    pub size: crate::ctypes::c_int,
    #[doc = "Save slot to use"]
    pub slotId: crate::ctypes::c_uint,
    #[doc = "Save slot params"]
    pub slotParam: SceAppUtilSaveDataSlotParam,
    #[doc = "Reserved data"]
    pub reserved: [u8; 116usize],
    #[doc = "Savedata mountpoint"]
    pub mountPoint: SceAppUtilSaveDataMountPoint,
    pub reserved2: [u8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrSaveDataSlotDelete {
    #[doc = "Must be 0x18"]
    pub size: crate::ctypes::c_int,
    #[doc = "Save slot to use"]
    pub slotId: crate::ctypes::c_uint,
    #[doc = "Savedata mountpoint"]
    pub mountPoint: SceAppUtilSaveDataMountPoint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppMgrSystemEvent {
    #[doc = "One of ::SceAppMgrSystemEventType"]
    pub systemEvent: crate::ctypes::c_int,
    #[doc = "Reserved data"]
    pub reserved: [u8; 60usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilAppEventParam {
    #[doc = "Event type"]
    pub type_: SceAppUtilAppEventType,
    #[doc = "Event parameter"]
    pub dat: [u8; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilBgdlStatus {
    pub type_: SceAppUtilBgdlStatusType,
    pub addcontNumReady: SceUInt32,
    pub addcontNumNotReady: SceUInt32,
    pub licenseReady: SceUInt32,
    pub reserved: [SceChar8; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilBootParam {
    #[doc = "Boot attribute"]
    pub attr: SceAppUtilBootAttribute,
    #[doc = "App version"]
    pub appVersion: crate::ctypes::c_uint,
    #[doc = "Reserved range"]
    pub reserved: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilInitParam {
    #[doc = "Buffer size"]
    pub workBufSize: SceSize,
    #[doc = "Reserved range"]
    pub reserved: [u8; 60usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilMountPoint {
    #[doc = "Mount point"]
    pub data: [i8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataFile {
    pub filePath: *const crate::ctypes::c_char,
    pub buf: *mut crate::ctypes::c_void,
    pub bufSize: SceSize,
    pub offset: SceOff,
    pub mode: crate::ctypes::c_uint,
    pub progDelta: crate::ctypes::c_uint,
    pub reserved: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataFileSlot {
    pub id: crate::ctypes::c_uint,
    pub slotParam: *mut SceAppUtilSaveDataSlotParam,
    pub reserved: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataMountPoint {
    pub data: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataRemoveItem {
    #[doc = "Path to savedata data"]
    pub dataPath: *const crate::ctypes::c_char,
    #[doc = "Savedata remove mode (One of ::SceAppUtilSaveDataRemoveMode)"]
    pub mode: crate::ctypes::c_int,
    #[doc = "Reserved range"]
    pub reserved: [u8; 36usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataSaveItem {
    #[doc = "Path to savedata"]
    pub dataPath: *const crate::ctypes::c_char,
    #[doc = "Buffer of savedata file"]
    pub buf: *const crate::ctypes::c_void,
    #[doc = "Padding"]
    pub pad: u32,
    #[doc = "Offset of savedata file"]
    pub offset: SceOff,
    #[doc = "Savedata save mode (One of ::SceAppUtilSaveDataSaveMode)"]
    pub mode: crate::ctypes::c_int,
    #[doc = "Reserved range"]
    pub reserved: [u8; 36usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataSlot {
    #[doc = "Slot id"]
    pub id: SceAppUtilSaveDataSlotId,
    #[doc = "Slot status"]
    pub status: SceAppUtilSaveDataSlotStatus,
    #[doc = "Param for free usage"]
    pub userParam: crate::ctypes::c_int,
    #[doc = "Settings for empty slot"]
    pub emptyParam: *mut SceAppUtilSaveDataSlotEmptyParam,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataSlotEmptyParam {
    #[doc = "Title string"]
    pub title: *mut SceWChar16,
    #[doc = "Path to icon"]
    pub iconPath: *mut crate::ctypes::c_char,
    #[doc = "Icon buffer"]
    pub iconBuf: *mut crate::ctypes::c_void,
    #[doc = "Icon buffer size"]
    pub iconBufSize: SceSize,
    #[doc = "Reserved range"]
    pub reserved: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilSaveDataSlotParam {
    #[doc = "Status"]
    pub status: SceAppUtilSaveDataSlotStatus,
    #[doc = "Title name"]
    pub title: [SceWChar16; 32usize],
    #[doc = "Subtitle"]
    pub subTitle: [SceWChar16; 64usize],
    #[doc = "Detail info"]
    pub detail: [SceWChar16; 256usize],
    #[doc = "Icon path"]
    pub iconPath: [crate::ctypes::c_char; 64usize],
    #[doc = "User param"]
    pub userParam: crate::ctypes::c_int,
    #[doc = "Data size (In KB)"]
    pub sizeKB: SceSize,
    #[doc = "Last modified time"]
    pub modifiedTime: SceDateTime,
    #[doc = "Reserved range"]
    pub reserved: [u8; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilStoreBrowseParam {
    #[doc = "Store browse type"]
    pub type_: crate::ctypes::c_uint,
    #[doc = "Target id"]
    pub id: *const crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAppUtilWebBrowserParam {
    #[doc = "String that's passed to command specified by launchMode"]
    pub str_: *const crate::ctypes::c_char,
    #[doc = "Length of str"]
    pub strlen: SceSize,
    #[doc = "Browser mode"]
    pub launchMode: crate::ctypes::c_uint,
    #[doc = "Reserved area"]
    pub reserved: crate::ctypes::c_uint,
}
#[doc = "Structure representing all ARM registers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceArmCpuRegisters {
    pub r0: u32,
    pub r1: u32,
    pub r2: u32,
    pub r3: u32,
    pub r4: u32,
    pub r5: u32,
    pub r6: u32,
    pub r7: u32,
    pub r8: u32,
    pub r9: u32,
    pub r10: u32,
    pub r11: u32,
    pub r12: u32,
    pub sp: u32,
    pub lr: u32,
    pub pc: u32,
    pub cpsr: u32,
    pub fpscr: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAtracContentInfo {
    pub size: SceUInt32,
    pub atracType: SceUInt32,
    pub channel: SceUInt32,
    pub samplingRate: SceUInt32,
    pub endSample: SceInt32,
    pub loopStartSample: SceInt32,
    pub loopEndSample: SceInt32,
    pub bitRate: SceUInt32,
    pub fixedEncBlockSize: SceUInt32,
    pub fixedEncBlockSample: SceUInt32,
    pub frameSample: SceUInt32,
    pub loopBlockOffset: SceUInt32,
    pub loopBlockSize: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAtracDecoderGroup {
    pub size: SceUInt32,
    pub wordLength: SceUInt32,
    pub totalCh: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAtracStreamInfo {
    pub size: SceUInt32,
    pub pWritePosition: *mut SceUChar8,
    pub readPosition: SceUInt32,
    pub writableSize: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecCtrl {
    pub size: SceUInt32,
    pub handle: SceInt32,
    #[doc = "pointer to elementary stream"]
    pub pEs: *mut SceUInt8,
    #[doc = "size of elementary stream used actually (in byte)"]
    pub inputEsSize: SceUInt32,
    #[doc = "maximum size of elementary stream used (in byte)"]
    pub maxEsSize: SceUInt32,
    #[doc = "pointer to PCM"]
    pub pPcm: *mut crate::ctypes::c_void,
    #[doc = "size of PCM output actually (in byte)"]
    pub outputPcmSize: SceUInt32,
    #[doc = "maximum size of PCM output (in byte)"]
    pub maxPcmSize: SceUInt32,
    #[doc = "PCM bit depth"]
    pub wordLength: SceUInt32,
    #[doc = "pointer to SceAudiodecInfo"]
    pub pInfo: *mut SceAudiodecInfo,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAudiodecInfo {
    pub size: SceUInt32,
    pub at9: SceAudiodecInfoAt9,
    pub mp3: SceAudiodecInfoMp3,
    pub aac: SceAudiodecInfoAac,
    pub celp: SceAudiodecInfoCelp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecInfoAac {
    pub size: SceUInt32,
    pub isAdts: SceUInt32,
    pub ch: SceUInt32,
    pub samplingRate: SceUInt32,
    pub isSbr: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecInfoAt9 {
    pub size: SceUInt32,
    pub configData: [SceUInt8; 4usize],
    pub ch: SceUInt32,
    pub bitRate: SceUInt32,
    pub samplingRate: SceUInt32,
    pub superFrameSize: SceUInt32,
    pub framesInSuperFrame: SceUInt32,
}
#[doc = "Information structure for CELP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecInfoCelp {
    #[doc = "sizeof(SceAudiodecInfoCelp)"]
    pub size: SceUInt32,
    #[doc = "Excitation mode"]
    pub excitationMode: SceUInt32,
    #[doc = "Sampling rate"]
    pub samplingRate: SceUInt32,
    #[doc = "Bit rate (one of ::SceAudiodecCelpBitrate)"]
    pub bitRate: SceUInt32,
    pub lostCount: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecInfoMp3 {
    #[doc = "sizeof(SceAudiodecInfoMp3)"]
    pub size: SceUInt32,
    #[doc = "number of channels (mono: 1, stereo/joint stereo/two mono: 2)"]
    pub ch: SceUInt32,
    #[doc = "MPEG version (MPEG1: 3, MPEG2: 2, MPEG2.5: 0)"]
    pub version: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecInitChParam {
    pub size: SceUInt32,
    pub totalCh: SceUInt32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAudiodecInitParam {
    pub size: SceUInt32,
    pub at9: SceAudiodecInitChParam,
    pub mp3: SceAudiodecInitStreamParam,
    pub aac: SceAudiodecInitStreamParam,
    pub celp: SceAudiodecInitStreamParam,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudiodecInitStreamParam {
    pub size: SceUInt32,
    pub totalStreams: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudioencCtrl {
    #[doc = "sizeof(SceAudioencCtrl)"]
    pub size: SceSize,
    #[doc = "Encoder handle"]
    pub handle: crate::ctypes::c_int,
    #[doc = "Pointer to elementary stream"]
    pub pInputPcm: *mut crate::ctypes::c_void,
    #[doc = "Size of elementary stream used actually (in byte)"]
    pub inputPcmSize: SceSize,
    #[doc = "Max size of elementary stream used (in byte)"]
    pub maxPcmSize: SceSize,
    #[doc = "Pointer to PCM"]
    pub pOutputEs: *mut crate::ctypes::c_void,
    #[doc = "Size of PCM output actually (in byte)"]
    pub outputEsSize: SceSize,
    #[doc = "Max size of PCM output (in byte)"]
    pub maxEsSize: SceSize,
    #[doc = "PCM bit depth"]
    pub wordLength: SceSize,
    #[doc = "Pointer to ::SceAudioencInfo"]
    pub pInfo: *mut SceAudioencInfo,
    #[doc = "Pointer to ::SceAudioencOptInfo"]
    pub pOptInfo: *mut SceAudioencOptInfo,
}
#[doc = "Audio encoder info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAudioencInfo {
    #[doc = "sizeof(SceAudioencInfo)"]
    pub size: SceSize,
    #[doc = "Information structure for CELP"]
    pub celp: SceAudioencInfoCelp,
}
#[doc = "Information structure for CELP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudioencInfoCelp {
    #[doc = "sizeof(SceAudioencInfoCelp)"]
    pub size: SceSize,
    #[doc = "Excitation mode"]
    pub excitationMode: crate::ctypes::c_uint,
    #[doc = "Sampling rate"]
    pub samplingRate: crate::ctypes::c_uint,
    #[doc = "Bit rate (one of ::SceAudioencCelpBitrate)"]
    pub bitRate: crate::ctypes::c_uint,
}
#[doc = "Initialization structure to pass as argument to ::sceAudioencInitLibrary"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAudioencInitParam {
    #[doc = "sizeof(SceAudioencInitParam)"]
    pub size: SceSize,
    #[doc = "See ::SceAudioencInitStreamParam"]
    pub celp: SceAudioencInitStreamParam,
}
#[doc = "Initialization structure to provide to ::SceAudioencInitParam"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudioencInitStreamParam {
    #[doc = "sizeof(SceAudioencInitStreamParam)"]
    pub size: SceSize,
    #[doc = "Total number of audio streams"]
    pub totalStreams: crate::ctypes::c_uint,
}
#[doc = "Audio encoder optional info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAudioencOptInfo {
    #[doc = "sizeof(SceAudioencOptInfo)"]
    pub size: SceSize,
    #[doc = "Optional information structure for CELP"]
    pub celp: SceAudioencOptInfoCelp,
}
#[doc = "Optional information structure for CELP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAudioencOptInfoCelp {
    #[doc = "sizeof(SceAudioencOptInfoCelp)"]
    pub size: SceSize,
    #[doc = "Header buffer"]
    pub header: [u8; 32usize],
    #[doc = "Header size"]
    pub headerSize: SceSize,
    #[doc = "Encoder version"]
    pub encoderVersion: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAuthInfo {
    pub unk_0x00: SceUInt32,
    pub self_type: SceUInt32,
    pub request: SceSelfAuthInfo,
    pub response: SceSelfAuthInfo,
    pub media_type: SceUInt32,
    pub unk_0x12C: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecArrayPicture {
    #[doc = "Number of outputs"]
    pub numOfOutput: u32,
    #[doc = "Number of elements"]
    pub numOfElm: u32,
    pub pPicture: *mut *mut SceAvcdecPicture,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecAu {
    pub pts: SceVideodecTimeStamp,
    pub dts: SceVideodecTimeStamp,
    pub es: SceAvcdecBuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecBuf {
    pub pBuf: *mut crate::ctypes::c_void,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecCtrl {
    pub handle: u32,
    pub frameBuf: SceAvcdecBuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecDecoderInfo {
    pub frameMemSize: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceAvcdecFrame {
    #[doc = "One of ::SceAvcdecPixelFormat"]
    pub pixelType: u32,
    pub framePitch: u32,
    pub frameWidth: u32,
    pub frameHeight: u32,
    pub horizontalSize: u32,
    pub verticalSize: u32,
    pub frameCropLeftOffset: u32,
    pub frameCropRightOffset: u32,
    pub frameCropTopOffset: u32,
    pub frameCropBottomOffset: u32,
    pub opt: SceAvcdecFrameOption,
    #[doc = "address of picture buffer"]
    pub pPicture: [*mut crate::ctypes::c_void; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAvcdecFrameOption {
    pub reserved: [u8; 16usize],
    pub rgba: SceAvcdecFrameOptionRGBA,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecFrameOptionRGBA {
    pub alpha: u8,
    pub cscCoefficient: u8,
    pub reserved: [u8; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecInfo {
    pub numUnitsInTick: u32,
    pub timeScale: u32,
    pub fixedFrameRateFlag: u8,
    pub aspectRatioIdc: u8,
    pub sarWidth: u16,
    pub sarHeight: u16,
    pub colourPrimaries: u8,
    pub transferCharacteristics: u8,
    pub matrixCoefficients: u8,
    pub videoFullRangeFlag: u8,
    pub picStruct: [u8; 2usize],
    pub ctType: u8,
    pub pts: SceVideodecTimeStamp,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceAvcdecPicture {
    pub size: u32,
    pub frame: SceAvcdecFrame,
    pub info: SceAvcdecInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvcdecQueryDecoderInfo {
    pub horizontal: u32,
    pub vertical: u32,
    #[doc = "Number of reference frames"]
    pub numOfRefFrames: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerAudio {
    #[doc = "The number of audio channels of the audio frame."]
    pub channelCount: u16,
    #[doc = "Reserved data."]
    pub reserved: [u8; 2usize],
    #[doc = "The samplerate of the audio frame in Hz."]
    pub sampleRate: u32,
    #[doc = "The size of the audio frame in bytes."]
    pub size: u32,
    #[doc = "The language code of the audio frame."]
    pub languageCode: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerEventReplacement {
    pub objectPointer: *mut crate::ctypes::c_void,
    pub eventCallback: SceAvPlayerEventCallback,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerFileReplacement {
    pub objectPointer: *mut crate::ctypes::c_void,
    #[doc = "File open"]
    pub open: SceAvPlayerOpenFile,
    #[doc = "File close"]
    pub close: SceAvPlayerCloseFile,
    #[doc = "File read from offset"]
    pub readOffset: SceAvPlayerReadOffsetFile,
    #[doc = "File size"]
    pub size: SceAvPlayerSizeFile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceAvPlayerFrameInfo {
    #[doc = "Pointer to the frame data."]
    pub pData: *mut u8,
    #[doc = "Reserved data"]
    pub reserved: u32,
    #[doc = "Timestamp of the frame in milliseconds"]
    pub timeStamp: u64,
    #[doc = "The frame details."]
    pub details: SceAvPlayerStreamDetails,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerInitData {
    #[doc = "Memory allocator replacement"]
    pub memoryReplacement: SceAvPlayerMemReplacement,
    #[doc = "File I/O replacement"]
    pub fileReplacement: SceAvPlayerFileReplacement,
    #[doc = "Event callback replacement"]
    pub eventReplacement: SceAvPlayerEventReplacement,
    pub debugLevel: i32,
    #[doc = "Base priority of the thread running the video player"]
    pub basePriority: u32,
    pub numOutputVideoFrameBuffers: i32,
    #[doc = "Flag indicating whether the video player should start playback automatically"]
    pub autoStart: SceBool,
    #[doc = "Reserved data"]
    pub reserved: [u8; 3usize],
    pub defaultLanguage: *const crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerMemReplacement {
    pub objectPointer: *mut crate::ctypes::c_void,
    #[doc = "Memory allocator for generic data"]
    pub allocate: SceAvPlayerAlloc,
    #[doc = "Memory deallocator for generic data"]
    pub deallocate: SceAvPlayerFree,
    #[doc = "Memory allocator for video frames"]
    pub allocateTexture: SceAvPlayerAllocFrame,
    #[doc = "Memory deallocator for video frames"]
    pub deallocateTexture: SceAvPlayerFreeFrame,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceAvPlayerStreamDetails {
    #[doc = "Reserved data."]
    pub reserved: [u32; 4usize],
    #[doc = "Audio details."]
    pub audio: SceAvPlayerAudio,
    #[doc = "Video details."]
    pub video: SceAvPlayerVideo,
    #[doc = "Subtitles details."]
    pub subs: SceAvPlayerTimedText,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceAvPlayerStreamInfo {
    #[doc = "Type of the stream (One of ::SceAvPlayerStreamType)"]
    pub type_: u32,
    #[doc = "Reserved data"]
    pub reserved: u32,
    #[doc = "The stream details."]
    pub details: SceAvPlayerStreamDetails,
    #[doc = "Total duration of the stream in milliseconds."]
    pub duration: u64,
    #[doc = "Starting time of the stream in milliseconds."]
    pub startTime: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerTextPosition {
    pub top: u16,
    pub left: u16,
    pub bottom: u16,
    pub right: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerTimedText {
    #[doc = "The language code of the subtitles."]
    pub languageCode: u32,
    #[doc = "The size of the subtitles."]
    pub textSize: u16,
    #[doc = "The size of the subtitles."]
    pub fontSize: u16,
    #[doc = "The position of the subtitles."]
    pub position: SceAvPlayerTextPosition,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceAvPlayerVideo {
    #[doc = "The width of the video frame in pixels."]
    pub width: u32,
    #[doc = "The height of the video frame in pixels."]
    pub height: u32,
    #[doc = "The aspect ratio of the video frame."]
    pub aspectRatio: f32,
    #[doc = "The language code of the video frame."]
    pub languageCode: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceBtEvent {
    pub __bindgen_anon_1: SceBtEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceBtEvent__bindgen_ty_1 {
    pub data: [crate::ctypes::c_uchar; 16usize],
    pub __bindgen_anon_1: SceBtEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceBtEvent__bindgen_ty_1__bindgen_ty_1 {
    pub id: crate::ctypes::c_uchar,
    pub unk1: crate::ctypes::c_uchar,
    pub unk2: crate::ctypes::c_ushort,
    pub unk3: crate::ctypes::c_uint,
    pub mac0: crate::ctypes::c_uint,
    pub mac1: crate::ctypes::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SceBtHidRequest {
    pub unk00: u32,
    pub unk04: u32,
    #[doc = "0 = read?, 1 = write?, 2 = feature?, 3 = ?"]
    pub type_: u8,
    pub unk09: u8,
    pub unk0A: u8,
    pub unk0B: u8,
    pub buffer: *mut crate::ctypes::c_void,
    pub length: u32,
    pub next: *mut _SceBtHidRequest,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceBtRegisteredInfo {
    pub mac: [crate::ctypes::c_uchar; 6usize],
    pub unk0: crate::ctypes::c_ushort,
    pub bt_class: crate::ctypes::c_uint,
    pub unk1: crate::ctypes::c_uint,
    pub unk2: crate::ctypes::c_uint,
    pub vid: crate::ctypes::c_ushort,
    pub pid: crate::ctypes::c_ushort,
    pub unk3: crate::ctypes::c_uint,
    pub unk4: crate::ctypes::c_uint,
    pub name: [crate::ctypes::c_char; 128usize],
    pub unk5: [crate::ctypes::c_uchar; 96usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCameraInfo {
    #[doc = "sizeof(SceCameraInfo)"]
    pub size: SceSize,
    #[doc = "Process priority (one of ::SceCameraPriority)"]
    pub priority: u16,
    #[doc = "Output format (One or more ::SceCameraFormat)"]
    pub format: u16,
    #[doc = "Resolution (one of ::SceCameraResolution)"]
    pub resolution: u16,
    #[doc = "Framerate (one of ::SceCameraFrameRate)"]
    pub framerate: u16,
    pub width: u16,
    pub height: u16,
    pub range: u16,
    #[doc = "Structure padding"]
    pub pad: u16,
    pub sizeIBase: SceSize,
    pub sizeUBase: SceSize,
    pub sizeVBase: SceSize,
    pub pIBase: *mut crate::ctypes::c_void,
    pub pUBase: *mut crate::ctypes::c_void,
    pub pVBase: *mut crate::ctypes::c_void,
    pub pitch: u16,
    pub buffer: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCameraRead {
    #[doc = "sizeof(SceCameraRead)"]
    pub size: SceSize,
    pub mode: crate::ctypes::c_int,
    pub pad: crate::ctypes::c_int,
    pub status: crate::ctypes::c_int,
    pub frame: u64,
    pub timestamp: u64,
    pub sizeIBase: SceSize,
    pub sizeUBase: SceSize,
    pub sizeVBase: SceSize,
    pub pIBase: *mut crate::ctypes::c_void,
    pub pUBase: *mut crate::ctypes::c_void,
    pub pVBase: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceClass {
    pub next: *mut SceClass,
    pub root: *mut SceClass,
    pub prev: *mut SceClass,
    pub name: *const crate::ctypes::c_char,
    pub uidclass: *mut SceClass,
    pub attributes: crate::ctypes::c_uint,
    pub itemsize: crate::ctypes::c_ushort,
    pub itemsize_aligned: crate::ctypes::c_ushort,
    pub unk1C: crate::ctypes::c_uint,
    pub create_cb: SceClassCallback,
    pub destroy_cb: SceClassCallback,
    pub magic: crate::ctypes::c_uint,
}
#[doc = "Structure for stats of SceClibMspace"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceClibMspaceStats {
    #[doc = "Capacity of the Mspace"]
    pub capacity: SceSize,
    #[doc = "Unknown, value is equal to capacity"]
    pub unk: SceSize,
    #[doc = "Peak memory allocated"]
    pub peak_in_use: SceSize,
    #[doc = "Current memory allocated"]
    pub current_in_use: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCommonDialogColor {
    pub r: SceUInt8,
    pub g: SceUInt8,
    pub b: SceUInt8,
    pub a: SceUInt8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCommonDialogConfigParam {
    pub sdkVersion: SceUInt32,
    pub language: SceSystemParamLang,
    pub enterButtonAssign: SceSystemParamEnterButtonAssign,
    pub reserved: [SceUInt8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCommonDialogInfobarParam {
    pub visibility: SceInt32,
    pub color: SceInt32,
    pub transparency: SceInt32,
    pub reserved: [SceUInt8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCommonDialogParam {
    pub infobarParam: *mut SceCommonDialogInfobarParam,
    pub bgColor: *mut SceCommonDialogColor,
    pub dimmerColor: *mut SceCommonDialogColor,
    pub reserved: [SceUInt8; 60usize],
    pub magic: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCommonDialogRenderTargetInfo {
    pub depthSurfaceData: ScePVoid,
    pub colorSurfaceData: ScePVoid,
    pub surfaceType: SceGxmColorSurfaceType,
    pub colorFormat: SceGxmColorFormat,
    pub width: SceUInt32,
    pub height: SceUInt32,
    pub strideInPixels: SceUInt32,
    pub reserved: [SceUInt8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCommonDialogUpdateParam {
    pub renderTarget: SceCommonDialogRenderTargetInfo,
    pub displaySyncObject: *mut SceGxmSyncObject,
    pub reserved: [SceUInt8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCompatCdram {
    pub cached_cdram: *mut crate::ctypes::c_void,
    pub uncached_cdram: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceConsoleId {
    pub unk: u16,
    pub company_code: u16,
    pub product_code: u16,
    pub product_sub_code: u16,
    pub __bindgen_anon_1: SceConsoleId__bindgen_ty_1,
    pub unk3: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceConsoleId__bindgen_ty_1 {
    pub __bindgen_anon_1: SceConsoleId__bindgen_ty_1__bindgen_ty_1,
    pub chassis_check: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceConsoleId__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl SceConsoleId__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn unk2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_unk2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn factory_code(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_factory_code(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(unk2: u8, factory_code: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let unk2: u8 = unsafe { ::core::mem::transmute(unk2) };
            unk2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let factory_code: u8 = unsafe { ::core::mem::transmute(factory_code) };
            factory_code as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCoredumpTriggerParam {
    pub size: SceSize,
    pub data_0x04: crate::ctypes::c_int,
    pub data_0x08: crate::ctypes::c_int,
    pub data_0x0C: crate::ctypes::c_int,
    pub data_0x10: crate::ctypes::c_int,
    pub titleid_len: SceSize,
    pub titleid: *const crate::ctypes::c_char,
    pub app_name_len: SceSize,
    pub app_name: *const crate::ctypes::c_char,
    pub data_0x24: crate::ctypes::c_int,
    pub data_0x28: crate::ctypes::c_int,
    pub crash_thid: SceUID,
    pub data_0x30: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCorelockContext {
    pub lock: crate::ctypes::c_int,
    pub core_count: i16,
    pub last_wait_core: i16,
}
#[doc = "Structure to pass as argument to ::sceCtrlSetActuator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCtrlActuator {
    #[doc = "Vibration strength of the small motor"]
    pub small: crate::ctypes::c_uchar,
    #[doc = "Vibration strength of the large motor"]
    pub large: crate::ctypes::c_uchar,
    #[doc = "Unknown"]
    pub unk: [u8; 6usize],
}
#[doc = "Returned controller data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCtrlData {
    #[doc = "The current read frame."]
    pub timeStamp: u64,
    #[doc = "Bit mask containing zero or more of ::SceCtrlButtons."]
    pub buttons: crate::ctypes::c_uint,
    #[doc = "Left analogue stick, X axis."]
    pub lx: crate::ctypes::c_uchar,
    #[doc = "Left analogue stick, Y axis."]
    pub ly: crate::ctypes::c_uchar,
    #[doc = "Right analogue stick, X axis."]
    pub rx: crate::ctypes::c_uchar,
    #[doc = "Right analogue stick, Y axis."]
    pub ry: crate::ctypes::c_uchar,
    #[doc = "Up button"]
    pub up: u8,
    #[doc = "Right button"]
    pub right: u8,
    #[doc = "Down button"]
    pub down: u8,
    #[doc = "Left button"]
    pub left: u8,
    #[doc = "Left trigger (L2)"]
    pub lt: u8,
    #[doc = "Right trigger (R2)"]
    pub rt: u8,
    #[doc = "Left button (L1)"]
    pub l1: u8,
    #[doc = "Right button (R1)"]
    pub r1: u8,
    #[doc = "Triangle button"]
    pub triangle: u8,
    #[doc = "Circle button"]
    pub circle: u8,
    #[doc = "Cross button"]
    pub cross: u8,
    #[doc = "Square button"]
    pub square: u8,
    #[doc = "Reserved."]
    pub reserved: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCtrlDataPsp {
    pub TimeStamp: crate::ctypes::c_uint,
    pub Buttons: crate::ctypes::c_uint,
    pub Lx: crate::ctypes::c_uchar,
    pub Ly: crate::ctypes::c_uchar,
    pub Rx: crate::ctypes::c_uchar,
    pub Ry: crate::ctypes::c_uchar,
    pub Rsrv: [crate::ctypes::c_uchar; 4usize],
}
#[doc = "Structure to pass as argument to ::sceCtrlGetControllerPortInfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCtrlPortInfo {
    #[doc = "Controller type of each port (See ::SceCtrlExternalInputMode)"]
    pub port: [u8; 5usize],
    #[doc = "Unknown"]
    pub unk: [u8; 11usize],
}
#[doc = "Structure to pass as argument to ::sceCtrlSetRapidFire"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCtrlRapidFireRule {
    pub Mask: crate::ctypes::c_uint,
    pub Trigger: crate::ctypes::c_uint,
    pub Target: crate::ctypes::c_uint,
    pub Delay: crate::ctypes::c_uint,
    pub Make: crate::ctypes::c_uint,
    pub Break: crate::ctypes::c_uint,
}
#[doc = "Structure to pass as argument to ::ksceCtrlRegisterVirtualControllerDriver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceCtrlVirtualControllerDriver {
    pub readButtons: ::core::option::Option<
        unsafe extern "C" fn(
            port: crate::ctypes::c_int,
            pad_data: *mut SceCtrlData,
            count: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub setActuator: ::core::option::Option<
        unsafe extern "C" fn(
            port: crate::ctypes::c_int,
            pState: *const SceCtrlActuator,
        ) -> crate::ctypes::c_int,
    >,
    pub getBatteryInfo: ::core::option::Option<
        unsafe extern "C" fn(
            port: crate::ctypes::c_int,
            batt: *mut SceUInt8,
        ) -> crate::ctypes::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(port: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub setTurnOffInterval: ::core::option::Option<
        unsafe extern "C" fn(port: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub getActiveControllerPort:
        ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub changePortAssign: ::core::option::Option<
        unsafe extern "C" fn(
            port1: crate::ctypes::c_int,
            port2: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk0: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub getControllerPortInfo: ::core::option::Option<
        unsafe extern "C" fn(info: *mut SceCtrlPortInfo) -> crate::ctypes::c_int,
    >,
    pub setLightBar: ::core::option::Option<
        unsafe extern "C" fn(
            port: crate::ctypes::c_int,
            r: SceUInt8,
            g: SceUInt8,
            b: SceUInt8,
        ) -> crate::ctypes::c_int,
    >,
    pub resetLightBar: ::core::option::Option<
        unsafe extern "C" fn(port: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub unk1: ::core::option::Option<
        unsafe extern "C" fn(port: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub singleControllerMode: ::core::option::Option<
        unsafe extern "C" fn(port: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceDateTime {
    pub year: crate::ctypes::c_ushort,
    pub month: crate::ctypes::c_ushort,
    pub day: crate::ctypes::c_ushort,
    pub hour: crate::ctypes::c_ushort,
    pub minute: crate::ctypes::c_ushort,
    pub second: crate::ctypes::c_ushort,
    pub microsecond: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceDeflatePartialInputParam {
    pub size: u32,
    pub pBufEnd: *const crate::ctypes::c_void,
    pub cookie: *mut crate::ctypes::c_void,
    pub SceDeflateDecompressPartialInputCallback: ::core::option::Option<
        unsafe extern "C" fn(
            param: *mut SceDeflatePartialInputParam,
            outputsize: u32,
        ) -> *const crate::ctypes::c_void,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceDipsw {
    pub cp_timestamp_1: u32,
    pub cp_version: u16,
    pub cp_build_id: u16,
    pub cp_timestamp_2: u32,
    pub aslr_seed: u32,
    pub sce_sdk_flags: u32,
    pub shell_flags: u32,
    pub debug_control_flags: u32,
    pub system_control_flags: u32,
}
#[doc = "Structure used with ::ksceDisplaySetFrameBuf to set/update framebuffer.\n Original screen resolution is 960x544, but the following resolutions\n can also be supplied as width and height :\n 480x272, 640x368, 720x408\n\n > **Note:** - This structure is returned by ::ksceDisplayGetFrameBuf"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceDisplayFrameBuf {
    #[doc = "sizeof(SceDisplayFrameBuf)"]
    pub size: SceSize,
    #[doc = "Pointer to framebuffer"]
    pub base: *mut crate::ctypes::c_void,
    #[doc = "pitch pixels"]
    pub pitch: crate::ctypes::c_uint,
    #[doc = "pixel format (one of ::SceDisplayPixelFormat)"]
    pub pixelformat: crate::ctypes::c_uint,
    #[doc = "framebuffer width"]
    pub width: crate::ctypes::c_uint,
    #[doc = "framebuffer height"]
    pub height: crate::ctypes::c_uint,
}
#[doc = "Extended framebuffer information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceDisplayFrameBufInfo {
    #[doc = "sizeof(SceDisplayFrameBufInfo)"]
    pub size: SceSize,
    #[doc = "PID of the process owning this framebuffer"]
    pub pid: SceUID,
    #[doc = "Amount of VBlanks this framebuffer has been displayed"]
    pub vblankcount: crate::ctypes::c_uint,
    #[doc = "Physical address"]
    pub paddr: usize,
    #[doc = "SceDisplayFrameBuf information"]
    pub framebuf: SceDisplayFrameBuf,
    #[doc = "Resolution"]
    pub resolution: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceExcpmgrData {
    #[doc = "Number of times an exception handler has been entered on core - panic if > 1 on exception return"]
    pub nestedExceptionCount: [crate::ctypes::c_int; 4usize],
    #[doc = "Seemingly unused"]
    pub unused: [crate::ctypes::c_int; 4usize],
    #[doc = "Top of the exception stack (size is 0x1000)"]
    pub ExcpStackTop: [*mut crate::ctypes::c_void; 4usize],
    #[doc = "Bottom of the exception stack"]
    pub ExcpStackBottom: [*mut crate::ctypes::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceExcpmgrExceptionContext {
    pub r0: u32,
    pub r1: u32,
    pub r2: u32,
    pub r3: u32,
    pub r4: u32,
    pub r5: u32,
    pub r6: u32,
    pub r7: u32,
    pub r8: u32,
    pub r9: u32,
    pub r10: u32,
    pub r11: u32,
    pub r12: u32,
    pub sp: u32,
    pub lr: u32,
    pub address_of_faulting_instruction: u32,
    pub ExceptionKind: SceExcpKind,
    pub SPSR: u32,
    pub CPACR: u32,
    pub FPSCR: u32,
    pub FPEXC: u32,
    pub CONTEXTIDR: u32,
    pub TPIDRURW: u32,
    pub TPIDRURO: u32,
    pub TPIDRPRW: u32,
    pub TTBR1: u32,
    pub unused68: u32,
    pub DACR: u32,
    pub DFSR: u32,
    pub IFSR: u32,
    pub DFAR: u32,
    pub IFAR: u32,
    pub PAR: u32,
    pub TEEHBR: u32,
    pub PMCR: u32,
    pub PMCNTENSET: u32,
    pub PMCNTENSET_2: u32,
    pub PMSELR: u32,
    pub PMCCNTR: u32,
    pub PMUSERENR: u32,
    pub PMXEVTYPER0: u32,
    pub PMXEVCNTR0: u32,
    pub PMXEVTYPER1: u32,
    pub PMXEVCNTR1: u32,
    pub PMXEVTYPER2: u32,
    pub PMXEVCNTR2: u32,
    pub PMXEVTYPER3: u32,
    pub PMXEVCNTR3: u32,
    pub PMXEVTYPER4: u32,
    pub PMXEVCNTR4: u32,
    pub PMXEVTYPER5: u32,
    pub PMXEVCNTR5: u32,
    pub unusedD0: u32,
    pub unkD4: u32,
    pub DBGSCRext: u32,
    pub unusedDC: [u32; 9usize],
    pub VFP_registers: [u64; 32usize],
    pub unk200: [u32; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFColor {
    pub r: SceFloat,
    pub g: SceFloat,
    pub b: SceFloat,
    pub a: SceFloat,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SceFiber {
    pub reserved: [crate::ctypes::c_char; 128usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SceFiberInfo {
    pub entry: SceFiberEntry,
    pub argOnInitialize: SceUInt32,
    pub addrContext: *mut crate::ctypes::c_void,
    pub sizeContext: SceSize,
    pub name: [crate::ctypes::c_char; 32usize],
    pub padding: [crate::ctypes::c_uint; 80usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SceFiberOptParam {
    pub reserved: [crate::ctypes::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosDHOpenSyncSyscallArgs {
    pub to_order: SceUInt8,
    pub padding: [crate::ctypes::c_int; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosGetListSyscallArgs {
    pub out_ids: *mut SceFiosKernelOverlayID,
    pub data_0x04: crate::ctypes::c_int,
    pub data_0x08: crate::ctypes::c_int,
    pub data_0x0C: SceSize,
    pub data_0x10: crate::ctypes::c_int,
    pub data_0x14: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosKernelOverlay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosNativeDirEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosNativeStat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosOverlay {
    pub type_: u8,
    pub order: u8,
    pub dst_len: u16,
    pub src_len: u16,
    pub unk2: u16,
    pub pid: SceUID,
    pub id: SceFiosOverlayID,
    pub dst: [crate::ctypes::c_char; 292usize],
    pub src: [crate::ctypes::c_char; 292usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosResolveSyncSyscallArgs {
    pub out_path: *mut crate::ctypes::c_char,
    pub data_0x04: crate::ctypes::c_int,
    pub data_0x08: crate::ctypes::c_int,
    pub data_0x0C: crate::ctypes::c_int,
    pub data_0x10: crate::ctypes::c_int,
    pub data_0x14: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFiosResolveWithRangeSyncSyscallArgs {
    pub out_path: *mut crate::ctypes::c_char,
    pub data_0x04: crate::ctypes::c_int,
    pub data_0x08: SceUInt8,
    pub data_0x09: SceUInt8,
    pub data_0x0C: crate::ctypes::c_int,
    pub data_0x10: crate::ctypes::c_int,
    pub data_0x14: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFMatrix2 {
    pub x: SceFVector2,
    pub y: SceFVector2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFMatrix3 {
    pub x: SceFVector3,
    pub y: SceFVector3,
    pub z: SceFVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFMatrix4 {
    pub x: SceFVector4,
    pub y: SceFVector4,
    pub z: SceFVector4,
    pub w: SceFVector4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFontCharInfo {
    pub bitmapWidth: crate::ctypes::c_uint,
    pub bitmapHeight: crate::ctypes::c_uint,
    pub bitmapLeft: crate::ctypes::c_uint,
    pub bitmapTop: crate::ctypes::c_uint,
    pub sfp26Width: crate::ctypes::c_uint,
    pub sfp26Height: crate::ctypes::c_uint,
    pub sfp26Ascender: crate::ctypes::c_int,
    pub sfp26Descender: crate::ctypes::c_int,
    pub sfp26BearingHX: crate::ctypes::c_int,
    pub sfp26BearingHY: crate::ctypes::c_int,
    pub sfp26BearingVX: crate::ctypes::c_int,
    pub sfp26BearingVY: crate::ctypes::c_int,
    pub sfp26AdvanceH: crate::ctypes::c_int,
    pub sfp26AdvanceV: crate::ctypes::c_int,
    pub shadowFlags: crate::ctypes::c_short,
    pub shadowId: crate::ctypes::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFontGlyphImage {
    pub pixelFormat: crate::ctypes::c_uint,
    pub xPos64: crate::ctypes::c_int,
    pub yPos64: crate::ctypes::c_int,
    pub bufWidth: crate::ctypes::c_ushort,
    pub bufHeight: crate::ctypes::c_ushort,
    pub bytesPerLine: crate::ctypes::c_ushort,
    pub pad: crate::ctypes::c_ushort,
    pub bufferPtr: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFontImageRect {
    pub width: crate::ctypes::c_ushort,
    pub height: crate::ctypes::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFontInfo {
    pub maxGlyphWidthI: crate::ctypes::c_uint,
    pub maxGlyphHeightI: crate::ctypes::c_uint,
    pub maxGlyphAscenderI: crate::ctypes::c_uint,
    pub maxGlyphDescenderI: crate::ctypes::c_uint,
    pub maxGlyphLeftXI: crate::ctypes::c_uint,
    pub maxGlyphBaseYI: crate::ctypes::c_uint,
    pub minGlyphCenterXI: crate::ctypes::c_uint,
    pub maxGlyphTopYI: crate::ctypes::c_uint,
    pub maxGlyphAdvanceXI: crate::ctypes::c_uint,
    pub maxGlyphAdvanceYI: crate::ctypes::c_uint,
    pub maxGlyphWidthF: f32,
    pub maxGlyphHeightF: f32,
    pub maxGlyphAscenderF: f32,
    pub maxGlyphDescenderF: f32,
    pub maxGlyphLeftXF: f32,
    pub maxGlyphBaseYF: f32,
    pub minGlyphCenterXF: f32,
    pub maxGlyphTopYF: f32,
    pub maxGlyphAdvanceXF: f32,
    pub maxGlyphAdvanceYF: f32,
    pub maxGlyphWidth: crate::ctypes::c_short,
    pub maxGlyphHeight: crate::ctypes::c_short,
    #[doc = "Number of elements in the font's charmap."]
    pub charMapLength: crate::ctypes::c_uint,
    #[doc = "Number of elements in the font's shadow charmap."]
    pub shadowMapLength: crate::ctypes::c_uint,
    pub fontStyle: SceFontStyle,
    #[doc = "Font's BPP."]
    pub BPP: u8,
    pub pad: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFontNewLibParams {
    pub userData: *mut crate::ctypes::c_void,
    pub numFonts: crate::ctypes::c_uint,
    pub cacheData: *mut crate::ctypes::c_void,
    pub allocFunc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::ctypes::c_void,
            arg2: crate::ctypes::c_uint,
        ) -> *mut crate::ctypes::c_void,
    >,
    pub freeFunc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void, arg2: *mut crate::ctypes::c_void),
    >,
    pub openFunc: *mut crate::ctypes::c_void,
    pub closeFunc: *mut crate::ctypes::c_void,
    pub readFunc: *mut crate::ctypes::c_void,
    pub seekFunc: *mut crate::ctypes::c_void,
    pub errorFunc: *mut crate::ctypes::c_void,
    pub ioFinishFunc: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFontStyle {
    pub fontH: f32,
    pub fontV: f32,
    pub fontHRes: f32,
    pub fontVRes: f32,
    pub fontWeight: f32,
    pub fontFamily: crate::ctypes::c_ushort,
    pub fontStyle: crate::ctypes::c_ushort,
    pub fontStyleSub: crate::ctypes::c_ushort,
    pub fontLanguage: crate::ctypes::c_ushort,
    pub fontRegion: crate::ctypes::c_ushort,
    pub fontCountry: crate::ctypes::c_ushort,
    pub fontName: [crate::ctypes::c_char; 64usize],
    pub fontFileName: [crate::ctypes::c_char; 64usize],
    pub fontAttributes: crate::ctypes::c_uint,
    pub fontExpire: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFPlane {
    pub a: SceFloat,
    pub b: SceFloat,
    pub c: SceFloat,
    pub d: SceFloat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFQuaternion {
    pub x: SceFloat,
    pub y: SceFloat,
    pub z: SceFloat,
    pub w: SceFloat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFVector2 {
    pub x: SceFloat,
    pub y: SceFloat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFVector3 {
    pub x: SceFloat,
    pub y: SceFloat,
    pub z: SceFloat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceFVector4 {
    pub x: SceFloat,
    pub y: SceFloat,
    pub z: SceFloat,
    pub w: SceFloat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGpsDeviceInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGpsPositionData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGpsSatelliteData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGpsStatus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceGUIDKernelCreateOpt {
    pub __bindgen_anon_1: SceGUIDKernelCreateOpt__bindgen_ty_1,
    pub field_4: SceUInt32,
    pub field_8: SceUInt32,
    pub pid: SceUInt32,
    pub field_10: SceUInt32,
    pub field_14: SceUInt32,
    pub field_18: SceUInt32,
    pub field_1C: SceUInt32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceGUIDKernelCreateOpt__bindgen_ty_1 {
    pub flags: SceUInt32,
    pub attr: SceUInt32,
}
#[doc = "Represents an auxiliary surface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmAuxiliarySurface {
    #[doc = "Format of auxiliary surface data from SceGxmColorFormat"]
    pub colorFormat: u32,
    #[doc = "Memory layout of the surface data from SceGxmColorSurfaceType"]
    pub type_: u32,
    #[doc = "Surface width"]
    pub width: u32,
    #[doc = "Surface height"]
    pub height: u32,
    #[doc = "Surface stride in bytes"]
    pub stride: u32,
    #[doc = "A pointer to the surface data"]
    pub data: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmBlendInfo {
    #[doc = "Color Mask (One of ::SceGxmColorMask)"]
    pub colorMask: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl SceGxmBlendInfo {
    #[inline]
    pub fn colorFunc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorFunc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn colorSrc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorSrc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn colorDst(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorDst(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaSrc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSrc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaDst(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_alphaDst(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        colorFunc: u8,
        alphaFunc: u8,
        colorSrc: u8,
        colorDst: u8,
        alphaSrc: u8,
        alphaDst: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorFunc: u8 = unsafe { ::core::mem::transmute(colorFunc) };
            colorFunc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let alphaFunc: u8 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let colorSrc: u8 = unsafe { ::core::mem::transmute(colorSrc) };
            colorSrc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let colorDst: u8 = unsafe { ::core::mem::transmute(colorDst) };
            colorDst as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let alphaSrc: u8 = unsafe { ::core::mem::transmute(alphaSrc) };
            alphaSrc as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let alphaDst: u8 = unsafe { ::core::mem::transmute(alphaDst) };
            alphaDst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceGxmColorSurface {
    pub pbeSidebandWord: crate::ctypes::c_uint,
    pub pbeEmitWords: [crate::ctypes::c_uint; 6usize],
    pub outputRegisterSize: crate::ctypes::c_uint,
    pub backgroundTex: SceGxmTexture,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmCommandList {
    pub words: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmContextParams {
    pub hostMem: *mut crate::ctypes::c_void,
    pub hostMemSize: SceSize,
    pub vdmRingBufferMem: *mut crate::ctypes::c_void,
    pub vdmRingBufferMemSize: SceSize,
    pub vertexRingBufferMem: *mut crate::ctypes::c_void,
    pub vertexRingBufferMemSize: SceSize,
    pub fragmentRingBufferMem: *mut crate::ctypes::c_void,
    pub fragmentRingBufferMemSize: SceSize,
    pub fragmentUsseRingBufferMem: *mut crate::ctypes::c_void,
    pub fragmentUsseRingBufferMemSize: SceSize,
    pub fragmentUsseRingBufferOffset: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmDeferredContextParams {
    pub hostMem: *mut crate::ctypes::c_void,
    pub hostMemSize: SceSize,
    pub vdmCallback: ::core::option::Option<
        unsafe extern "C" fn(
            args: *mut crate::ctypes::c_void,
            requestedSize: SceSize,
            size: *mut SceSize,
        ) -> *mut crate::ctypes::c_void,
    >,
    pub vertexCallback: ::core::option::Option<
        unsafe extern "C" fn(
            args: *mut crate::ctypes::c_void,
            requestedSize: SceSize,
            size: *mut SceSize,
        ) -> *mut crate::ctypes::c_void,
    >,
    pub fragmentCallback: ::core::option::Option<
        unsafe extern "C" fn(
            args: *mut crate::ctypes::c_void,
            requestedSize: SceSize,
            size: *mut SceSize,
        ) -> *mut crate::ctypes::c_void,
    >,
    pub callbackData: *mut crate::ctypes::c_void,
    pub vdmRingBufferMem: *mut crate::ctypes::c_void,
    pub vdmRingBufferMemSize: SceSize,
    pub vertexRingBufferMem: *mut crate::ctypes::c_void,
    pub vertexRingBufferMemSize: SceSize,
    pub fragmentRingBufferMem: *mut crate::ctypes::c_void,
    pub fragmentRingBufferMemSize: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmDepthStencilSurface {
    pub zlsControl: crate::ctypes::c_uint,
    pub depthData: *mut crate::ctypes::c_void,
    pub stencilData: *mut crate::ctypes::c_void,
    pub backgroundDepth: f32,
    pub backgroundControl: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmFragmentProgram {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmInitializeParams {
    pub flags: crate::ctypes::c_uint,
    pub displayQueueMaxPendingCount: crate::ctypes::c_uint,
    pub displayQueueCallback: SceGxmDisplayQueueCallback,
    pub displayQueueCallbackDataSize: crate::ctypes::c_uint,
    pub parameterBufferSize: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmNotification {
    pub address: *mut crate::ctypes::c_uint,
    pub value: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmPrecomputedDraw {
    pub data: [crate::ctypes::c_uint; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmPrecomputedFragmentState {
    pub data: [crate::ctypes::c_uint; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmPrecomputedVertexState {
    pub data: [crate::ctypes::c_uint; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmProgram {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmProgramParameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmRegisteredProgram {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmRenderTarget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmRenderTargetParams {
    #[doc = "Bitwise combined flags from ::SceGxmRenderTargetFlags."]
    pub flags: u32,
    #[doc = "The width of the render target in pixels."]
    pub width: u16,
    #[doc = "The height of the render target in pixels."]
    pub height: u16,
    #[doc = "The expected number of scenes per frame, in the range [1, SCE_GXM_MAX_SCENES_PER_RENDERTARGET]."]
    pub scenesPerFrame: u16,
    #[doc = "A value from the #SceGxmMultisampleMode enum."]
    pub multisampleMode: u16,
    #[doc = "If enabled in the flags, the multisample locations to use."]
    pub multisampleLocations: u32,
    #[doc = "The uncached LPDDR memblock for the render target GPU data structures or SCE_UID_INVALID_UID to specify memory should be allocated in libgxm."]
    pub driverMemBlock: SceUID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmShaderPatcher {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmShaderPatcherParams {
    pub userData: *mut crate::ctypes::c_void,
    pub hostAllocCallback: SceGxmShaderPatcherHostAllocCallback,
    pub hostFreeCallback: SceGxmShaderPatcherHostFreeCallback,
    pub bufferAllocCallback: SceGxmShaderPatcherBufferAllocCallback,
    pub bufferFreeCallback: SceGxmShaderPatcherBufferFreeCallback,
    pub bufferMem: *mut crate::ctypes::c_void,
    pub bufferMemSize: SceSize,
    pub vertexUsseAllocCallback: SceGxmShaderPatcherUsseAllocCallback,
    pub vertexUsseFreeCallback: SceGxmShaderPatcherUsseFreeCallback,
    pub vertexUsseMem: *mut crate::ctypes::c_void,
    pub vertexUsseMemSize: SceSize,
    pub vertexUsseOffset: crate::ctypes::c_uint,
    pub fragmentUsseAllocCallback: SceGxmShaderPatcherUsseAllocCallback,
    pub fragmentUsseFreeCallback: SceGxmShaderPatcherUsseFreeCallback,
    pub fragmentUsseMem: *mut crate::ctypes::c_void,
    pub fragmentUsseMemSize: SceSize,
    pub fragmentUsseOffset: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmSyncObject {
    _unused: [u8; 0],
}
#[doc = "Texture struct"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceGxmTexture {
    pub __bindgen_anon_1: SceGxmTexture__bindgen_ty_1,
    pub __bindgen_anon_2: SceGxmTexture__bindgen_ty_2,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl SceGxmTexture {
    #[inline]
    pub fn lod_min0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lod_min0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn data_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_data_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn palette_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_palette_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn lod_min1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lod_min1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn swizzle_format(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_swizzle_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn normalize_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_normalize_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lod_min0: u32,
        data_addr: u32,
        palette_addr: u32,
        lod_min1: u32,
        swizzle_format: u32,
        normalize_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let lod_min0: u32 = unsafe { ::core::mem::transmute(lod_min0) };
            lod_min0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let data_addr: u32 = unsafe { ::core::mem::transmute(data_addr) };
            data_addr as u64
        });
        __bindgen_bitfield_unit.set(32usize, 26u8, {
            let palette_addr: u32 = unsafe { ::core::mem::transmute(palette_addr) };
            palette_addr as u64
        });
        __bindgen_bitfield_unit.set(58usize, 2u8, {
            let lod_min1: u32 = unsafe { ::core::mem::transmute(lod_min1) };
            lod_min1 as u64
        });
        __bindgen_bitfield_unit.set(60usize, 3u8, {
            let swizzle_format: u32 = unsafe { ::core::mem::transmute(swizzle_format) };
            swizzle_format as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let normalize_mode: u32 = unsafe { ::core::mem::transmute(normalize_mode) };
            normalize_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceGxmTexture__bindgen_ty_1 {
    pub generic: SceGxmTexture__bindgen_ty_1__bindgen_ty_1,
    pub linear_strided: SceGxmTexture__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmTexture__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl SceGxmTexture__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn unk0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unk0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stride_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stride_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vaddr_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vaddr_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn uaddr_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uaddr_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mip_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mip_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn min_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_min_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mag_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mag_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_unk1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mip_count(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mip_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn lod_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_lod_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn gamma_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gamma_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_unk2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn format0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_format0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk0: u32,
        stride_ext: u32,
        vaddr_mode: u32,
        uaddr_mode: u32,
        mip_filter: u32,
        min_filter: u32,
        mag_filter: u32,
        unk1: u32,
        mip_count: u32,
        lod_bias: u32,
        gamma_mode: u32,
        unk2: u32,
        format0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk0: u32 = unsafe { ::core::mem::transmute(unk0) };
            unk0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let stride_ext: u32 = unsafe { ::core::mem::transmute(stride_ext) };
            stride_ext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vaddr_mode: u32 = unsafe { ::core::mem::transmute(vaddr_mode) };
            vaddr_mode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let uaddr_mode: u32 = unsafe { ::core::mem::transmute(uaddr_mode) };
            uaddr_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mip_filter: u32 = unsafe { ::core::mem::transmute(mip_filter) };
            mip_filter as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let min_filter: u32 = unsafe { ::core::mem::transmute(min_filter) };
            min_filter as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let mag_filter: u32 = unsafe { ::core::mem::transmute(mag_filter) };
            mag_filter as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let unk1: u32 = unsafe { ::core::mem::transmute(unk1) };
            unk1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 4u8, {
            let mip_count: u32 = unsafe { ::core::mem::transmute(mip_count) };
            mip_count as u64
        });
        __bindgen_bitfield_unit.set(21usize, 6u8, {
            let lod_bias: u32 = unsafe { ::core::mem::transmute(lod_bias) };
            lod_bias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let gamma_mode: u32 = unsafe { ::core::mem::transmute(gamma_mode) };
            gamma_mode as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let unk2: u32 = unsafe { ::core::mem::transmute(unk2) };
            unk2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let format0: u32 = unsafe { ::core::mem::transmute(format0) };
            format0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmTexture__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl SceGxmTexture__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn unk0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unk0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stride_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stride_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vaddr_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vaddr_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn uaddr_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uaddr_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stride_low(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stride_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mag_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mag_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_unk1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stride(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_stride(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn gamma_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gamma_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_unk2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn format0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_format0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk0: u32,
        stride_ext: u32,
        vaddr_mode: u32,
        uaddr_mode: u32,
        stride_low: u32,
        mag_filter: u32,
        unk1: u32,
        stride: u32,
        gamma_mode: u32,
        unk2: u32,
        format0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk0: u32 = unsafe { ::core::mem::transmute(unk0) };
            unk0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let stride_ext: u32 = unsafe { ::core::mem::transmute(stride_ext) };
            stride_ext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vaddr_mode: u32 = unsafe { ::core::mem::transmute(vaddr_mode) };
            vaddr_mode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let uaddr_mode: u32 = unsafe { ::core::mem::transmute(uaddr_mode) };
            uaddr_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let stride_low: u32 = unsafe { ::core::mem::transmute(stride_low) };
            stride_low as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let mag_filter: u32 = unsafe { ::core::mem::transmute(mag_filter) };
            mag_filter as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let unk1: u32 = unsafe { ::core::mem::transmute(unk1) };
            unk1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 10u8, {
            let stride: u32 = unsafe { ::core::mem::transmute(stride) };
            stride as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let gamma_mode: u32 = unsafe { ::core::mem::transmute(gamma_mode) };
            gamma_mode as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let unk2: u32 = unsafe { ::core::mem::transmute(unk2) };
            unk2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let format0: u32 = unsafe { ::core::mem::transmute(format0) };
            format0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceGxmTexture__bindgen_ty_2 {
    pub generic2: SceGxmTexture__bindgen_ty_2__bindgen_ty_1,
    pub swizzled_cube: SceGxmTexture__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmTexture__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl SceGxmTexture__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn base_format(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_base_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        height: u32,
        width: u32,
        base_format: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let height: u32 = unsafe { ::core::mem::transmute(height) };
            height as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let base_format: u32 = unsafe { ::core::mem::transmute(base_format) };
            base_format as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmTexture__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl SceGxmTexture__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn height_pot(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_height_pot(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn width_pot(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_width_pot(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn base_format(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_base_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        height_pot: u32,
        reserved0: u32,
        width_pot: u32,
        reserved1: u32,
        base_format: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let height_pot: u32 = unsafe { ::core::mem::transmute(height_pot) };
            height_pot as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let width_pot: u32 = unsafe { ::core::mem::transmute(width_pot) };
            width_pot as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let base_format: u32 = unsafe { ::core::mem::transmute(base_format) };
            base_format as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmValidRegion {
    pub xMax: u32,
    pub yMax: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmVertexAttribute {
    #[doc = "Vertex stream index"]
    pub streamIndex: u16,
    #[doc = "Offset for the stream data in bytes"]
    pub offset: u16,
    #[doc = "Stream data type (One of ::SceGxmAttributeFormat)"]
    pub format: u8,
    #[doc = "Number of components for the stream data"]
    pub componentCount: u8,
    #[doc = "The register index in the vertex shader to link stream to."]
    pub regIndex: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmVertexProgram {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxmVertexStream {
    pub stride: u16,
    pub indexSource: u16,
}
#[doc = "Header for a GXT file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxtHeader {
    #[doc = "GXT Identifier"]
    pub tag: u32,
    #[doc = "Version number"]
    pub version: u32,
    #[doc = "Number of textures"]
    pub numTextures: u32,
    #[doc = "Offset to the texture data"]
    pub dataOffset: u32,
    #[doc = "Total size of the texture data"]
    pub dataSize: u32,
    #[doc = "Number of 16 entry palettes"]
    pub numP4Palettes: u32,
    #[doc = "Number of 256 entry palettes"]
    pub numP8Palettes: u32,
    #[doc = "Padding"]
    pub pad: u32,
}
#[doc = "This structure contains information about each texture in the GXT file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceGxtTextureInfo {
    #[doc = "Offset to the texture data"]
    pub dataOffset: u32,
    #[doc = "Size of the texture data"]
    pub dataSize: u32,
    #[doc = "Index of the palette"]
    pub paletteIndex: u32,
    #[doc = "Texture flags"]
    pub flags: u32,
    #[doc = "Texture type"]
    pub type_: u32,
    #[doc = "Texture format"]
    pub format: u32,
    #[doc = "Texture width"]
    pub width: u16,
    #[doc = "Texture height"]
    pub height: u16,
    #[doc = "Number of mipmaps"]
    pub mipCount: u8,
    #[doc = "Padding"]
    pub pad: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceHidKeyboardReport {
    pub reserved: SceUInt8,
    pub modifiers: [SceUInt8; 2usize],
    pub keycodes: [SceUInt8; 6usize],
    pub reserved2: [SceUInt8; 7usize],
    pub timestamp: SceUInt64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceHidMouseReport {
    pub buttons: SceUInt8,
    pub reserved: SceUInt8,
    pub rel_x: SceInt16,
    pub rel_y: SceInt16,
    pub wheel: SceInt8,
    pub tilt: SceInt8,
    pub timestamp: SceUInt64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceHttpMemoryPoolStats {
    pub poolSize: crate::ctypes::c_uint,
    pub maxInuseSize: crate::ctypes::c_uint,
    pub currentInuseSize: crate::ctypes::c_uint,
    pub reserved: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceHttpsCaList {
    pub caCerts: *mut *mut crate::ctypes::c_void,
    pub caNum: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceHttpsData {
    pub ptr: *mut crate::ctypes::c_char,
    pub size: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceHttpUriElement {
    pub opaque: crate::ctypes::c_int,
    pub scheme: *mut crate::ctypes::c_char,
    pub username: *mut crate::ctypes::c_char,
    pub password: *mut crate::ctypes::c_char,
    pub hostname: *mut crate::ctypes::c_char,
    pub path: *mut crate::ctypes::c_char,
    pub query: *mut crate::ctypes::c_char,
    pub fragment: *mut crate::ctypes::c_char,
    pub port: crate::ctypes::c_ushort,
    pub reserved: [crate::ctypes::c_uchar; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceI2cDebugHandlers {
    pub size: crate::ctypes::c_uint,
    pub write_start: ::core::option::Option<
        unsafe extern "C" fn(
            bus: crate::ctypes::c_int,
            addr: crate::ctypes::c_int,
            buffer: *mut crate::ctypes::c_uchar,
            size: crate::ctypes::c_int,
        ),
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            bus: crate::ctypes::c_int,
            error: crate::ctypes::c_int,
            result: crate::ctypes::c_int,
        ),
    >,
    pub read_start: ::core::option::Option<
        unsafe extern "C" fn(
            bus: crate::ctypes::c_int,
            addr: crate::ctypes::c_int,
            buffer: *mut crate::ctypes::c_uchar,
            size: crate::ctypes::c_int,
        ),
    >,
    pub read_end: ::core::option::Option<
        unsafe extern "C" fn(
            bus: crate::ctypes::c_int,
            error: crate::ctypes::c_int,
            result: crate::ctypes::c_int,
        ),
    >,
    pub write_read_start: ::core::option::Option<
        unsafe extern "C" fn(
            bus: crate::ctypes::c_int,
            write_addr: crate::ctypes::c_int,
            write_buffer: *mut crate::ctypes::c_uchar,
            write_size: crate::ctypes::c_int,
            read_addr: crate::ctypes::c_uint,
            read_buffer: *mut crate::ctypes::c_uchar,
            read_size: crate::ctypes::c_int,
        ),
    >,
    pub write_read_end: ::core::option::Option<
        unsafe extern "C" fn(
            bus: crate::ctypes::c_int,
            error: crate::ctypes::c_int,
            result: crate::ctypes::c_int,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIftuConvParams {
    pub size: crate::ctypes::c_uint,
    pub unk04: crate::ctypes::c_uint,
    pub csc_params1: *mut SceIftuCscParams,
    pub csc_params2: *mut SceIftuCscParams,
    pub csc_control: crate::ctypes::c_uint,
    pub unk14: crate::ctypes::c_uint,
    pub unk18: crate::ctypes::c_uint,
    pub unk1C: crate::ctypes::c_uint,
    pub alpha: crate::ctypes::c_uint,
    pub unk24: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIftuCscParams {
    pub post_add_0: crate::ctypes::c_uint,
    pub post_add_1_2: crate::ctypes::c_uint,
    pub post_clamp_max_0: crate::ctypes::c_uint,
    pub post_clamp_min_0: crate::ctypes::c_uint,
    pub post_clamp_max_1_2: crate::ctypes::c_uint,
    pub post_clamp_min_1_2: crate::ctypes::c_uint,
    pub ctm: [[crate::ctypes::c_uint; 3usize]; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIftuFrameBuf {
    pub pixelformat: crate::ctypes::c_uint,
    pub width: crate::ctypes::c_uint,
    pub height: crate::ctypes::c_uint,
    pub leftover_stride: crate::ctypes::c_uint,
    pub leftover_align: crate::ctypes::c_uint,
    pub paddr0: crate::ctypes::c_uint,
    pub paddr1: crate::ctypes::c_uint,
    pub paddr2: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIftuPlaneState {
    pub fb: SceIftuFrameBuf,
    pub unk20: crate::ctypes::c_uint,
    pub src_x: crate::ctypes::c_uint,
    pub src_y: crate::ctypes::c_uint,
    pub src_w: crate::ctypes::c_uint,
    pub src_h: crate::ctypes::c_uint,
    pub dst_x: crate::ctypes::c_uint,
    pub dst_y: crate::ctypes::c_uint,
    pub dst_w: crate::ctypes::c_uint,
    pub dst_h: crate::ctypes::c_uint,
    pub vtop_padding: crate::ctypes::c_uint,
    pub vbot_padding: crate::ctypes::c_uint,
    pub hleft_padding: crate::ctypes::c_uint,
    pub hright_padding: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIMatrix2 {
    pub x: SceIVector2,
    pub y: SceIVector2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIMatrix3 {
    pub x: SceIVector3,
    pub y: SceIVector3,
    pub z: SceIVector3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIMatrix4 {
    pub x: SceIVector4,
    pub y: SceIVector4,
    pub z: SceIVector4,
    pub w: SceIVector4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImeCaret {
    pub x: SceUInt32,
    pub y: SceUInt32,
    pub height: SceUInt32,
    pub index: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImeDialogParam {
    pub sdkVersion: SceUInt32,
    pub inputMethod: SceUInt32,
    #[doc = "Dialog languages (One or more ::SceImeLanguage)"]
    pub supportedLanguages: SceUInt64,
    pub languagesForced: SceBool,
    #[doc = "Dialog type (One of ::SceImeType)"]
    pub type_: SceUInt32,
    #[doc = "Dialog options (One or more ::SceImeOption)"]
    pub option: SceUInt32,
    pub filter: SceImeTextFilter,
    #[doc = "Dialog mode (One of ::SceImeDialogDialogMode)"]
    pub dialogMode: SceUInt32,
    #[doc = "Textbox mode (One of ::SceImeDialogTextboxMode)"]
    pub textBoxMode: SceUInt32,
    pub title: *const SceWChar16,
    pub maxTextLength: SceUInt32,
    pub initialText: *mut SceWChar16,
    pub inputTextBuffer: *mut SceWChar16,
    pub commonParam: SceCommonDialogParam,
    pub enterLabel: SceUChar8,
    pub reserved: [SceChar8; 35usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImeDialogResult {
    pub result: SceInt32,
    pub button: SceInt32,
    pub reserved: [SceChar8; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImeEditText {
    pub preeditIndex: SceUInt32,
    pub preeditLength: SceUInt32,
    pub caretIndex: SceUInt32,
    pub str_: *mut SceWChar16,
    pub editIndex: SceUInt32,
    pub editLengthChange: SceInt32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceImeEventData {
    pub id: SceUInt32,
    pub param: SceImeEventParam,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceImeEventParam {
    pub rect: SceImeRect,
    pub text: SceImeEditText,
    pub caretIndex: SceUInt32,
    pub reserved: [SceUChar8; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImeParam {
    pub sdkVersion: SceUInt32,
    pub inputMethod: SceUInt32,
    #[doc = "Dialog languages (One or more ::SceImeLanguage)"]
    pub supportedLanguages: SceUInt64,
    pub languagesForced: SceBool,
    #[doc = "Dialog type (One of ::SceImeType)"]
    pub type_: SceUInt32,
    #[doc = "Dialog options (One or more ::SceImeOption)"]
    pub option: SceUInt32,
    pub work: *mut crate::ctypes::c_void,
    pub arg: *mut crate::ctypes::c_void,
    pub handler: SceImeEventHandler,
    pub filter: SceImeTextFilter,
    pub initialText: *mut SceWChar16,
    pub maxTextLength: SceUInt32,
    pub inputTextBuffer: *mut SceWChar16,
    pub enterLabel: SceUChar8,
    pub reserved: [SceUChar8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImePreeditGeometry {
    pub x: SceUInt32,
    pub y: SceUInt32,
    pub height: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceImeRect {
    pub x: SceUInt32,
    pub y: SceUInt32,
    pub width: SceUInt32,
    pub height: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIncomingDialogParam {
    pub sdkVersion: SceInt32,
    pub audioPath: [SceChar8; 128usize],
    pub titleid: [SceChar8; 16usize],
    pub unk_BC: SceInt32,
    pub dialogTimer: SceUInt32,
    pub reserved1: [SceChar8; 62usize],
    pub buttonRightText: [SceWChar16; 31usize],
    pub separator0: SceInt16,
    pub buttonLeftText: [SceWChar16; 31usize],
    pub separator1: SceInt16,
    pub dialogText: [SceWChar16; 128usize],
    pub separator2: SceInt16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIoDevInfo {
    pub max_size: SceOff,
    pub free_size: SceOff,
    pub cluster_size: SceSize,
    pub unk: *mut crate::ctypes::c_void,
}
#[doc = "Describes a single directory entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIoDirent {
    #[doc = "File status"]
    pub d_stat: SceIoStat,
    #[doc = "File name"]
    pub d_name: [crate::ctypes::c_char; 256usize],
    #[doc = "Device-specific data"]
    pub d_private: *mut crate::ctypes::c_void,
    #[doc = "Dummy data"]
    pub dummy: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIoFdInfo {
    pub fd: SceUID,
    pub pid: SceUID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIofileInfo {
    pub path: [crate::ctypes::c_char; 1024usize],
    pub path2: [crate::ctypes::c_char; 1024usize],
    pub pid: SceUID,
    pub data_0x804: crate::ctypes::c_int,
    pub data_0x808: crate::ctypes::c_int,
    pub data_0x80C: crate::ctypes::c_int,
    pub data_0x810: crate::ctypes::c_int,
    pub data_0x814: crate::ctypes::c_int,
    pub data_0x818: crate::ctypes::c_int,
    pub data_0x81C: crate::ctypes::c_int,
    pub data_0x820: crate::ctypes::c_int,
    pub data_0x824: crate::ctypes::c_int,
}
#[doc = "Structure to hold the status information about a file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIoStat {
    #[doc = "One or more ::SceIoAccessMode"]
    pub st_mode: SceMode,
    #[doc = "One or more ::SceIoFileMode"]
    pub st_attr: crate::ctypes::c_uint,
    #[doc = "Size of the file in bytes"]
    pub st_size: SceOff,
    #[doc = "Creation time"]
    pub st_ctime: SceDateTime,
    #[doc = "Last access time"]
    pub st_atime: SceDateTime,
    #[doc = "Last modification time"]
    pub st_mtime: SceDateTime,
    #[doc = "Device-specific data"]
    pub st_private: [crate::ctypes::c_uint; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIVector2 {
    pub x: SceInt,
    pub y: SceInt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIVector3 {
    pub x: SceInt,
    pub y: SceInt,
    pub z: SceInt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceIVector4 {
    pub x: SceInt,
    pub y: SceInt,
    pub z: SceInt,
    pub w: SceInt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceJpegEncoderInitParam {
    #[doc = "Size of this structure"]
    pub size: SceSize,
    #[doc = "Input width in pixels"]
    pub inWidth: crate::ctypes::c_int,
    #[doc = "Input height in pixels"]
    pub inHeight: crate::ctypes::c_int,
    #[doc = "A valid ::SceJpegEncoderPixelFormat set of values"]
    pub pixelFormat: crate::ctypes::c_int,
    #[doc = "A physically continuous memory block 256 bytes aligned"]
    pub outBuffer: *mut crate::ctypes::c_void,
    #[doc = "Output size in bytes"]
    pub outSize: SceSize,
    #[doc = "Additional options, OR of ::SceJpegEncoderInitParamOption"]
    pub option: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceJpegMJpegInitParam {
    pub size: SceSize,
    pub decoderCount: SceInt32,
    pub options: SceInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceJpegOutputInfo {
    pub colorSpace: SceInt32,
    pub width: SceUInt16,
    pub height: SceUInt16,
    pub outputSize: SceUInt32,
    pub unk_0xc: SceUInt32,
    pub unk_0x10: SceUInt32,
    pub pitch: [SceJpegPitch; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceJpegPitch {
    pub x: SceUInt32,
    pub y: SceUInt32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SceKblParam {
    pub version: u16,
    pub size: u16,
    pub current_fw_version: u32,
    pub factory_fw_version: u32,
    pub unk_C: u32,
    pub unk_10: u32,
    pub unk_14: [u8; 12usize],
    pub qa_flags: [u8; 16usize],
    pub boot_flags: [u8; 16usize],
    pub dipsw: SceDipsw,
    pub dram: SceKernelPARange,
    pub unk_68: u32,
    pub boot_type_indicator_1: u32,
    pub openpsid: SceOpenPsId,
    pub secure_kernel: SceKernelPARange,
    pub context_auth_sm: SceKernelPARange,
    pub kprx_auth_sm: SceKernelPARange,
    pub prog_rvk: SceKernelPARange,
    pub pscode: ScePsCode,
    pub __stack_chk_guard: u32,
    pub unk_AC: u32,
    pub session_id: [u8; 16usize],
    pub unk_C0: u32,
    pub wakeup_factor: u32,
    pub unk_C8: u32,
    pub hold_ctrl: u32,
    pub resume_context_addr: u32,
    pub hardware_info: u32,
    pub boot_type_indicator_2: u32,
    pub unk_DC: u32,
    pub unk_E0: u32,
    pub unk_E4: u32,
    pub hardware_flags: [u8; 16usize],
    pub bootldr_revision: u32,
    pub magic: u32,
    pub coredump_session_key: [u8; 32usize],
    pub unused: [u8; 224usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelAddrPair {
    #[doc = "Address"]
    pub addr: u32,
    #[doc = "Length"]
    pub length: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelAllocMemBlockKernelOpt {
    #[doc = "sizeof(SceKernelAllocMemBlockKernelOpt)"]
    pub size: SceSize,
    pub field_4: SceUInt32,
    #[doc = "OR of SceKernelAllocMemBlockAttr"]
    pub attr: SceUInt32,
    pub field_C: SceUInt32,
    pub paddr: SceUInt32,
    pub alignment: SceSize,
    pub extraLow: SceUInt32,
    pub extraHigh: SceUInt32,
    pub mirror_blockid: SceUInt32,
    pub pid: SceUID,
    pub paddr_list: *mut SceKernelPaddrList,
    pub field_2C: SceUInt32,
    pub field_30: SceUInt32,
    pub field_34: SceUInt32,
    pub field_38: SceUInt32,
    pub field_3C: SceUInt32,
    pub field_40: SceUInt32,
    pub field_44: SceUInt32,
    pub field_48: SceUInt32,
    pub field_4C: SceUInt32,
    pub field_50: SceUInt32,
    pub field_54: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelAllocMemBlockOpt {
    pub size: SceSize,
    pub attr: SceUInt32,
    pub alignment: SceSize,
    pub uidBaseBlock: SceUInt32,
    pub strBaseBlockName: *const crate::ctypes::c_char,
    pub flags: crate::ctypes::c_int,
    #[doc = "Unknown flags 0x10 or 0x30 for ::sceKernelOpenMemBlock"]
    pub reserved: [crate::ctypes::c_int; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelBootArgs {
    _unused: [u8; 0],
}
#[doc = "Structure to hold the status information for a callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelCallbackInfo {
    #[doc = "Size of the structure (i.e. sizeof(SceKernelCallbackInfo))"]
    pub size: SceSize,
    #[doc = "The UID of the callback."]
    pub callbackId: SceUID,
    #[doc = "The name given to the callback"]
    pub name: [crate::ctypes::c_char; 32usize],
    #[doc = "The thread id associated with the callback"]
    pub threadId: SceUID,
    #[doc = "Pointer to the callback function"]
    pub callback: SceKernelCallbackFunction,
    #[doc = "User supplied argument for the callback"]
    pub common: *mut crate::ctypes::c_void,
    #[doc = "Unknown"]
    pub notifyCount: crate::ctypes::c_int,
    #[doc = "Unknown"]
    pub notifyArg: crate::ctypes::c_int,
}
#[doc = "Current state of a condition variable.\n [`sceKernelGetCondInfo.`]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelCondInfo {
    #[doc = "Size of the ::SceKernelCondInfo structure."]
    pub size: SceSize,
    #[doc = "The UID of the condition variable."]
    pub condId: SceUID,
    #[doc = "NUL-terminated name of the condition variable."]
    pub name: [crate::ctypes::c_char; 32usize],
    #[doc = "Attributes."]
    pub attr: SceUInt,
    #[doc = "Mutex associated with the condition variable."]
    pub mutexId: SceUID,
    #[doc = "The number of threads waiting on the condition variable."]
    pub numWaitThreads: crate::ctypes::c_int,
}
#[doc = "Additional options used when creating condition variables."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelCondOptParam {
    #[doc = "Size of the ::SceKernelCondOptParam structure."]
    pub size: SceSize,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SceKernelDebugEventLog {
    #[doc = "struct size(variable size)"]
    pub size: SceSize,
    #[doc = "0xA, maybe titleid size"]
    pub data_0x04: crate::ctypes::c_int,
    #[doc = "Title id of the process where the event occurred"]
    pub titleid: [crate::ctypes::c_char; 12usize],
    #[doc = "Event flags"]
    pub flags: crate::ctypes::c_int,
    #[doc = "Parent process id"]
    pub ppid: SceUID,
    #[doc = "Thread id?"]
    pub data_0x1C: SceUID,
    pub rsvd: [crate::ctypes::c_int; 4usize],
    #[doc = "Time of the event occurred"]
    pub time: SceUInt64,
    pub data_0x38: crate::ctypes::c_int,
    #[doc = "Event data size"]
    pub item_size: SceSize,
    pub __bindgen_anon_1: SceKernelDebugEventLog__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDebugEventLog1 {
    pub data_0x40: crate::ctypes::c_int,
    pub pid: SceUID,
    pub budget_type: crate::ctypes::c_int,
    #[doc = "0xA"]
    pub data_0x4C: crate::ctypes::c_int,
    pub titleid: [crate::ctypes::c_char; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDebugEventLog2 {
    #[doc = "0 or 0x80412118?"]
    pub data_0x40: crate::ctypes::c_int,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDebugEventLog3 {
    #[doc = "0?"]
    pub data_0x40: crate::ctypes::c_int,
    pub ip1: [crate::ctypes::c_char; 16usize],
    pub ip2: [crate::ctypes::c_char; 16usize],
    pub ip3: [crate::ctypes::c_char; 16usize],
    pub ip4: [crate::ctypes::c_char; 16usize],
    pub ip5: [crate::ctypes::c_char; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceKernelDebugEventLog__bindgen_ty_1 {
    pub type1: SceKernelDebugEventLog1,
    pub type2: SceKernelDebugEventLog2,
    pub type3: SceKernelDebugEventLog3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceKernelDebugInfo {
    pub __bindgen_anon_1: SceKernelDebugInfo__bindgen_ty_1,
    pub func: *const crate::ctypes::c_char,
    pub line: SceUInt32,
    pub file: *const crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceKernelDebugInfo__bindgen_ty_1 {
    pub __bindgen_anon_1: SceKernelDebugInfo__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SceKernelDebugInfo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDebugInfo__bindgen_ty_1__bindgen_ty_1 {
    pub fileHash: SceUInt32,
    pub lineHash: SceUInt32,
    pub funcHash: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDebugInfo__bindgen_ty_1__bindgen_ty_2 {
    pub hex_value0_hi: SceUInt32,
    pub hex_value0_lo: SceUInt32,
    pub hex_value1: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDmaOpChainParam {
    pub size: SceSize,
    pub coherencyMask: SceUInt32,
    #[doc = "8-bit value duplicated into 32 bits"]
    pub setValue: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDmaOpDirectParam {
    pub src: *const crate::ctypes::c_void,
    pub dst: *mut crate::ctypes::c_void,
    pub len: SceUInt32,
    #[doc = "Bitwise combination of SCE_KERNEL_DMAC_CMD_* fields"]
    pub cmd: SceUInt32,
    pub blockSize: SceUInt32,
    pub coherencyMask: SceUInt32,
    #[doc = "8-bit value duplicated into 32 bits"]
    pub setValue: SceUInt32,
    pub encDec: SceKernelDmaOpEncDec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDmaOpEncDec {
    pub keyring: SceUInt32,
    #[doc = "Must be a physical address"]
    pub iv: *mut crate::ctypes::c_void,
    pub ivCoherencyMask: SceUInt32,
    pub reserved: SceUInt32,
    pub key: [SceUInt8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDmaOpEncDecChainParam {
    #[doc = "header.size = sizeof(SceKernelDmaOpEncDecChainParam)"]
    pub header: SceKernelDmaOpChainParam,
    pub encDec: SceKernelDmaOpEncDec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelDmaOpTag {
    pub src: *const crate::ctypes::c_void,
    pub dst: *mut crate::ctypes::c_void,
    pub len: SceUInt32,
    #[doc = "Bitwise combination of SCE_KERNEL_DMAC_CMD_* fields"]
    pub cmd: SceUInt32,
    pub keyring: SceUInt32,
    #[doc = "Must be a physical address"]
    pub iv: *mut crate::ctypes::c_void,
    pub blockSize: SceUInt32,
    #[doc = "Set to SCE_KERNEL_DMAC_CHAIN_END to signify the last tag"]
    pub pNext: *mut SceKernelDmaOpTag,
}
#[doc = "Structure to hold the event flag information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelEventFlagInfo {
    pub size: SceSize,
    pub evfId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub initPattern: SceUInt,
    pub currentPattern: SceUInt,
    pub numWaitThreads: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelEventFlagOptParam {
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelFastMutex {
    pub data: [SceUInt8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelFaultingProcessInfo {
    pub pid: SceUID,
    pub faultingThreadId: SceUID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelFreeMemorySizeInfo {
    #[doc = "sizeof(SceKernelFreeMemorySizeInfo)"]
    pub size: crate::ctypes::c_int,
    #[doc = "Free memory size for *_USER_RW memory"]
    pub size_user: crate::ctypes::c_int,
    #[doc = "Free memory size for USER_CDRAM_RW memory"]
    pub size_cdram: crate::ctypes::c_int,
    #[doc = "Free memory size for USER_MAIN_PHYCONT_*_RW memory"]
    pub size_phycont: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceKernelHeapCreateOpt {
    pub size: SceSize,
    pub __bindgen_anon_1: SceKernelHeapCreateOpt__bindgen_ty_1,
    pub field_8: SceUInt32,
    pub field_C: SceUInt32,
    pub memtype: SceUInt32,
    pub field_14: SceUInt32,
    pub field_18: SceUInt32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceKernelHeapCreateOpt__bindgen_ty_1 {
    pub attr: SceUInt32,
    pub uselock: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelIntrOptHandlers {
    pub size: u32,
    pub pre_register_subintr_cb: *mut SceKernelIntrOptHandlersCb3,
    pub post_register_subintr_cb: *mut SceKernelIntrOptHandlersCb3,
    pub release_subintr_cb: *mut SceKernelIntrOptHandlersCb1,
    pub fptr0: *mut SceKernelIntrOptHandlersCb1,
    pub enable_subintr_cb: *mut SceKernelIntrOptHandlersCb1,
    pub disable_subintr_cb: *mut SceKernelIntrOptHandlersCb1,
    pub fptr3: *mut SceKernelIntrOptHandlersCb2,
    pub fptr4: *mut SceKernelIntrOptHandlersCb1,
    pub fptr5: *mut SceKernelIntrOptHandlersCb1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelIntrOptParam {
    pub size: u32,
    pub num: u32,
    pub handlers: *mut SceKernelIntrOptHandlers,
    pub unk_C: u32,
    pub unk_10: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLibraryInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLMOption {
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLoadModuleOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLwCondInfo {
    pub size: SceSize,
    pub lwcond_id: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: crate::ctypes::c_int,
    pub work: *mut SceKernelLwCondWork,
    pub lwmutex: *mut SceKernelLwMutexWork,
    pub num_wait_threads: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLwCondOptParam {
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLwCondWork {
    pub data: [SceInt32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLwMutexInfo {
    pub size: SceSize,
    pub mtxid: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: crate::ctypes::c_int,
    pub work: *mut SceKernelLwMutexWork,
    pub init_count: crate::ctypes::c_int,
    pub current_count: crate::ctypes::c_int,
    pub current_owner_id: SceUID,
    pub num_wait_threads: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLwMutexOptParam {
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelLwMutexWork {
    pub data: [SceInt64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelMemBlockInfo {
    pub size: SceSize,
    pub mappedBase: *mut crate::ctypes::c_void,
    pub mappedSize: SceSize,
    pub memoryType: crate::ctypes::c_int,
    pub access: SceUInt32,
    pub type_: SceKernelMemBlockType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleInfo {
    #[doc = "0x1B8 for Vita 1.x"]
    pub size: SceSize,
    pub modid: SceUID,
    pub modattr: u16,
    pub modver: [u8; 2usize],
    pub module_name: [crate::ctypes::c_char; 28usize],
    pub unk28: SceUInt,
    pub start_entry: *mut crate::ctypes::c_void,
    pub stop_entry: *mut crate::ctypes::c_void,
    pub exit_entry: *mut crate::ctypes::c_void,
    pub exidx_top: *mut crate::ctypes::c_void,
    pub exidx_btm: *mut crate::ctypes::c_void,
    pub extab_top: *mut crate::ctypes::c_void,
    pub extab_btm: *mut crate::ctypes::c_void,
    pub tlsInit: *mut crate::ctypes::c_void,
    pub tlsInitSize: SceSize,
    pub tlsAreaSize: SceSize,
    pub path: [crate::ctypes::c_char; 256usize],
    pub segments: [SceKernelSegmentInfo; 4usize],
    #[doc = "see:SceKernelModuleState"]
    pub state: SceUInt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleLibraryInfo {
    #[doc = "sizeof(SceKernelModuleLibraryInfo) : 0x120"]
    pub size: SceSize,
    pub library_id: SceUID,
    pub libnid: u32,
    pub version: u16,
    pub flags: u16,
    pub entry_num_function: u16,
    pub entry_num_variable: u16,
    pub unk_0x14: u16,
    pub unk_0x16: u16,
    pub library_name: [crate::ctypes::c_char; 256usize],
    pub number_of_imported: SceSize,
    pub modid2: SceUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceKernelModuleListInfo {
    pub size: SceSize,
    pub modid: SceUID,
    pub version: u32,
    pub module_version: u32,
    pub unk10: u32,
    pub unk14: *mut crate::ctypes::c_void,
    pub unk18: u32,
    pub unk1C: *mut crate::ctypes::c_void,
    pub unk20: *mut crate::ctypes::c_void,
    pub module_name: [crate::ctypes::c_char; 28usize],
    pub unk40: u32,
    pub unk44: u32,
    pub nid: u32,
    pub segments_num: SceSize,
    pub __bindgen_anon_1: SceKernelModuleListInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceKernelModuleListInfo__bindgen_ty_1 {
    pub seg1: SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_1,
    pub seg2: SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_2,
    pub seg3: SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_3,
    pub seg4: SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_1 {
    pub SegmentInfo: [SceKernelSegmentInfo2; 1usize],
    pub addr: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_2 {
    pub SegmentInfo: [SceKernelSegmentInfo2; 2usize],
    pub addr: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_3 {
    pub SegmentInfo: [SceKernelSegmentInfo2; 3usize],
    pub addr: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleListInfo__bindgen_ty_1__bindgen_ty_4 {
    pub SegmentInfo: [SceKernelSegmentInfo2; 4usize],
    pub addr: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelModuleName {
    pub s: [crate::ctypes::c_char; 28usize],
}
#[doc = "Message Pipe status info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelMppInfo {
    pub size: SceSize,
    pub mppId: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: SceUInt,
    pub bufSize: crate::ctypes::c_int,
    pub freeSize: crate::ctypes::c_int,
    pub numSendWaitThreads: crate::ctypes::c_int,
    pub numReceiveWaitThreads: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelMsgPipeInfo {
    pub size: SceSize,
    pub msgpipe_id: SceUID,
    pub name: [crate::ctypes::c_char; 32usize],
    pub attr: crate::ctypes::c_int,
    pub buffer_size: SceSize,
    pub free_size: SceSize,
    pub num_send_wait_threads: crate::ctypes::c_int,
    pub num_receive_wait_threads: crate::ctypes::c_int,
}
#[doc = "Current state of a mutex.\n [`sceKernelGetMutexInfo.`]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelMutexInfo {
    #[doc = "Size of the ::SceKernelMutexInfo structure."]
    pub size: SceSize,
    #[doc = "The UID of the mutex."]
    pub mutexId: SceUID,
    #[doc = "NUL-terminated name of the mutex."]
    pub name: [crate::ctypes::c_char; 32usize],
    #[doc = "Attributes."]
    pub attr: SceUInt,
    #[doc = "The initial count the mutex was created with."]
    pub initCount: crate::ctypes::c_int,
    #[doc = "The current count."]
    pub currentCount: crate::ctypes::c_int,
    #[doc = "The UID of the current owner of the mutex."]
    pub currentOwnerId: SceUID,
    #[doc = "The number of threads waiting on the mutex."]
    pub numWaitThreads: crate::ctypes::c_int,
}
#[doc = "Additional options used when creating mutexes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelMutexOptParam {
    #[doc = "Size of the ::SceKernelMutexOptParam structure."]
    pub size: SceSize,
    pub ceilingPriority: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelOpenPsId {
    pub id: [crate::ctypes::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPaArmTraceParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPaCounterTraceParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPaGpuSampledData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPaGpuTraceParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPARange {
    pub addr: u32,
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPaTraceBufferParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceKernelPAVector {
    #[doc = "Size of this structure"]
    pub size: SceSize,
    pub __bindgen_anon_1: SceKernelPAVector__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceKernelPAVector__bindgen_ty_1 {
    pub __bindgen_anon_1: SceKernelPAVector__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SceKernelPAVector__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPAVector__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "Ex: 8"]
    pub ranges_size: u32,
    #[doc = "Must be <= 8"]
    pub data_in_vector: u32,
    pub count: u32,
    pub ranges: *mut SceKernelPARange,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelPAVector__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "Size in elements of the list array"]
    pub list_size: u32,
    #[doc = "Total physical size of the memory pairs"]
    pub ret_length: u32,
    #[doc = "Number of elements of list filled by ksceKernelGetPaddrList"]
    pub ret_count: u32,
    #[doc = "Array of physical addresses and their lengths pairs"]
    pub list: *mut SceKernelAddrPair,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelProcessContext {
    pub TTBR1: SceUInt32,
    pub DACR: SceUInt32,
    pub CONTEXTIDR: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelProcessInfo {
    #[doc = "size of this struct, make sure it's 0xE8"]
    pub size: SceSize,
    #[doc = "our process ID"]
    pub pid: SceUID,
    pub unk1: crate::ctypes::c_int,
    pub unk2: crate::ctypes::c_int,
    pub unk3: crate::ctypes::c_int,
    #[doc = "parent process ID"]
    pub ppid: SceUID,
    #[doc = "the rest is unknown"]
    pub unk: [crate::ctypes::c_int; 52usize],
}
#[doc = "Current state of a rwlock.\n [`sceKernelGetRWLockInfo`]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelRWLockInfo {
    #[doc = "Size of the ::SceKernelRWLockInfo structure"]
    pub size: SceSize,
    #[doc = "The UID of the rwlock"]
    pub rwLockId: SceUID,
    #[doc = "NULL-terminated name of the rwlock"]
    pub name: [crate::ctypes::c_char; 32usize],
    #[doc = "Attributes"]
    pub attr: SceUInt32,
    #[doc = "The current lock count"]
    pub lockCount: SceInt32,
    #[doc = "The UID of the current owner of the rwlock with write access, 0 when locked for reads"]
    pub writeOwnerId: SceUID,
    #[doc = "The number of threads waiting on the rwlock for read access"]
    pub numReadWaitThreads: SceUInt32,
    #[doc = "The number of threads waiting on the rwlock for write access"]
    pub numWriteWaitThreads: SceUInt32,
}
#[doc = "Additional options used when creating rwlock."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelRWLockOptParam {
    #[doc = "Size of the ::SceKernelRWLockOptParam structure"]
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSegmentInfo {
    #[doc = "this structure size (0x18)"]
    pub size: SceSize,
    #[doc = "probably rwx in low bits"]
    pub perms: SceUInt,
    #[doc = "address in memory"]
    pub vaddr: *mut crate::ctypes::c_void,
    #[doc = "size in memory"]
    pub memsz: SceSize,
    #[doc = "original size of memsz"]
    pub filesz: SceSize,
    #[doc = "unused"]
    pub res: SceUInt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSegmentInfo2 {
    #[doc = "sizeof(SceKernelSegmentInfo2) (0x14)"]
    pub size: SceSize,
    pub perm: crate::ctypes::c_int,
    pub vaddr: *mut crate::ctypes::c_void,
    pub memsz: u32,
    pub unk_10: crate::ctypes::c_int,
}
#[doc = "Current state of a semaphore.\n [`sceKernelGetSemaInfo.`]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSemaInfo {
    #[doc = "Size of the ::SceKernelSemaInfo structure."]
    pub size: SceSize,
    #[doc = "The UID of the semaphore"]
    pub semaId: SceUID,
    #[doc = "NUL-terminated name of the semaphore."]
    pub name: [crate::ctypes::c_char; 32usize],
    #[doc = "Attributes."]
    pub attr: SceUInt,
    #[doc = "The initial count the semaphore was created with."]
    pub initCount: crate::ctypes::c_int,
    #[doc = "The current count."]
    pub currentCount: crate::ctypes::c_int,
    #[doc = "The maximum count."]
    pub maxCount: crate::ctypes::c_int,
    #[doc = "The number of threads waiting on the semaphore."]
    pub numWaitThreads: crate::ctypes::c_int,
}
#[doc = "Additional options used when creating semaphores."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSemaOptParam {
    #[doc = "Size of the ::SceKernelSemaOptParam structure."]
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSysrootSelfInfo {
    pub size: SceSize,
    pub self_data: *mut crate::ctypes::c_void,
    pub self_size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSystemInfo {
    pub size: SceSize,
    pub activeCpuMask: SceUInt32,
    pub cpuInfo: [SceKernelSystemInfo__bindgen_ty_1; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSystemInfo__bindgen_ty_1 {
    pub idleClock: SceKernelSysClock,
    pub comesOutOfIdleCount: SceUInt32,
    pub threadSwitchCount: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelSystemSwVersion {
    pub size: SceSize,
    pub versionString: [crate::ctypes::c_char; 28usize],
    pub version: SceUInt,
    pub unk_24: SceUInt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelThreadContextInfo {
    pub process_id: ScePID,
    pub thread_id: SceUID,
}
#[doc = "Structure to hold the status information for a thread\n [`sceKernelGetThreadInfo`]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelThreadInfo {
    #[doc = "Size of the structure"]
    pub size: SceSize,
    #[doc = "The UID of the process where the thread belongs"]
    pub processId: SceUID,
    #[doc = "Nul terminated name of the thread"]
    pub name: [crate::ctypes::c_char; 32usize],
    #[doc = "Thread attributes"]
    pub attr: SceUInt32,
    #[doc = "Thread status"]
    pub status: SceUInt32,
    #[doc = "Thread entry point"]
    pub entry: SceKernelThreadEntry,
    #[doc = "Thread stack pointer"]
    pub stack: *mut crate::ctypes::c_void,
    #[doc = "Thread stack size"]
    pub stackSize: SceInt32,
    #[doc = "Initial priority"]
    pub initPriority: SceInt32,
    #[doc = "Current priority"]
    pub currentPriority: SceInt32,
    #[doc = "Initial CPU affinity mask"]
    pub initCpuAffinityMask: SceInt32,
    #[doc = "Current CPU affinity mask"]
    pub currentCpuAffinityMask: SceInt32,
    #[doc = "Current CPU ID"]
    pub currentCpuId: SceInt32,
    #[doc = "Last executed CPU ID"]
    pub lastExecutedCpuId: SceInt32,
    #[doc = "Wait type"]
    pub waitType: SceUInt32,
    #[doc = "Wait id"]
    pub waitId: SceUID,
    #[doc = "Exit status of the thread"]
    pub exitStatus: SceInt32,
    #[doc = "Number of clock cycles run"]
    pub runClocks: SceKernelSysClock,
    #[doc = "Interrupt preemption count"]
    pub intrPreemptCount: SceUInt32,
    #[doc = "Thread preemption count"]
    pub threadPreemptCount: SceUInt32,
    #[doc = "Thread release count"]
    pub threadReleaseCount: SceUInt32,
    #[doc = "Number of CPUs to which the thread is moved"]
    pub changeCpuCount: SceInt32,
    #[doc = "Function notify callback UID"]
    pub fNotifyCallback: SceInt32,
    #[doc = "Reserved"]
    pub reserved: SceInt32,
}
#[doc = "Additional options used when creating threads."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelThreadOptParam {
    #[doc = "Size of the ::SceKernelThreadOptParam structure."]
    pub size: SceSize,
    #[doc = "Attributes"]
    pub attr: SceUInt32,
}
#[doc = "Statistics about a running thread.\n [`sceKernelGetThreadRunStatus.`]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelThreadRunStatus {
    pub size: SceSize,
    pub cpuInfo: [SceKernelThreadRunStatus__bindgen_ty_1; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelThreadRunStatus__bindgen_ty_1 {
    pub processId: SceUID,
    pub threadId: SceUID,
    pub priority: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelTimeval {
    pub sec: SceInt32,
    pub usec: SceInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelTimezone {
    pub value: SceUInt64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelULMOption {
    pub size: SceSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelUnloadModuleOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceKernelVARange {
    pub addr: u32,
    pub size: SceSize,
}
#[doc = "Structure of heading information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceLocationHeadingInfo {
    #[doc = "Clockwise angle from true north (0 to 360 degrees). If cannot be acquired, SCE_LOCATION_INVALID_DATA"]
    pub trueHeading: SceFloat32,
    #[doc = "Direction vector X coordinates element of true north. If cannot be acquired, SCE_LOCATION_INVALID_DATA"]
    pub headingVectorX: SceFloat32,
    #[doc = "Direction vector Y coordinates element of true north. If cannot be acquired, SCE_LOCATION_INVALID_DATA"]
    pub headingVectorY: SceFloat32,
    #[doc = "Direction vector Z coordinates element of true north. If cannot be acquired, SCE_LOCATION_INVALID_DATA"]
    pub headingVectorZ: SceFloat32,
    #[doc = "Reserve"]
    pub reserve: SceFloat32,
    #[doc = "Reserve"]
    pub reserve2: SceFloat32,
    #[doc = "Time acquired in unit of 1 usec (UTC)"]
    pub timestamp: SceRtcTick,
}
#[doc = "Structure of location information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceLocationLocationInfo {
    #[doc = "Latitude (deg). Valid range: -90 to + 90. If cannot be obtained, SCE_LOCATION_DATA_INVALID"]
    pub latitude: SceDouble64,
    #[doc = "Longitude (deg). Valid range: -180 to +180. If cannot be obtained, SCE_LOCATION_DATA_INVALID"]
    pub longitude: SceDouble64,
    #[doc = "Altitude (m). If cannot be obtained, SCE_LOCATION_DATA_INVALID"]
    pub altitude: SceDouble64,
    #[doc = "Horizontal error (m). If cannot be obtained, SCE_LOCATION_DATA_INVALID"]
    pub accuracy: SceFloat32,
    #[doc = "Reserve"]
    pub reserve: SceFloat32,
    #[doc = "Travel direction. If cannot be obtained, SCE_LOCATION_DATA_INVALID"]
    pub direction: SceFloat32,
    #[doc = "Travel speed (m/s). If cannot be obtained, SCE_LOCATION_DATA_INVALID"]
    pub speed: SceFloat32,
    #[doc = "Time of data acquisition, in μsec (UTC)"]
    pub timestamp: SceRtcTick,
}
#[doc = "Location information acquisition permission information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceLocationPermissionInfo {
    #[doc = "Status of usage permission through parental control"]
    pub parentalstatus: SceLocationPermissionStatus,
    #[doc = "Status of usage permission through location data item of system settings"]
    pub mainstatus: SceLocationPermissionStatus,
    #[doc = "Status of usage permission through location data item for each application in system settings"]
    pub applicationstatus: SceLocationPermissionApplicationStatus,
    pub unk_0x0C: crate::ctypes::c_int,
    pub unk_0x10: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevAccCalibData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevCalibrationData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevCalibrationHeader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevDeviceInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevDeviceLocation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevGyroBiasData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevGyroCalibData {
    _unused: [u8; 0],
}
#[doc = "Returned location of both the accelerometer and gyroscope in mm\n > **Note:** - Axies are fixed with z axis being straight perpendicular through the screen and x axis being parallel to the screen's bottom and top edge\n > **Note:** - Direction of the z axis is as if the device were laying on a flat surface, oled/lcd side facing upwards\n > **Note:** - OLED models should return the following values:\n > **Note:** - Accelerometer: x == -32; y == 12; z == -8\n > **Note:** - Gyroscope: x == -33; y == 6; z == -8\n > **Note:** - LCD models should return the following values:\n > **Note:** - Accelerometer: x == 13; y == 19; z == -8\n > **Note:** - Gyroscope: x == 13; y == 19; z == -8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDeviceLocation {
    #[doc = "Location of te accelerometer in relation to the center of the device (in mm)"]
    pub accelerometer: SceFVector3,
    #[doc = "Location of te gyroscope in relation to the center of the device (in mm)"]
    pub gyro: SceFVector3,
    #[doc = "Reserved data"]
    pub reserved: [u8; 24usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevMagnCalibData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionDevModeInfo {
    _unused: [u8; 0],
}
#[doc = "Returned motion sensor state\n > **Note:** - ::SceMotionSensorState holds actual sensor data as opposed to ::SceMotionState which uses a calculated state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionSensorState {
    #[doc = "Accelerometer data"]
    pub accelerometer: SceFVector3,
    #[doc = "Angular velocity data"]
    pub gyro: SceFVector3,
    #[doc = "Reserved data"]
    pub reserved1: [u8; 12usize],
    #[doc = "Timestamp of the data in microseconds"]
    pub timestamp: crate::ctypes::c_uint,
    #[doc = "Number of requested state"]
    pub counter: crate::ctypes::c_uint,
    #[doc = "Reserved data"]
    pub reserved2: [u8; 4usize],
    #[doc = "Timestamp of the data in microseconds"]
    pub hostTimestamp: SceULong64,
    #[doc = "Unknown"]
    pub unknown: u8,
    #[doc = "Reserved data"]
    pub reserved3: [u8; 7usize],
}
#[doc = "Returned motion state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMotionState {
    #[doc = "Local timestamp of the device"]
    pub timestamp: crate::ctypes::c_uint,
    #[doc = "Accelerometer data"]
    pub acceleration: SceFVector3,
    #[doc = "Angular velocity data"]
    pub angularVelocity: SceFVector3,
    #[doc = "Reserved data"]
    pub reserved1: [u8; 12usize],
    #[doc = "Orientation data as a Quaternion"]
    pub deviceQuat: SceFQuaternion,
    #[doc = "Orientation data as a rotation matrix"]
    pub rotationMatrix: SceFMatrix4,
    #[doc = "Magnetometer orientation matrix"]
    pub nedMatrix: SceFMatrix4,
    #[doc = "Reserved data"]
    pub reserved2: [u8; 4usize],
    #[doc = "Orientation of the device in reference to gravity"]
    pub basicOrientation: SceFVector3,
    #[doc = "Timestamp of the data in microseconds"]
    pub hostTimestamp: SceULong64,
    #[doc = "Reserved data"]
    pub reserved3: [u8; 36usize],
    #[doc = "One of ::SceMotionMagFieldStability"]
    pub magFieldStability: u8,
    #[doc = "Unknown"]
    pub unknown: u8,
    #[doc = "Reserved data"]
    pub reserved4: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogButtonsParam {
    #[doc = "Text of the first button"]
    pub msg1: *const crate::ctypes::c_char,
    #[doc = "Font size of the first button (one of ::SceMsgDialogFontSize)"]
    pub fontSize1: SceInt32,
    #[doc = "Text of the second button"]
    pub msg2: *const crate::ctypes::c_char,
    #[doc = "Font size of the second button (one of ::SceMsgDialogFontSize)"]
    pub fontSize2: SceInt32,
    #[doc = "Text of the third button"]
    pub msg3: *const crate::ctypes::c_char,
    #[doc = "Font size of the third button (one of ::SceMsgDialogFontSize)"]
    pub fontSize3: SceInt32,
    #[doc = "Reserved range"]
    pub reserved: [SceChar8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogErrorCodeParam {
    #[doc = "Displayed error code"]
    pub errorCode: SceInt32,
    #[doc = "Reserved range"]
    pub reserved: [SceChar8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogParam {
    #[doc = "Required to use MsgDialog. Just use NULL"]
    pub sdkVersion: SceUInt32,
    #[doc = "Common parameter"]
    pub commonParam: SceCommonDialogParam,
    #[doc = "Mode of function (one of ::SceMsgDialogMode)"]
    pub mode: SceInt32,
    #[doc = "Parameter for user message"]
    pub userMsgParam: *mut SceMsgDialogUserMessageParam,
    #[doc = "Parameter for system prepared message"]
    pub sysMsgParam: *mut SceMsgDialogSystemMessageParam,
    #[doc = "Parameter for display error code"]
    pub errorCodeParam: *mut SceMsgDialogErrorCodeParam,
    #[doc = "Parameter for progress bar"]
    pub progBarParam: *mut SceMsgDialogProgressBarParam,
    #[doc = "Settings for dialog environment (one of ::SceMsgDialogEnvFlag)"]
    pub flag: SceInt32,
    #[doc = "Reserved range"]
    pub reserved: [SceChar8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogProgressBarParam {
    #[doc = "Progress bar type (one of ::SceMsgDialogProgressBarType)"]
    pub barType: SceInt32,
    #[doc = "Displayed system message"]
    pub sysMsgParam: SceMsgDialogSystemMessageParam,
    #[doc = "Displayed user message"]
    pub msg: *const SceChar8,
    #[doc = "Reserved range"]
    pub reserved: [SceInt32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogResult {
    #[doc = "Mode of function (one of ::SceMsgDialogMode)"]
    pub mode: SceInt32,
    #[doc = "Result of executing function"]
    pub result: SceInt32,
    #[doc = "Id of button user selected (one of ::SceMsgDialogButtonId)"]
    pub buttonId: SceInt32,
    #[doc = "Reserved range"]
    pub reserved: [SceChar8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogSystemMessageParam {
    #[doc = "System message type (one of ::SceMsgDialogSystemMessageType)"]
    pub sysMsgType: SceInt32,
    #[doc = "Additional value"]
    pub value: SceInt32,
    #[doc = "Reserved range"]
    pub reserved: [SceChar8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsgDialogUserMessageParam {
    #[doc = "Type of button set (one of ::SceMsgDialogButtonType)"]
    pub buttonType: SceInt32,
    #[doc = "Displayed message"]
    pub msg: *const SceChar8,
    #[doc = "Buttons parameters"]
    pub buttonParam: *mut SceMsgDialogButtonsParam,
    #[doc = "Reserved range"]
    pub reserved: [SceChar8; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceMsInfo {
    pub unk_0x00: crate::ctypes::c_int,
    pub unk_0x04: crate::ctypes::c_int,
    pub nbytes: SceUInt64,
    pub nbytes2: SceUInt64,
    pub sector_size: SceUInt32,
    pub unk_0x1C: crate::ctypes::c_int,
    pub fs_offset: SceUInt32,
    pub unk_0x24: SceUInt32,
    pub unk_0x28: SceUInt32,
    pub unk_0x2C: SceUInt32,
    pub id: [SceUInt8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocctlAdhocId {
    pub type_: crate::ctypes::c_int,
    pub data: [SceChar8; 9usize],
    pub padding: [SceUChar8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocctlBSSId {
    pub data: [SceUChar8; 6usize],
    pub padding: [SceUChar8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocctlGroupName {
    pub data: [SceChar8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocctlNickname {
    pub data: [SceChar8; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocctlParameter {
    pub channel: crate::ctypes::c_int,
    pub groupName: SceNetAdhocctlGroupName,
    pub nickname: SceNetAdhocctlNickname,
    pub bssid: SceNetAdhocctlBSSId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocctlPeerInfo {
    pub next: *mut SceNetAdhocctlPeerInfo,
    pub nickname: SceNetAdhocctlNickname,
    pub macAddr: SceNetEtherAddr,
    pub padding: [SceUChar8; 6usize],
    pub lastRecv: SceUInt64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocPdpStat {
    pub next: *mut SceNetAdhocPdpStat,
    pub id: crate::ctypes::c_int,
    pub laddr: SceNetEtherAddr,
    pub lport: SceUShort16,
    pub rcv_sb_cc: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocPollSd {
    pub id: crate::ctypes::c_int,
    pub events: crate::ctypes::c_int,
    pub revents: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetAdhocPtpStat {
    pub next: *mut SceNetAdhocPtpStat,
    pub id: crate::ctypes::c_int,
    pub laddr: SceNetEtherAddr,
    pub paddr: SceNetEtherAddr,
    pub lport: SceUShort16,
    pub pport: SceUShort16,
    pub snd_sb_cc: crate::ctypes::c_uint,
    pub rcv_sb_cc: crate::ctypes::c_uint,
    pub state: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCheckDialogAgeRestriction {
    pub countryCode: [crate::ctypes::c_char; 2usize],
    pub age: SceInt8,
    pub padding: SceInt8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCheckDialogParam {
    pub sdkVersion: SceUInt32,
    pub commonParam: SceCommonDialogParam,
    pub mode: SceInt32,
    pub npCommunicationId: SceNpCommunicationId,
    pub ps3ConnectParam: *mut SceNetCheckDialogPS3ConnectParam,
    pub groupName: *mut SceNetAdhocctlGroupName,
    pub timeoutUs: SceUInt32,
    pub defaultAgeRestriction: SceInt8,
    pub padding: [SceInt8; 3usize],
    pub ageRestrictionCount: SceInt32,
    pub ageRestriction: *const SceNetCheckDialogAgeRestriction,
    pub reserved: [SceUInt8; 104usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCheckDialogPS3ConnectInfo {
    pub inaddr: SceNetInAddr,
    pub nickname: [SceUInt8; 128usize],
    pub macAddress: [SceUInt8; 6usize],
    pub reserved: [SceUInt8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCheckDialogPS3ConnectParam {
    pub action: SceInt32,
    pub ssid: [crate::ctypes::c_char; 33usize],
    pub wpaKey: [crate::ctypes::c_char; 65usize],
    pub titleId: [crate::ctypes::c_char; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCheckDialogResult {
    pub result: SceInt32,
    pub psnModeSucceeded: SceBool,
    pub reserved: [SceUInt8; 124usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCtlAdhocPeerInfo {
    pub next: *mut SceNetCtlAdhocPeerInfo,
    pub inet_addr: SceNetInAddr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceNetCtlInfo {
    pub cnf_name: [crate::ctypes::c_char; 65usize],
    pub device: crate::ctypes::c_uint,
    pub ether_addr: SceNetEtherAddr,
    pub mtu: crate::ctypes::c_uint,
    pub link: crate::ctypes::c_uint,
    pub bssid: SceNetEtherAddr,
    pub ssid: [crate::ctypes::c_char; 33usize],
    pub wifi_security: crate::ctypes::c_uint,
    pub rssi_dbm: crate::ctypes::c_uint,
    pub rssi_percentage: crate::ctypes::c_uint,
    pub channel: crate::ctypes::c_uint,
    pub ip_config: crate::ctypes::c_uint,
    pub dhcp_hostname: [crate::ctypes::c_char; 256usize],
    pub pppoe_auth_name: [crate::ctypes::c_char; 128usize],
    pub ip_address: [crate::ctypes::c_char; 16usize],
    pub netmask: [crate::ctypes::c_char; 16usize],
    pub default_route: [crate::ctypes::c_char; 16usize],
    pub primary_dns: [crate::ctypes::c_char; 16usize],
    pub secondary_dns: [crate::ctypes::c_char; 16usize],
    pub http_proxy_config: crate::ctypes::c_uint,
    pub http_proxy_server: [crate::ctypes::c_char; 256usize],
    pub http_proxy_port: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetCtlNatInfo {
    pub size: crate::ctypes::c_uint,
    pub stun_status: crate::ctypes::c_int,
    pub nat_type: crate::ctypes::c_int,
    pub mapped_addr: SceNetInAddr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetDnsInfo {
    pub dns_addr: [SceNetInAddr; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetEmulationData {
    pub drop_rate: crate::ctypes::c_ushort,
    pub drop_duration: crate::ctypes::c_ushort,
    pub pass_duration: crate::ctypes::c_ushort,
    pub delay_time: crate::ctypes::c_ushort,
    pub delay_jitter: crate::ctypes::c_ushort,
    pub order_rate: crate::ctypes::c_ushort,
    pub order_delay_time: crate::ctypes::c_ushort,
    pub duplication_rate: crate::ctypes::c_ushort,
    pub bps_limit: crate::ctypes::c_uint,
    pub lower_size_limit: crate::ctypes::c_ushort,
    pub upper_size_limit: crate::ctypes::c_ushort,
    pub system_policy_pattern: crate::ctypes::c_uint,
    pub game_policy_pattern: crate::ctypes::c_uint,
    pub policy_flags: [crate::ctypes::c_ushort; 64usize],
    pub reserved: [crate::ctypes::c_uchar; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetEmulationParam {
    pub version: crate::ctypes::c_ushort,
    pub option_number: crate::ctypes::c_ushort,
    pub current_version: crate::ctypes::c_ushort,
    pub result: crate::ctypes::c_ushort,
    pub flags: crate::ctypes::c_uint,
    pub reserved1: crate::ctypes::c_uint,
    pub send: SceNetEmulationData,
    pub recv: SceNetEmulationData,
    pub seed: crate::ctypes::c_uint,
    pub reserved: [crate::ctypes::c_uchar; 44usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceNetEpollData {
    pub ptr: *mut crate::ctypes::c_void,
    pub fd: crate::ctypes::c_int,
    pub u32_: crate::ctypes::c_uint,
    pub u64_: crate::ctypes::c_ulonglong,
    pub ext: SceNetEpollDataExt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetEpollDataExt {
    pub id: crate::ctypes::c_int,
    pub u32_: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceNetEpollEvent {
    pub events: crate::ctypes::c_uint,
    pub reserved: crate::ctypes::c_uint,
    pub system: SceNetEpollSystemData,
    pub data: SceNetEpollData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetEpollSystemData {
    pub system: [crate::ctypes::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetEtherAddr {
    pub data: [crate::ctypes::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetFdSet {
    pub bits: [crate::ctypes::c_uint; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceNetIcmpHeader {
    pub type_: crate::ctypes::c_uchar,
    pub code: crate::ctypes::c_uchar,
    pub checksum: crate::ctypes::c_ushort,
    pub un: SceNetIcmpHeaderUnion,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetIcmpHeaderEcho {
    pub id: crate::ctypes::c_ushort,
    pub sequence: crate::ctypes::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetIcmpHeaderFrag {
    pub unused: crate::ctypes::c_ushort,
    pub mtu: crate::ctypes::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceNetIcmpHeaderUnion {
    pub echo: SceNetIcmpHeaderEcho,
    pub gateway: crate::ctypes::c_uint,
    pub frag: SceNetIcmpHeaderFrag,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetInAddr {
    pub s_addr: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetInitParam {
    pub memory: *mut crate::ctypes::c_void,
    pub size: crate::ctypes::c_int,
    pub flags: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetIovec {
    pub iov_base: *mut crate::ctypes::c_void,
    pub iov_len: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceNetIpHeader {
    pub un: SceNetIpHeaderUnion,
    pub ip_tos: crate::ctypes::c_uchar,
    pub ip_len: crate::ctypes::c_ushort,
    pub ip_id: crate::ctypes::c_ushort,
    pub ip_off: crate::ctypes::c_ushort,
    pub ip_ttl: crate::ctypes::c_uchar,
    pub ip_p: crate::ctypes::c_uchar,
    pub ip_sum: crate::ctypes::c_ushort,
    pub ip_src: SceNetInAddr,
    pub ip_dst: SceNetInAddr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetIpHeaderIpVerHl {
    pub hl: crate::ctypes::c_uchar,
    pub ver: crate::ctypes::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceNetIpHeaderUnion {
    pub ip_ver_hl: SceNetIpHeaderIpVerHl,
    pub ver_hl: crate::ctypes::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetIpMreq {
    pub imr_multiaddr: SceNetInAddr,
    pub imr_interface: SceNetInAddr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetLinger {
    pub l_onoff: crate::ctypes::c_int,
    pub l_linger: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetMsghdr {
    pub msg_name: *mut crate::ctypes::c_void,
    pub msg_namelen: crate::ctypes::c_uint,
    pub msg_iov: *mut SceNetIovec,
    pub msg_iovlen: crate::ctypes::c_int,
    pub msg_control: *mut crate::ctypes::c_void,
    pub msg_controllen: crate::ctypes::c_uint,
    pub msg_flags: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetResolverParam {
    pub allocate: SceNetResolverFunctionAllocate,
    pub free: SceNetResolverFunctionFree,
    pub user: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetSockaddr {
    pub sa_len: crate::ctypes::c_uchar,
    pub sa_family: crate::ctypes::c_uchar,
    pub sa_data: [crate::ctypes::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetSockaddrIn {
    pub sin_len: crate::ctypes::c_uchar,
    pub sin_family: crate::ctypes::c_uchar,
    pub sin_port: crate::ctypes::c_ushort,
    pub sin_addr: SceNetInAddr,
    pub sin_vport: crate::ctypes::c_ushort,
    pub sin_zero: [crate::ctypes::c_char; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetSockInfo {
    pub name: [crate::ctypes::c_char; 32usize],
    pub pid: crate::ctypes::c_int,
    pub s: crate::ctypes::c_int,
    pub socket_type: crate::ctypes::c_char,
    pub policy: crate::ctypes::c_char,
    pub reserved16: crate::ctypes::c_short,
    pub recv_queue_length: crate::ctypes::c_int,
    pub send_queue_length: crate::ctypes::c_int,
    pub local_adr: SceNetInAddr,
    pub remote_adr: SceNetInAddr,
    pub local_port: crate::ctypes::c_ushort,
    pub remote_port: crate::ctypes::c_ushort,
    pub local_vport: crate::ctypes::c_ushort,
    pub remote_vport: crate::ctypes::c_ushort,
    pub state: crate::ctypes::c_int,
    pub flags: crate::ctypes::c_int,
    pub reserved: [crate::ctypes::c_int; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetStatisticsInfo {
    pub kernel_mem_free_size: crate::ctypes::c_int,
    pub kernel_mem_free_min: crate::ctypes::c_int,
    pub packet_count: crate::ctypes::c_int,
    pub packet_qos_count: crate::ctypes::c_int,
    pub libnet_mem_free_size: crate::ctypes::c_int,
    pub libnet_mem_free_min: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNetSyscallParameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsBufferInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsCallbackInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsCallbackListInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsParamsDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsPatchSetupInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsRackDescription {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsSystemInitParams {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsVoiceDefinition {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNgsVoicePreset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNotificationUtilProgressFinishParam {
    pub notificationText: [SceWChar16; 63usize],
    pub separator0: SceInt16,
    pub notificationSubText: [SceWChar16; 63usize],
    pub separator1: SceInt16,
    pub path: [SceChar8; 1000usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNotificationUtilProgressInitParam {
    pub notificationText: [SceWChar16; 63usize],
    pub separator0: SceInt16,
    pub notificationSubText: [SceWChar16; 63usize],
    pub separator1: SceInt16,
    pub unk: [SceChar8; 998usize],
    pub unk_4EC: SceInt32,
    pub eventHandler: SceNotificationUtilProgressEventHandler,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNotificationUtilProgressUpdateParam {
    pub notificationText: [SceWChar16; 63usize],
    pub separator0: SceInt16,
    pub notificationSubText: [SceWChar16; 63usize],
    pub separator1: SceInt16,
    pub targetProgress: SceFloat,
    pub reserved: [SceChar8; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNpCommunicationId {
    pub data: [crate::ctypes::c_char; 9usize],
    pub term: crate::ctypes::c_char,
    pub num: SceUChar8,
    pub dummy: crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNpDrmActivationData {
    pub act_type: SceInt16,
    pub version_flag: SceInt16,
    pub version: SceInt32,
    pub account_id: SceUInt64,
    pub primary_key_table: [[SceUInt8; 16usize]; 128usize],
    pub unk1: [SceUInt8; 64usize],
    pub openpsid: [SceUInt8; 16usize],
    pub unk2: [SceUInt8; 16usize],
    pub unk3: [SceUInt8; 16usize],
    pub secondary_key_table: [[SceUInt8; 16usize]; 101usize],
    pub rsa_signature: [SceUInt8; 256usize],
    pub unk_sigmature: [SceUInt8; 64usize],
    pub ecdsa_signature: [SceUInt8; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceNpDrmLicense {
    pub version: SceInt16,
    pub version_flags: SceInt16,
    pub license_type: SceInt16,
    pub license_flags: SceInt16,
    pub account_id: SceUInt64,
    pub content_id: [crate::ctypes::c_char; 48usize],
    pub key_table: [crate::ctypes::c_char; 16usize],
    pub key1: [crate::ctypes::c_char; 16usize],
    pub start_time: SceInt64,
    pub expiration_time: SceInt64,
    pub ecdsa_signature: [crate::ctypes::c_char; 40usize],
    pub flags: SceInt64,
    pub key2: [crate::ctypes::c_char; 16usize],
    pub unk_0xB0: [crate::ctypes::c_char; 16usize],
    pub open_psid: [crate::ctypes::c_char; 16usize],
    pub unk_0xD0: [crate::ctypes::c_char; 16usize],
    pub cmd56_handshake_part: [crate::ctypes::c_char; 20usize],
    pub debug_upgradable: crate::ctypes::c_int,
    pub unk_0xF8: crate::ctypes::c_int,
    pub sku_flag: crate::ctypes::c_int,
    pub rsa_signature: [crate::ctypes::c_char; 256usize],
}
#[doc = "Options for _sceNpDrmPackageDecrypt"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sceNpDrmPackageDecrypt {
    #[doc = "The offset in the encrypted data"]
    pub offset: SceOff,
    #[doc = "The identifier specified for _sceNpDrmPackageCheck but NOT ORed\n with (1 << 8)"]
    pub identifier: crate::ctypes::c_uint,
}
#[repr(C)]
pub struct SceObjectBase {
    pub __bindgen_anon_1: SceObjectBase__bindgen_ty_1,
    pub data: __IncompleteArrayField<u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceObjectBase__bindgen_ty_1 {
    pub sce_reserved: [u32; 2usize],
    pub __bindgen_anon_1: SceObjectBase__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceObjectBase__bindgen_ty_1__bindgen_ty_1 {
    pub object: *mut crate::ctypes::c_void,
    pub sce_class: *mut SceClass,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceOpenPsId {
    pub open_psid: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePafDateTime {
    pub data: SceDateTime,
    pub data_0x10: crate::ctypes::c_int,
    pub data_0x14: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePafHeapContext {
    pub vtable: *mut crate::ctypes::c_void,
    pub heap: *mut crate::ctypes::c_void,
    pub membase: *mut crate::ctypes::c_void,
    pub size: SceSize,
    pub name: [crate::ctypes::c_char; 32usize],
    pub is_import_membase: SceChar8,
    pub is_skip_debug_msg: SceChar8,
    pub data_0x32: crate::ctypes::c_char,
    pub data_0x33: crate::ctypes::c_char,
    pub data_0x34: crate::ctypes::c_int,
    pub lw_mtx: SceKernelLwMutexWork,
    pub memblk_id: SceUID,
    pub mode: SceInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePafHeapOpt {
    pub a1: crate::ctypes::c_int,
    pub a2: crate::ctypes::c_int,
    pub is_skip_debug_msg: SceChar8,
    pub a3: [crate::ctypes::c_char; 3usize],
    pub mode: SceInt32,
    pub a5: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePafSha1Context {
    pub h: [u32; 5usize],
    pub unk: [crate::ctypes::c_char; 84usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePfsRndDriveId {
    pub drive_id: [crate::ctypes::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePortabilityData {
    pub msg_size: SceSize,
    pub msg: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceProcEventHandler {
    pub size: SceSize,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            a2: *mut SceProcEventInvokeParam2,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub exit: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            a2: *mut SceProcEventInvokeParam1,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub kill: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            a2: *mut SceProcEventInvokeParam1,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            event_type: crate::ctypes::c_int,
            a3: *mut SceProcEventInvokeParam1,
            a4: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub start: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            event_type: crate::ctypes::c_int,
            a3: *mut SceProcEventInvokeParam1,
            a4: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub switch_process: ::core::option::Option<
        unsafe extern "C" fn(
            event_id: crate::ctypes::c_int,
            event_type: crate::ctypes::c_int,
            a3: *mut SceProcEventInvokeParam2,
            a4: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceProcEventInvokeParam1 {
    pub size: SceSize,
    pub unk_0x04: crate::ctypes::c_int,
    pub unk_0x08: crate::ctypes::c_int,
    pub unk_0x0C: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceProcEventInvokeParam2 {
    pub size: SceSize,
    pub pid: SceUID,
    pub unk_0x08: crate::ctypes::c_int,
    pub unk_0x0C: crate::ctypes::c_int,
    pub unk_0x10: crate::ctypes::c_int,
}
#[doc = "Parameters for scePromoterUtilityPromoteImport()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePromoterUtilityImportParams {
    #[doc = "Install path (ux0:/temp/game on PSM/PSV, ux0:/pspemu/temp/game on PSP)"]
    pub path: [crate::ctypes::c_char; 128usize],
    #[doc = "Game titleid"]
    pub titleid: [crate::ctypes::c_char; 12usize],
    #[doc = "Package type"]
    pub type_: ScePromoterUtilityPackageType,
    #[doc = "Additional Attributes (Appears to be 0x1 on PSM content but 0x00 on Vita contents)"]
    pub attribute: u32,
    pub reserved: [crate::ctypes::c_char; 28usize],
}
#[doc = "Parameters for scePromoterUtilityUpdateLiveArea()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePromoterUtilityLAUpdate {
    #[doc = "Target app."]
    pub titleid: [crate::ctypes::c_char; 12usize],
    #[doc = "Directory of extracted LA update data."]
    pub path: [crate::ctypes::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePsCode {
    pub company_code: u16,
    pub product_code: u16,
    pub product_sub_code: u16,
    pub factory_code: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePsmDrmLicense {
    pub magic: [crate::ctypes::c_char; 8usize],
    pub unk1: SceUInt32,
    pub unk2: SceUInt32,
    pub account_id: SceUInt64,
    pub unk3: SceUInt32,
    pub unk4: SceUInt32,
    pub start_time: SceUInt64,
    pub expiration_time: SceUInt64,
    pub activation_checksum: [SceUInt8; 32usize],
    pub content_id: [crate::ctypes::c_char; 48usize],
    pub unk5: [SceUInt8; 128usize],
    pub unk6: [SceUInt8; 32usize],
    pub key: [SceUInt8; 16usize],
    pub signature: [SceUInt8; 464usize],
    pub rsa_signature: [SceUInt8; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePssCryptoHandle {
    pub fd: SceUID,
    pub unk1: u32,
    pub size: SceSize,
    pub unk3: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfCacheKey {
    pub keyValue0: crate::ctypes::c_int,
    pub keyValue1: crate::ctypes::c_int,
    pub keyValue2: f32,
    pub keyValue3: f32,
    pub keyValue4: f32,
    pub keyValue5: f32,
    pub keyValue6: f32,
    pub keyValue7: f32,
    pub keyValue8: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfCacheSystemInterface {
    pub cacheInstance: *mut ScePvfPointer,
    pub lockFunc: ScePvfFontCacheLockFunc,
    pub unlockFunc: ScePvfFontChcheUnlockFunc,
    pub findFunc: ScePvfFontChcheFindFunc,
    pub writeKeyValueToCacheFunc: ScePvfFontChcheWriteKeyValueToCacheFunc,
    pub write0ToCacheFunc: ScePvfFontChcheWriteToCacheFunc,
    pub write1ToCacheFunc: ScePvfFontChcheWriteToCacheFunc,
    pub read0FromCacheFunc: ScePvfFontChcheReadFromCacheFunc,
    pub read1FromCacheFunc: ScePvfFontChcheReadFromCacheFunc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfCharInfo {
    pub bitmapWidth: ScePvfU32,
    pub bitmapHeight: ScePvfU32,
    pub bitmapPitch: ScePvfU32,
    pub bitmapLeft: ScePvfS32,
    pub bitmapTop: ScePvfS32,
    pub glyphMetrics: ScePvfIGlyphMetricsInfo,
    pub reserved0: [ScePvfU8; 2usize],
    pub reserved1: ScePvfU16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfFGlyphMetricsInfo {
    pub width: ScePvfFloat32,
    pub height: ScePvfFloat32,
    pub ascender: ScePvfFloat32,
    pub descender: ScePvfFloat32,
    pub horizontalBearingX: ScePvfFloat32,
    pub horizontalBearingY: ScePvfFloat32,
    pub verticalBearingX: ScePvfFloat32,
    pub verticalBearingY: ScePvfFloat32,
    pub horizontalAdvance: ScePvfFloat32,
    pub verticalAdvance: ScePvfFloat32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfFKerningInfo {
    pub xOffset: ScePvfFloat32,
    pub yOffset: ScePvfFloat32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfFontInfo {
    pub maxIGlyphMetrics: ScePvfIGlyphMetricsInfo,
    pub maxFGlyphMetrics: ScePvfFGlyphMetricsInfo,
    pub numChars: ScePvfU32,
    pub fontStyleInfo: ScePvfFontStyleInfo,
    pub reserved: [ScePvfU8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfFontStyleInfo {
    pub weight: ScePvfFloat32,
    pub familyCode: ScePvfU16,
    pub style: ScePvfU16,
    pub subStyle: ScePvfU16,
    pub languageCode: ScePvfU16,
    pub regionCode: ScePvfU16,
    pub countryCode: ScePvfU16,
    pub fontName: [ScePvfU8; 64usize],
    pub styleName: [ScePvfU8; 64usize],
    pub fileName: [ScePvfU8; 64usize],
    pub extraAttributes: ScePvfU32,
    pub expireDate: ScePvfU32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfIGlyphMetricsInfo {
    pub width64: ScePvfU32,
    pub height64: ScePvfU32,
    pub ascender64: ScePvfS32,
    pub descender64: ScePvfS32,
    pub horizontalBearingX64: ScePvfS32,
    pub horizontalBearingY64: ScePvfS32,
    pub verticalBearingX64: ScePvfS32,
    pub verticalBearingY64: ScePvfS32,
    pub horizontalAdvance64: ScePvfS32,
    pub verticalAdvance64: ScePvfS32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfIKerningInfo {
    pub xOffset64: ScePvfS32,
    pub yOffset64: ScePvfS32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfInitRec {
    pub userData: ScePvfPointer,
    pub maxNumFonts: ScePvfU32,
    pub cache: *mut ScePvfCacheSystemInterface,
    pub reserved: ScePvfPointer,
    pub allocFunc: ScePvfAllocFunc,
    pub reallocFunc: ScePvfReallocFunc,
    pub freeFunc: ScePvfFreeFunc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfIrect {
    pub width: ScePvfU16,
    pub height: ScePvfU16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfKerningInfo {
    pub iKerningInfo: ScePvfIKerningInfo,
    pub fKerningInfo: ScePvfFKerningInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfRect {
    pub width: ScePvfU32,
    pub height: ScePvfU32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePvfUserImageBufferRec {
    pub pixelFormat: ScePvfU32,
    pub xPos64: ScePvfS32,
    pub yPos64: ScePvfS32,
    pub rect: ScePvfIrect,
    pub bytesPerLine: ScePvfU16,
    pub reserved: ScePvfU16,
    pub buffer: *mut ScePvfU8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryFrame {
    #[doc = "Distinguishing header for the entry"]
    pub header: SceRazorGpuLiveEntryHeader,
    #[doc = "Start time of the entry in microseconds"]
    pub start_time: u64,
    #[doc = "Duration of the frame in microseconds"]
    pub duration: u32,
    #[doc = "Number of the frame"]
    pub frame_number: u32,
    #[doc = "Duration of GPU activity for the frame in microseconds"]
    pub gpu_activity_duration_time: u32,
    #[doc = "Reserved data"]
    pub reserved: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryHeader {
    #[doc = "Entry size in bytes"]
    pub entry_size: u16,
    #[doc = "Entry type (One of ::SceRazorLiveTraceMetricEntryType)"]
    pub entry_type: u16,
    #[doc = "Reserved data"]
    pub reserved: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJob {
    #[doc = "Distinguishing header for the entry"]
    pub header: SceRazorGpuLiveEntryHeader,
    #[doc = "Start time of the entry in microseconds"]
    pub start_time: u64,
    #[doc = "End time of the entry in microseconds"]
    pub end_time: u64,
    #[doc = "The type of the job (One of ::SceRazorLiveTraceMetricJobType)"]
    pub type_: u8,
    #[doc = "Core number on which the job got executed"]
    pub core: i8,
    #[doc = "Index of the scene in which the job got executed"]
    pub scene_index: u16,
    #[doc = "Frame number in which the job got executed"]
    pub frame_number: u32,
    #[doc = "Reported values by the job"]
    pub job_values: SceRazorGpuLiveEntryJobValues,
    #[doc = "ID of the process which executed the job"]
    pub process_id: u32,
    #[doc = "Unknown data"]
    pub unk: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobFragmentValues1 {
    #[doc = "USSE fragment processing percentage"]
    pub usse_fragment_processing_percent: f32,
    #[doc = "USSE dependant texture reads requests percentage"]
    pub usse_dependent_texture_reads_percent: f32,
    #[doc = "USSE non-dependant texture reads requests percentage"]
    pub usse_non_dependent_texture_reads_percent: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobFragmentValues2 {
    #[doc = "Number of rasterized pixels before Hidden Surface Removal"]
    pub rasterized_pixels_before_hsr_num: u32,
    #[doc = "Number of rasterized pixels"]
    pub rasterized_output_pixels_num: u32,
    #[doc = "Number of rasterized samples"]
    pub rasterized_output_samples_num: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobFragmentValues3 {
    #[doc = "Amount of ISP parameter fetches memory reads in bytes"]
    pub isp_parameter_fetches_mem_reads: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobValues {
    #[doc = "Values for a job of SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX1 type"]
    pub vertex_values_type1: SceRazorGpuLiveEntryJobVertexValues1,
    #[doc = "Values for a job of SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT1 type"]
    pub fragment_values_type1: SceRazorGpuLiveEntryJobFragmentValues1,
    #[doc = "Values for a job of SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX2 type"]
    pub vertex_values_type2: SceRazorGpuLiveEntryJobVertexValues2,
    #[doc = "Values for a job of SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT2 type"]
    pub fragment_values_type2: SceRazorGpuLiveEntryJobFragmentValues2,
    #[doc = "Values for a job of SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX3 type"]
    pub vertex_values_type3: SceRazorGpuLiveEntryJobVertexValues3,
    #[doc = "Values for a job of SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT3 type"]
    pub fragment_values_type3: SceRazorGpuLiveEntryJobFragmentValues3,
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_int; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobVertexValues1 {
    #[doc = "USSE vertex processing percentage"]
    pub usse_vertex_processing_percent: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobVertexValues2 {
    #[doc = "VDM input primitives number"]
    pub vdm_primitives_input_num: u32,
    #[doc = "MTE output primitives number"]
    pub mte_primitives_output_num: u32,
    #[doc = "VDM input vertices number"]
    pub vdm_vertices_input_num: u32,
    #[doc = "MTE output vertices number"]
    pub mte_vertices_output_num: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryJobVertexValues3 {
    #[doc = "Amount of tiling accelerated memory writes in bytes"]
    pub tiling_accelerated_mem_writes: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveEntryParameterBuffer {
    #[doc = "Distinguishing header for the entry"]
    pub header: SceRazorGpuLiveEntryHeader,
    #[doc = "Time of param buffer peak usage in microseconds"]
    pub peak_usage_timestamp: u64,
    #[doc = "Memory peak usage of the param buffer in bytes"]
    pub peak_usage_value: u32,
    #[doc = "Flag indicating wether a partial render occurred or not"]
    pub partial_render: u8,
    #[doc = "Flag indicating wether a vertex job had been paused or not"]
    pub vertex_job_paused: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRazorGpuLiveResultInfo {
    #[doc = "Pointer to the raw data results entries."]
    pub result_data: *mut crate::ctypes::c_void,
    #[doc = "Number of elements stored in the results buffer"]
    pub entry_count: SceSize,
    pub overflow_count: SceSize,
    #[doc = "Size of the results buffer in bytes"]
    pub buffer_size: SceSize,
    #[doc = "Start time of the results collection in microseconds"]
    pub start_time: u64,
    #[doc = "End time of the results collection in microseconds"]
    pub end_time: u64,
    #[doc = "Metrics group used for the results"]
    pub metric_group: u32,
    #[doc = "Reserved data"]
    pub reserved: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceRtcTick {
    pub tick: SceUInt64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblDmac5EncDecParam {
    pub src: *const crate::ctypes::c_void,
    pub dst: *mut crate::ctypes::c_void,
    pub length: SceSize,
    pub key: *const crate::ctypes::c_void,
    pub keysize: SceSize,
    pub iv: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblDmac5HashTransformContext {
    pub state: [SceUInt32; 8usize],
    pub length: SceUInt64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblDmac5HashTransformParam {
    pub src: *const crate::ctypes::c_void,
    pub dst: *mut crate::ctypes::c_void,
    pub length: SceSize,
    pub key: *const crate::ctypes::c_void,
    pub keysize: SceSize,
    pub ctx: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblRsaDataParam {
    pub data: *mut crate::ctypes::c_void,
    pub size: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblRsaPrivateKeyParam {
    pub unk_0x00: crate::ctypes::c_int,
    pub unk_0x04: crate::ctypes::c_int,
    pub unk_0x08: crate::ctypes::c_int,
    pub unk_0x0C: crate::ctypes::c_int,
    pub p: *mut crate::ctypes::c_void,
    pub q: *mut crate::ctypes::c_void,
    pub dp: *mut crate::ctypes::c_void,
    pub dq: *mut crate::ctypes::c_void,
    pub qp: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblRsaPublicKeyParam {
    pub n: *const crate::ctypes::c_void,
    pub k: *const crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSblSmCommPair {
    pub data_00: crate::ctypes::c_int,
    pub data_04: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceScreenShotParam {
    #[doc = "Photo title"]
    pub photoTitle: *const SceWChar32,
    #[doc = "Game title"]
    pub gameTitle: *const SceWChar32,
    #[doc = "Game description"]
    pub gameComment: *const SceWChar32,
    #[doc = "Reserved range (Must be NULL)"]
    pub reserved: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSelfAuthInfo {
    pub program_authority_id: SceUInt64,
    pub padding: [u8; 8usize],
    pub capability: [u8; 32usize],
    pub attribute: [u8; 32usize],
    pub secret: SceSharedSecret,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSha1Context {
    pub h: [u32; 5usize],
    pub usRemains: u16,
    pub usComputed: u16,
    pub ullTotalLen: u64,
    pub buf: [crate::ctypes::c_char; 64usize],
    pub result: [crate::ctypes::c_char; 20usize],
    pub pad: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSha224Context {
    pub h: [u32; 8usize],
    pub pad: u32,
    pub usRemains: u16,
    pub usComputed: u16,
    pub ullTotalLen: u64,
    pub buf: [crate::ctypes::c_char; 64usize],
    pub result: [crate::ctypes::c_char; 28usize],
    pub pad2: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSha256Context {
    pub h: [u32; 8usize],
    pub pad: u32,
    pub usRemains: u16,
    pub usComputed: u16,
    pub ullTotalLen: u64,
    pub buf: [crate::ctypes::c_char; 64usize],
    pub result: [crate::ctypes::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShaccCgCallbackList {
    pub openFile: SceShaccCgCallbackOpenFile,
    pub releaseFile: SceShaccCgCallbackReleaseFile,
    pub locateFile: SceShaccCgCallbackLocateFile,
    pub absolutePath: SceShaccCgCallbackAbsolutePath,
    pub releaseFileName: SceShaccCgCallbackReleaseFileName,
    pub fileDate: SceShaccCgCallbackFileDate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShaccCgCompileOptions {
    pub mainSourceFile: *const crate::ctypes::c_char,
    pub targetProfile: SceShaccCgTargetProfile,
    pub entryFunctionName: *const crate::ctypes::c_char,
    pub searchPathCount: SceUInt32,
    pub searchPaths: *const *const crate::ctypes::c_char,
    pub macroDefinitionCount: SceUInt32,
    pub macroDefinitions: *const *const crate::ctypes::c_char,
    pub includeFileCount: SceUInt32,
    pub includeFiles: *const *const crate::ctypes::c_char,
    pub suppressedWarningsCount: SceUInt32,
    pub suppressedWarnings: *const SceUInt32,
    pub locale: SceShaccCgLocale,
    pub useFx: SceInt32,
    pub noStdlib: SceInt32,
    pub optimizationLevel: SceInt32,
    pub useFastmath: SceInt32,
    pub useFastprecision: SceInt32,
    pub useFastint: SceInt32,
    pub field_48: crate::ctypes::c_int,
    pub warningsAsErrors: SceInt32,
    pub performanceWarnings: SceInt32,
    pub warningLevel: SceInt32,
    pub pedantic: SceInt32,
    pub pedanticError: SceInt32,
    pub field_60: crate::ctypes::c_int,
    pub field_64: crate::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShaccCgCompileOutput {
    pub programData: *const u8,
    pub programSize: SceUInt32,
    pub diagnosticCount: SceInt32,
    pub diagnostics: *const SceShaccCgDiagnosticMessage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShaccCgDiagnosticMessage {
    pub level: SceShaccCgDiagnosticLevel,
    pub code: SceUInt32,
    pub location: *const SceShaccCgSourceLocation,
    pub message: *const crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShaccCgSourceFile {
    pub fileName: *const crate::ctypes::c_char,
    pub text: *const crate::ctypes::c_char,
    pub size: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShaccCgSourceLocation {
    pub file: *const SceShaccCgSourceFile,
    pub lineNumber: SceUInt32,
    pub columnNumber: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSharedFbInfo {
    pub fb_base: *mut crate::ctypes::c_void,
    pub fb_size: crate::ctypes::c_int,
    pub fb_base2: *mut crate::ctypes::c_void,
    pub unk0: [crate::ctypes::c_int; 6usize],
    pub stride: crate::ctypes::c_int,
    pub width: crate::ctypes::c_int,
    pub height: crate::ctypes::c_int,
    pub unk1: crate::ctypes::c_int,
    pub index: crate::ctypes::c_int,
    pub unk2: [crate::ctypes::c_int; 4usize],
    pub vsync: crate::ctypes::c_int,
    pub unk3: [crate::ctypes::c_int; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSharedSecret {
    pub shared_secret_0: [u8; 16usize],
    pub klicensee: [u8; 16usize],
    pub shared_secret_2: [u8; 16usize],
    pub shared_secret_3_0: u32,
    pub shared_secret_3_1: u32,
    pub shared_secret_3_2: u32,
    pub shared_secret_3_3: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceShellUtilLaunchAppParam {
    pub cmd: *const crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSqliteMallocMethods {
    pub xMalloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: crate::ctypes::c_int) -> *mut crate::ctypes::c_void,
    >,
    pub xRealloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::ctypes::c_void,
            arg2: crate::ctypes::c_int,
        ) -> *mut crate::ctypes::c_void,
    >,
    pub xFree: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSslMemoryPoolStats {
    pub poolSize: crate::ctypes::c_uint,
    pub maxInuseSize: crate::ctypes::c_uint,
    pub currentInuseSize: crate::ctypes::c_uint,
    pub reserved: crate::ctypes::c_int,
}
#[doc = "A set of debug handlers for syscon, that you can set in ksceSysconSetDebugHandlers()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysconDebugHandlers {
    #[doc = "Structure size (probably, unused)."]
    pub size: crate::ctypes::c_int,
    #[doc = "Callback ran right before running a packet, with a pointer to it passed as the first argument."]
    pub start: ::core::option::Option<unsafe extern "C" fn(packet: *mut SceSysconPacket)>,
    #[doc = "Callback ran right after finishing running a packet, with a pointer to it passed as the first argument."]
    pub end: ::core::option::Option<unsafe extern "C" fn(packet: *mut SceSysconPacket)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysconPacket {
    pub next: *mut SceSysconPacket,
    pub status: crate::ctypes::c_uint,
    pub semaId: SceUID,
    pub unk: crate::ctypes::c_uint,
    pub tx: [crate::ctypes::c_uchar; 32usize],
    pub rx: [crate::ctypes::c_uchar; 32usize],
    pub unk1: [crate::ctypes::c_uint; 4usize],
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(
            packet: *mut SceSysconPacket,
            argp: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    pub argp: *mut crate::ctypes::c_void,
    pub time: crate::ctypes::c_uint,
    pub unk2: [crate::ctypes::c_uint; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysmoduleOpt {
    pub flags: crate::ctypes::c_int,
    pub result: *mut crate::ctypes::c_int,
    pub unused: [crate::ctypes::c_int; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysrootDbgpHandler {
    #[doc = "sizeof(SceSysrootDbgpHandler):0x5C"]
    pub size: SceSize,
    pub unk_0x04: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
            a4: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x08: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
            a4: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x0C: ::core::option::Option<unsafe extern "C" fn(a1: crate::ctypes::c_int)>,
    pub unk_0x10: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
            a4: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x14: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
            a4: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x18: ::core::option::Option<
        unsafe extern "C" fn(pid: SceUID, modid: SceUID, flags: crate::ctypes::c_int, time: u64),
    >,
    pub unk_0x1C: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x20: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x24: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ),
    >,
    pub unk_0x28:
        ::core::option::Option<unsafe extern "C" fn(pid: SceUID, modid: SceUID, time: u64)>,
    pub unk_0x2C:
        ::core::option::Option<unsafe extern "C" fn(pid: SceUID, modid: SceUID, time: u64)>,
    pub unk_0x30: ::core::option::Option<unsafe extern "C" fn(pid: SceUID) -> crate::ctypes::c_int>,
    pub unk_0x34: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x38: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x3C: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x40: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            some_flag: *mut crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x44: ::core::option::Option<
        unsafe extern "C" fn(
            pid: SceUID,
            modid: SceUID,
            flags: crate::ctypes::c_int,
            time: u64,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x48: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x4C: ::core::option::Option<unsafe extern "C" fn()>,
    pub unk_0x50: ::core::option::Option<unsafe extern "C" fn()>,
    pub unk_0x54: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
            a4: crate::ctypes::c_int,
            a5: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x58: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysrootForDriver_733C243E_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysrootForKernel_D29BCA77_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysrootModulemgrHandlers {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceSysrootProcessHandler {
    #[doc = "sizeof(SceSysrootProcessHandler)"]
    pub size: SceSize,
    #[doc = "process start shared modules"]
    pub unk_4: ::core::option::Option<
        unsafe extern "C" fn(pid: SceUID, modid: SceUID, flags: crate::ctypes::c_int, time: u64),
    >,
    pub exit: ::core::option::Option<
        unsafe extern "C" fn(pid: SceUID, flags: crate::ctypes::c_int, time: u64),
    >,
    #[doc = "by SceShell"]
    pub kill: ::core::option::Option<unsafe extern "C" fn(pid: SceUID)>,
    pub unk_10: ::core::option::Option<unsafe extern "C" fn(pid: SceUID, modid: SceUID, time: u64)>,
    pub unk_14: ::core::option::Option<unsafe extern "C" fn(pid: SceUID, modid: SceUID, time: u64)>,
    pub unk_18: ::core::option::Option<unsafe extern "C" fn(pid: SceUID, modid: SceUID, time: u64)>,
    #[doc = "called when process is created"]
    pub on_process_created: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_20: ::core::option::Option<unsafe extern "C" fn(pid: SceUID, modid: SceUID, time: u64)>,
    pub unk_24: ::core::option::Option<
        unsafe extern "C" fn(pid: SceUID, modid: SceUID, flags: crate::ctypes::c_int, time: u64),
    >,
}
#[doc = "Structure containing a threads register states."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SceThreadCpuRegisters {
    pub __bindgen_anon_1: SceThreadCpuRegisters__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceThreadCpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: SceThreadCpuRegisters__bindgen_ty_1__bindgen_ty_1,
    pub entry: [SceArmCpuRegisters; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceThreadCpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "Set of registers used for user mode."]
    pub user: SceArmCpuRegisters,
    #[doc = "Set of registers used for kernel mode."]
    pub kernel: SceArmCpuRegisters,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTouchData {
    #[doc = "Data timestamp"]
    pub timeStamp: SceUInt64,
    #[doc = "Unused"]
    pub status: SceUInt32,
    #[doc = "Number of touch reports"]
    pub reportNum: SceUInt32,
    #[doc = "Touch reports"]
    pub report: [SceTouchReport; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTouchPanelInfo {
    #[doc = "Min active area X position"]
    pub minAaX: SceInt16,
    #[doc = "Min active area Y position"]
    pub minAaY: SceInt16,
    #[doc = "Max active area X position"]
    pub maxAaX: SceInt16,
    #[doc = "Max active area Y position"]
    pub maxAaY: SceInt16,
    #[doc = "Min display X origin (top left)"]
    pub minDispX: SceInt16,
    #[doc = "Min display Y origin (top left)"]
    pub minDispY: SceInt16,
    #[doc = "Max display X origin (bottom right)"]
    pub maxDispX: SceInt16,
    #[doc = "Max display Y origin (bottom right)"]
    pub maxDispY: SceInt16,
    #[doc = "Min touch force value"]
    pub minForce: SceUInt8,
    #[doc = "Max touch force value"]
    pub maxForce: SceUInt8,
    #[doc = "Reserved"]
    pub reserved: [SceUInt8; 30usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTouchReport {
    #[doc = "Touch ID"]
    pub id: SceUInt8,
    #[doc = "Touch force"]
    pub force: SceUInt8,
    #[doc = "X position"]
    pub x: SceInt16,
    #[doc = "Y position"]
    pub y: SceInt16,
    #[doc = "Reserved"]
    pub reserved: [SceUInt8; 8usize],
    #[doc = "Information of this touch"]
    pub info: SceUInt16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTriggerUtilEventParamDaily {
    pub ver: SceUInt32,
    pub extraParam1: SceInt16,
    pub extraParam2: SceInt16,
    pub triggerTime: SceInt32,
    pub repeatDays: SceUInt16,
    pub reserved: [SceChar8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTriggerUtilEventParamOneTime {
    pub ver: SceUInt32,
    pub triggerTime: SceRtcTick,
    pub extraParam1: SceUInt8,
    pub extraParam2: SceUInt8,
    pub reserved: [SceChar8; 68usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTriggerUtilSystemAppInfo {
    pub name: [SceWChar16; 256usize],
    pub iconPath: [SceChar8; 1024usize],
    pub reserved: [crate::ctypes::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceTriggerUtilUserAppInfo {
    pub name: [SceWChar16; 52usize],
    pub iconPath: [SceChar8; 1024usize],
    pub unk: crate::ctypes::c_short,
}
#[doc = "USB configuration descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdConfigDescriptor {
    pub bLength: crate::ctypes::c_uchar,
    pub bDescriptorType: crate::ctypes::c_uchar,
    pub wTotalLength: crate::ctypes::c_ushort,
    pub bNumInterfaces: crate::ctypes::c_uchar,
    pub bConfigurationValue: crate::ctypes::c_uchar,
    pub iConfiguration: crate::ctypes::c_uchar,
    pub bmAttributes: crate::ctypes::c_uchar,
    pub bMaxPower: crate::ctypes::c_uchar,
    pub settings: *mut SceUdcdInterfaceSettings,
    #[doc = "Extra descriptors"]
    pub extra: *mut crate::ctypes::c_uchar,
    pub extraLength: crate::ctypes::c_int,
}
#[doc = "USB driver configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdConfiguration {
    #[doc = "Pointer to the configuration descriptors"]
    pub configDescriptors: *mut SceUdcdConfigDescriptor,
    #[doc = "USB driver interface settings"]
    pub settings: *mut SceUdcdInterfaceSettings,
    #[doc = "Pointer to the first interface descriptor"]
    pub interfaceDescriptors: *mut SceUdcdInterfaceDescriptor,
    #[doc = "Pointer to the first endpoint descriptor"]
    pub endpointDescriptors: *mut SceUdcdEndpointDescriptor,
}
#[doc = "USB device descriptor"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDeviceDescriptor {
    pub bLength: crate::ctypes::c_uchar,
    pub bDescriptorType: crate::ctypes::c_uchar,
    pub bcdUSB: crate::ctypes::c_ushort,
    pub bDeviceClass: crate::ctypes::c_uchar,
    pub bDeviceSubClass: crate::ctypes::c_uchar,
    pub bDeviceProtocol: crate::ctypes::c_uchar,
    pub bMaxPacketSize0: crate::ctypes::c_uchar,
    pub idVendor: crate::ctypes::c_ushort,
    pub idProduct: crate::ctypes::c_ushort,
    pub bcdDevice: crate::ctypes::c_ushort,
    pub iManufacturer: crate::ctypes::c_uchar,
    pub iProduct: crate::ctypes::c_uchar,
    pub iSerialNumber: crate::ctypes::c_uchar,
    pub bNumConfigurations: crate::ctypes::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDeviceInfo {
    pub info: [crate::ctypes::c_uchar; 64usize],
}
#[doc = "USB device qualifier descriptor"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDeviceQualifierDescriptor {
    pub bLength: crate::ctypes::c_uchar,
    pub bDescriptorType: crate::ctypes::c_uchar,
    pub bcdUSB: crate::ctypes::c_ushort,
    pub bDeviceClass: crate::ctypes::c_uchar,
    pub bDeviceSubClass: crate::ctypes::c_uchar,
    pub bDeviceProtocol: crate::ctypes::c_uchar,
    pub bMaxPacketSize0: crate::ctypes::c_uchar,
    pub bNumConfigurations: crate::ctypes::c_uchar,
    pub bReserved: crate::ctypes::c_uchar,
}
#[doc = "USB device request"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDeviceRequest {
    #[doc = "Pointer to the endpoint to queue request on"]
    pub endpoint: *mut SceUdcdEndpoint,
    #[doc = "Pointer to the data buffer to use in the request"]
    pub data: *mut crate::ctypes::c_void,
    #[doc = "Request attributes (See ::SceUdcdDeviceRequestAttr)"]
    pub attributes: crate::ctypes::c_uint,
    #[doc = "Size of the data buffer"]
    pub size: crate::ctypes::c_int,
    #[doc = "Is a control request?"]
    pub isControlRequest: crate::ctypes::c_int,
    #[doc = "Pointer to the function to call on completion"]
    pub onComplete: ::core::option::Option<unsafe extern "C" fn(req: *mut SceUdcdDeviceRequest)>,
    #[doc = "Number of transmitted bytes"]
    pub transmitted: crate::ctypes::c_int,
    #[doc = "Return code of the request (See ::SceUdcdRetcode)"]
    pub returnCode: crate::ctypes::c_int,
    #[doc = "Link pointer to next request used by the driver, set it to NULL"]
    pub next: *mut SceUdcdDeviceRequest,
    #[doc = "An unused value (maybe an argument)"]
    pub unused: *mut crate::ctypes::c_void,
    #[doc = "Physical address"]
    pub physicalAddress: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDeviceState {
    pub unk_00: crate::ctypes::c_int,
    pub state: crate::ctypes::c_int,
    pub cable: crate::ctypes::c_int,
    pub connection: crate::ctypes::c_int,
    pub use_usb_charging: crate::ctypes::c_int,
    pub unk_14: crate::ctypes::c_int,
}
#[doc = "USB driver structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDriver {
    #[doc = "Name of the USB driver"]
    pub driverName: *const crate::ctypes::c_char,
    #[doc = "Number of endpoints in this driver (including default control)"]
    pub numEndpoints: crate::ctypes::c_int,
    #[doc = "List of endpoint structures (used when calling other functions)"]
    pub endpoints: *mut SceUdcdEndpoint,
    #[doc = "Interface list"]
    pub interface: *mut SceUdcdInterface,
    #[doc = "Pointer to hi-speed device descriptor"]
    pub descriptor_hi: *mut SceUdcdDeviceDescriptor,
    #[doc = "Pointer to hi-speed device configuration"]
    pub configuration_hi: *mut SceUdcdConfiguration,
    #[doc = "Pointer to full-speed device descriptor"]
    pub descriptor: *mut SceUdcdDeviceDescriptor,
    #[doc = "Pointer to full-speed device configuration"]
    pub configuration: *mut SceUdcdConfiguration,
    #[doc = "Default string descriptors"]
    pub stringDescriptors: *mut SceUdcdStringDescriptor,
    #[doc = "Product string descriptor (iProduct has to be 2)"]
    pub stringDescriptorProduct: *mut SceUdcdStringDescriptor,
    #[doc = "Serial string descriptor (iSerial has to be 3)"]
    pub stringDescriptorSerial: *mut SceUdcdStringDescriptor,
    #[doc = "Received a control request"]
    pub processRequest: ::core::option::Option<
        unsafe extern "C" fn(
            recipient: crate::ctypes::c_int,
            arg: crate::ctypes::c_int,
            req: *mut SceUdcdEP0DeviceRequest,
            user_data: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    #[doc = "Change alternate setting"]
    pub changeSetting: ::core::option::Option<
        unsafe extern "C" fn(
            interfaceNumber: crate::ctypes::c_int,
            alternateSetting: crate::ctypes::c_int,
            bus: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    #[doc = "Configuration set (attach) function"]
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(
            usb_version: crate::ctypes::c_int,
            user_data: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    #[doc = "Configuration unset (detach) function"]
    pub detach: ::core::option::Option<unsafe extern "C" fn(user_data: *mut crate::ctypes::c_void)>,
    #[doc = "Configure the device"]
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(
            usb_version: crate::ctypes::c_int,
            desc_count: crate::ctypes::c_int,
            settings: *mut SceUdcdInterfaceSettings,
            user_data: *mut crate::ctypes::c_void,
        ),
    >,
    #[doc = "Function called when the driver is started"]
    pub start: ::core::option::Option<
        unsafe extern "C" fn(
            size: crate::ctypes::c_int,
            args: *mut crate::ctypes::c_void,
            user_data: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    #[doc = "Function called when the driver is stopped"]
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(
            size: crate::ctypes::c_int,
            args: *mut crate::ctypes::c_void,
            user_data: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    #[doc = "User data"]
    pub user_data: *mut crate::ctypes::c_void,
    #[doc = "USB bus"]
    pub bus: crate::ctypes::c_int,
    #[doc = "Link to next USB driver in the chain, set to NULL"]
    pub link: *mut SceUdcdDriver,
}
#[doc = "USB driver name"]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdDriverName {
    pub size: crate::ctypes::c_int,
    pub name: [crate::ctypes::c_char; 32usize],
    pub flags: crate::ctypes::c_int,
}
#[doc = "USB driver endpoint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdEndpoint {
    #[doc = "USB_ENDPOINT_IN / USB_ENDPOINT_OUT"]
    pub direction: crate::ctypes::c_int,
    #[doc = "Driver Endpoint number (must be filled in sequentially)"]
    pub driverEndpointNumber: crate::ctypes::c_int,
    #[doc = "Endpoint number (Filled in by the bus driver)"]
    pub endpointNumber: crate::ctypes::c_int,
    #[doc = "Number of transmitted bytes"]
    pub transmittedBytes: crate::ctypes::c_int,
}
#[doc = "USB endpoint descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdEndpointDescriptor {
    pub bLength: crate::ctypes::c_uchar,
    pub bDescriptorType: crate::ctypes::c_uchar,
    pub bEndpointAddress: crate::ctypes::c_uchar,
    pub bmAttributes: crate::ctypes::c_uchar,
    pub wMaxPacketSize: crate::ctypes::c_ushort,
    pub bInterval: crate::ctypes::c_uchar,
    #[doc = "Extra descriptors"]
    pub extra: *mut crate::ctypes::c_uchar,
    pub extraLength: crate::ctypes::c_int,
}
#[doc = "USB EP0 Device Request"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdEP0DeviceRequest {
    pub bmRequestType: crate::ctypes::c_uchar,
    pub bRequest: crate::ctypes::c_uchar,
    pub wValue: crate::ctypes::c_ushort,
    pub wIndex: crate::ctypes::c_ushort,
    pub wLength: crate::ctypes::c_ushort,
}
#[doc = "USB driver interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdInterface {
    #[doc = "Expectant interface number (interface number or -1)"]
    pub expectNumber: crate::ctypes::c_int,
    #[doc = "End interface"]
    pub interfaceNumber: crate::ctypes::c_int,
    #[doc = "Number of interfaces"]
    pub numInterfaces: crate::ctypes::c_int,
}
#[doc = "USB Interface descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdInterfaceDescriptor {
    pub bLength: crate::ctypes::c_uchar,
    pub bDescriptorType: crate::ctypes::c_uchar,
    pub bInterfaceNumber: crate::ctypes::c_uchar,
    pub bAlternateSetting: crate::ctypes::c_uchar,
    pub bNumEndpoints: crate::ctypes::c_uchar,
    pub bInterfaceClass: crate::ctypes::c_uchar,
    pub bInterfaceSubClass: crate::ctypes::c_uchar,
    pub bInterfaceProtocol: crate::ctypes::c_uchar,
    pub iInterface: crate::ctypes::c_uchar,
    pub endpoints: *mut SceUdcdEndpointDescriptor,
    #[doc = "Extra descriptors"]
    pub extra: *mut crate::ctypes::c_uchar,
    pub extraLength: crate::ctypes::c_int,
}
#[doc = "USB driver interfaces structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdInterfaceSettings {
    #[doc = "Pointers to the individual interface descriptors"]
    pub descriptors: *mut SceUdcdInterfaceDescriptor,
    pub alternateSetting: crate::ctypes::c_uint,
    #[doc = "Number of interface descriptors"]
    pub numDescriptors: crate::ctypes::c_uint,
}
#[doc = "USB string descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdStringDescriptor {
    pub bLength: crate::ctypes::c_uchar,
    pub bDescriptorType: crate::ctypes::c_uchar,
    pub bString: [crate::ctypes::c_short; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUdcdWaitParam {
    pub unk_00: crate::ctypes::c_int,
    pub status: crate::ctypes::c_int,
    pub unk_08: crate::ctypes::c_int,
    pub unk_0C: crate::ctypes::c_int,
    pub unk_10: crate::ctypes::c_int,
    pub driverName: *const crate::ctypes::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUIDSysrootObject {
    pub object: *mut crate::ctypes::c_void,
    pub sce_class: *mut SceClass,
    pub size: SceSize,
    pub magic1: SceUInt32,
    pub cpu_intr: crate::ctypes::c_int,
    pub boot_alloc_memory_size: SceSize,
    pub boot_alloc_memory: *mut crate::ctypes::c_void,
    pub unk_0x1C: crate::ctypes::c_int,
    pub unk_0x20: *mut crate::ctypes::c_void,
    pub boot_flags: SceUInt32,
    pub status: SceUInt32,
    pub corelock_context: SceCorelockContext,
    pub unk_0x34: crate::ctypes::c_int,
    pub unk_0x38: crate::ctypes::c_int,
    pub unk_0x3C: *mut crate::ctypes::c_void,
    pub unk_0x40: *mut crate::ctypes::c_void,
    pub unk_0x44: *mut crate::ctypes::c_void,
    pub unk_0x48: *mut crate::ctypes::c_void,
    pub unk_0x4C: *mut crate::ctypes::c_void,
    pub unk_0x50: *mut crate::ctypes::c_void,
    pub unk_0x54: crate::ctypes::c_int,
    pub unk_0x58: *mut crate::ctypes::c_void,
    pub unk_0x5C: crate::ctypes::c_int,
    pub unk_0x60: crate::ctypes::c_int,
    pub unk_0x64: crate::ctypes::c_int,
    pub unk_0x68: crate::ctypes::c_int,
    pub kbl_param: *mut SceKblParam,
    pub boot_args: *mut SceKernelBootArgs,
    pub soc_revision: SceUInt32,
    pub unk_0x78: SceUInt32,
    pub soc_revision2: SceUInt32,
    pub model_info: SceUInt32,
    pub model_capability: SceUInt32,
    pub longtime5base: *mut crate::ctypes::c_void,
    pub cpu_intr_for_init_callback: crate::ctypes::c_int,
    pub init_callback_registable_base_number: SceUInt32,
    pub init_callback_slot: [[SceUIDSysrootObject__bindgen_ty_1; 8usize]; 9usize],
    pub funcThreadMgrStartAfterProcess:
        ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub funcIofilemgrStart: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub unk_0x2DC: *mut crate::ctypes::c_void,
    pub unk_0x2E0: *mut crate::ctypes::c_void,
    pub sysroot_names: [*mut crate::ctypes::c_char; 9usize],
    pub this_object_uid: SceUID,
    pub unk_0x30C: *mut crate::ctypes::c_void,
    pub unk_0x310: *mut crate::ctypes::c_void,
    pub unk_0x314: *mut crate::ctypes::c_void,
    pub VBAR: *mut crate::ctypes::c_void,
    pub MVBAR: *mut crate::ctypes::c_void,
    pub unk_0x320: *mut crate::ctypes::c_void,
    pub unk_func_0x324: *mut *mut crate::ctypes::c_void,
    pub funcGetThreadId: ::core::option::Option<unsafe extern "C" fn() -> SceUID>,
    pub funcThreadFunction3: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub funcGetProcessId: ::core::option::Option<unsafe extern "C" fn() -> SceUID>,
    pub funcThreadFunction4: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub funcThreadFunction5: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub funcThreadFunction6: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub funcThreadFunction7: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcThreadFunction8: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub funcThreadFunction9: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub funcThreadFunction10: ::core::option::Option<
        unsafe extern "C" fn(a1: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub modulemgr_handlers: *mut SceSysrootModulemgrHandlers,
    pub unk_0x354: crate::ctypes::c_int,
    pub processmgr_callbacks1: *mut SceSysrootForKernel_D29BCA77_struct,
    pub processmgr_callbacks2: *mut SceSysrootForDriver_733C243E_struct,
    pub unk_func_0x360: *mut crate::ctypes::c_void,
    pub funcGetBusError: ::core::option::Option<
        unsafe extern "C" fn(dst: *mut crate::ctypes::c_void, len: u32) -> crate::ctypes::c_int,
    >,
    pub funcAppMgrFunction1: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
            a3: crate::ctypes::c_int,
            a4: crate::ctypes::c_int,
            a5: crate::ctypes::c_int,
            a6: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub funcGetShellPid: ::core::option::Option<unsafe extern "C" fn() -> SceUID>,
    pub unk_func_0x370: *mut crate::ctypes::c_void,
    pub unk_func_0x374: *mut crate::ctypes::c_void,
    pub unk_func_0x378: *mut crate::ctypes::c_void,
    pub unk_0x37C: crate::ctypes::c_int,
    pub unk_func_0x380: *mut crate::ctypes::c_void,
    pub unk_func_0x384: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub unk_func_0x388: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub unk_func_0x38C: *mut crate::ctypes::c_void,
    pub unk_func_0x390: *mut crate::ctypes::c_void,
    pub funcHasNpTestFlag: ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>,
    pub unk_func_0x398: *mut crate::ctypes::c_void,
    pub funcLedSetMode: ::core::option::Option<
        unsafe extern "C" fn(
            led: crate::ctypes::c_int,
            mode: crate::ctypes::c_int,
            led_configuration: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    pub cached_sm_info_ranges: *mut SceKernelVARange,
    pub funcGetFunctionNameByNID: ::core::option::Option<
        unsafe extern "C" fn(
            funcnid: SceNID,
            name: *mut *const crate::ctypes::c_char,
        ) -> crate::ctypes::c_int,
    >,
    pub unk_0x3A8: *mut crate::ctypes::c_void,
    pub unk_0x3AC: *mut crate::ctypes::c_void,
    pub unk_struct_0x3B0: *mut crate::ctypes::c_void,
    pub unk_0x3B4: *mut crate::ctypes::c_void,
    pub unk_0x3B8: *mut crate::ctypes::c_void,
    pub unk_0x3BC: *mut crate::ctypes::c_void,
    pub unk_0x3C0: *mut crate::ctypes::c_void,
    pub process_handler: *mut SceSysrootProcessHandler,
    pub dbgp_handler: *mut SceSysrootDbgpHandler,
    pub unk_func_0x3CC: *mut crate::ctypes::c_void,
    pub unk_func_0x3D0: *mut crate::ctypes::c_void,
    pub unk_func_0x3D4: *mut crate::ctypes::c_void,
    pub unk_func_0x3D8: *mut crate::ctypes::c_void,
    pub unk_func_0x3DC: *mut crate::ctypes::c_void,
    pub unk_func_0x3E0: *mut crate::ctypes::c_void,
    pub funcAppMgrFunction3: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub funcAppMgrFunction4: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            a2: crate::ctypes::c_int,
        ) -> crate::ctypes::c_int,
    >,
    pub funcAppMgrFunction5: ::core::option::Option<
        unsafe extern "C" fn(a1: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub unk_func_0x3F0: *mut crate::ctypes::c_void,
    pub unk_struct_0x3F4: *mut crate::ctypes::c_void,
    pub unk_struct_0x3F8: *mut crate::ctypes::c_void,
    pub unk_struct_0x3FC: *mut crate::ctypes::c_void,
    pub unk_data_0x400: *mut crate::ctypes::c_void,
    pub unk_func_0x404: *mut crate::ctypes::c_void,
    pub unk_func_0x408: *mut crate::ctypes::c_void,
    pub unk_func_0x40C: *mut crate::ctypes::c_void,
    pub unk_func_0x410: *mut crate::ctypes::c_void,
    pub unk_func_0x414: *mut crate::ctypes::c_void,
    pub magic2: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUIDSysrootObject__bindgen_ty_1 {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(
            a1: crate::ctypes::c_int,
            args: *mut crate::ctypes::c_void,
        ) -> crate::ctypes::c_int,
    >,
    pub args: *mut crate::ctypes::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbAudioInDeviceInfo {
    pub vendor: u16,
    pub product: u16,
    pub _reserved: [SceUInt32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbAudioInDeviceListItem {
    pub device_id: SceUInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdAttachCompositeParam {
    pub driver_id: u32,
    pub bus: u32,
    pub device: u32,
    pub unk3: u32,
    pub unk4: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdCompositeDriver {
    pub name: *const crate::ctypes::c_char,
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(
            device_id: crate::ctypes::c_int,
            desc: *mut SceUsbdEndpointDescriptor,
        ) -> crate::ctypes::c_int,
    >,
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(device_id: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub detach: ::core::option::Option<
        unsafe extern "C" fn(device_id: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdConfigurationDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub MaxPower: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdDeviceAddress {
    pub unk0: crate::ctypes::c_uint,
    pub unk1: crate::ctypes::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdDeviceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUSB: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubclass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize0: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdDeviceInfo {
    pub port: crate::ctypes::c_uint,
    pub device_num: crate::ctypes::c_uint,
    pub unk3: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdDevicePipe {
    pub device_id: crate::ctypes::c_uint,
    pub unk1: crate::ctypes::c_uint,
    pub unk2: crate::ctypes::c_uint,
    pub unk3: crate::ctypes::c_uint,
    pub unk4: crate::ctypes::c_uint,
    pub unk5: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdDeviceRequest {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdDriver {
    pub name: *const crate::ctypes::c_char,
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(device_id: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(device_id: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
    pub detach: ::core::option::Option<
        unsafe extern "C" fn(device_id: crate::ctypes::c_int) -> crate::ctypes::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdEndpointDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct SceUsbdHidDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdHID0: u8,
    pub bcdHID1: u8,
    pub bCountryCode: u8,
    pub bNumDescriptors: u8,
    pub SubDescriptorInfo: __IncompleteArrayField<SceUsbdHidSubDescriptorInfo>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdHidSubDescriptorInfo {
    pub bDescriptorType: u8,
    pub wDescriptorLength0: u8,
    pub wDescriptorLength1: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdInterfaceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bInterfaceNumber: u8,
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubclass: u8,
    pub bInterfaceProtocol: u8,
    pub iInterface: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdIsochTransfer {
    pub unk0: crate::ctypes::c_uint,
    pub unk1: crate::ctypes::c_uint,
    pub unk2: crate::ctypes::c_uint,
    pub unk3: crate::ctypes::c_uint,
    pub unk4: crate::ctypes::c_uint,
    pub unk5: crate::ctypes::c_uint,
    pub unk6: crate::ctypes::c_uint,
    pub unk7: crate::ctypes::c_uint,
    pub unk8: crate::ctypes::c_uint,
    pub unk9: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdIsochTransferStatus {
    pub unk0: u32,
    pub unk1: u32,
    pub unk2: *mut usize,
    pub unk3: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdReceiveEvent {
    pub unk0: crate::ctypes::c_uint,
    pub unk1: crate::ctypes::c_uint,
    pub unk2: crate::ctypes::c_uint,
    pub unk3: crate::ctypes::c_uint,
    pub unk4: crate::ctypes::c_uint,
    pub unk5: crate::ctypes::c_uint,
    pub transfer_id: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct SceUsbdStringDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bString: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdTransferData {
    pub pipe: crate::ctypes::c_uint,
    pub data: *const crate::ctypes::c_void,
    pub data_size: crate::ctypes::c_uint,
    pub transferred: *mut crate::ctypes::c_void,
    pub timeout: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceUsbdTransferStatus {
    pub unk0: u32,
    pub unk1: u32,
    pub unk2: u32,
    pub unk3: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SceVideodecQueryInitInfo {
    pub reserved: [u8; 32usize],
    pub hwAvc: SceVideodecQueryInitInfoHwAvcdec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceVideodecQueryInitInfoHwAvcdec {
    #[doc = "sizeof(SceVideodecQueryInitInfoHwAvcdec)"]
    pub size: u32,
    pub horizontal: u32,
    pub vertical: u32,
    #[doc = "Number of reference frames to use"]
    pub numOfRefFrames: u32,
    #[doc = "Must be set to 1"]
    pub numOfStreams: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceVideodecTimeStamp {
    pub upper: u32,
    pub lower: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SulphaNgsModuleQuery {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SulphaNgsRegistration {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VideoExportInputParam {
    #[doc = "Path of file to be exported"]
    pub path: [crate::ctypes::c_char; 1024usize],
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VideoExportOutputParam {
    #[doc = "Path of exported file"]
    pub path: [crate::ctypes::c_char; 1024usize],
    #[doc = "Reserved data"]
    pub reserved: [crate::ctypes::c_char; 8usize],
}
pub const BOOT_INTF_SUBCLASS: u32 = 1;
pub const BOOT_PROTOCOL: SceUdcdProtocol = 0;
pub const EHCI_CC_BABBLE: u32 = 48;
pub const EHCI_CC_DATABUF: u32 = 64;
pub const EHCI_CC_HALTED: u32 = 80;
pub const EHCI_CC_MISSED_MICRO_FRAME: u32 = 16;
pub const EHCI_CC_XACT: u32 = 32;
pub const HID_DESCRIPTOR_HID: SceUdcdHidDescriptor = 33;
pub const HID_DESCRIPTOR_REPORT: SceUdcdHidDescriptor = 34;
pub const HID_DESRIPTOR_PHY: SceUdcdHidDescriptor = 35;
pub const HID_INTF: u32 = 3;
pub const HID_PROTOCOL_KEYBOARD: SceUdcdHidProtocol = 1;
pub const HID_PROTOCOL_MOUSE: SceUdcdHidProtocol = 2;
pub const HID_PROTOCOL_NONE: SceUdcdHidProtocol = 0;
pub const HID_REQUEST_GET_IDLE: SceUdcdHidRequest = 2;
pub const HID_REQUEST_GET_PROTOCOL: SceUdcdHidRequest = 3;
pub const HID_REQUEST_GET_REPORT: SceUdcdHidRequest = 1;
pub const HID_REQUEST_SET_IDLE: SceUdcdHidRequest = 10;
pub const HID_REQUEST_SET_PROTOCOL: SceUdcdHidRequest = 11;
pub const HID_REQUEST_SET_REPORT: SceUdcdHidRequest = 9;
pub const OHCI_CC_BIT_STUFFING: u32 = 2;
pub const OHCI_CC_BUFFER_OVERRUN: u32 = 12;
pub const OHCI_CC_BUFFER_UNDERRUN: u32 = 13;
pub const OHCI_CC_CRC: u32 = 1;
pub const OHCI_CC_DATA_OVERRUN: u32 = 8;
pub const OHCI_CC_DATA_TOGGLE_MISMATCH: u32 = 3;
pub const OHCI_CC_DATA_UNDERRUN: u32 = 9;
pub const OHCI_CC_DEVICE_NOT_RESPONDING: u32 = 5;
pub const OHCI_CC_NO_ERROR: u32 = 0;
pub const OHCI_CC_NOT_ACCESSED1: u32 = 14;
pub const OHCI_CC_NOT_ACCESSED2: u32 = 15;
pub const OHCI_CC_PID_CHECK_FAILURE: u32 = 6;
pub const OHCI_CC_STALL: u32 = 4;
pub const OHCI_CC_UNEXPECTED_PID: u32 = 7;
pub const __PSP2FILEHASH__: u32 = 0;
pub const PSP2_SDK_VERSION: u32 = 56033297;
pub const RPT_PROTOCOL: SceUdcdProtocol = 1;
#[doc = "Application without physically contiguous memory access"]
pub const SCE_APPMGR_APPLICATION_MODE_A: SceAppMgrApplicationMode = 2;
#[doc = "Application with physically contiguous memory access"]
pub const SCE_APPMGR_APPLICATION_MODE_B: SceAppMgrApplicationMode = 3;
#[doc = "Application with physically contiguous memory and extra memory access"]
pub const SCE_APPMGR_APPLICATION_MODE_C: SceAppMgrApplicationMode = 4;
#[doc = "BGM port was occupied and could not be secured"]
pub const SCE_APPMGR_ERROR_BGM_PORT_BUSY: SceAppMgrErrorCode = 2155884544;
#[doc = "Busy"]
pub const SCE_APPMGR_ERROR_BUSY: SceAppMgrErrorCode = 2155880448;
#[doc = "Invalid param"]
pub const SCE_APPMGR_ERROR_INVALID: SceAppMgrErrorCode = 2155880474;
#[doc = "Invalid SELF path"]
pub const SCE_APPMGR_ERROR_INVALID_SELF_PATH: SceAppMgrErrorCode = 2155880478;
#[doc = "The process is not authorized to run this function"]
pub const SCE_APPMGR_ERROR_NOEXEC: SceAppMgrErrorCode = 2155880479;
#[doc = "NULL pointer"]
pub const SCE_APPMGR_ERROR_NULL_POINTER: SceAppMgrErrorCode = 2155880470;
#[doc = "Invalid state"]
pub const SCE_APPMGR_ERROR_STATE: SceAppMgrErrorCode = 2155880467;
#[doc = "argv is too long"]
pub const SCE_APPMGR_ERROR_TOO_LONG_ARGV: SceAppMgrErrorCode = 2155880477;
pub const SCE_APPMGR_INFOBAR_COLOR_BLACK: SceAppMgrInfoBarColor = 0;
pub const SCE_APPMGR_INFOBAR_COLOR_WHITE: SceAppMgrInfoBarColor = 1;
pub const SCE_APPMGR_INFOBAR_TRANSPARENCY_OPAQUE: SceAppMgrInfoBarTransparency = 0;
pub const SCE_APPMGR_INFOBAR_TRANSPARENCY_TRANSLUCENT: SceAppMgrInfoBarTransparency = 1;
pub const SCE_APPMGR_INFOBAR_VISIBILITY_INVISIBLE: SceAppMgrInfoBarVisibility = 0;
pub const SCE_APPMGR_INFOBAR_VISIBILITY_VISIBLE: SceAppMgrInfoBarVisibility = 1;
pub const SCE_APPMGR_MAX_APP_NAME_LENGTH: u32 = 31;
pub const SCE_APPMGR_SYSTEMEVENT_ON_NP_MESSAGE_ARRIVED: SceAppMgrSystemEventType = 268435461;
pub const SCE_APPMGR_SYSTEMEVENT_ON_RESUME: SceAppMgrSystemEventType = 268435459;
pub const SCE_APPMGR_SYSTEMEVENT_ON_STORE_PURCHASE: SceAppMgrSystemEventType = 268435460;
pub const SCE_APPMGR_SYSTEMEVENT_ON_STORE_REDEMPTION: SceAppMgrSystemEventType = 268435462;
pub const SCE_APPUTIL_ERROR_APPEVENT_PARSE_INVALID_DATA: SceAppUtilErrorCode = 2148533792;
pub const SCE_APPUTIL_ERROR_BUSY: SceAppUtilErrorCode = 2148533763;
pub const SCE_APPUTIL_ERROR_DRM_NO_ENTITLEMENT: SceAppUtilErrorCode = 2148533856;
pub const SCE_APPUTIL_ERROR_MOUNT_LIMIT_OVER: SceAppUtilErrorCode = 2148533894;
pub const SCE_APPUTIL_ERROR_MUSIC_DEVICE_NOT_FOUND: SceAppUtilErrorCode = 2148533893;
pub const SCE_APPUTIL_ERROR_NO_MEMORY: SceAppUtilErrorCode = 2148533762;
pub const SCE_APPUTIL_ERROR_NO_PERMISSION: SceAppUtilErrorCode = 2148533765;
pub const SCE_APPUTIL_ERROR_NOT_INITIALIZED: SceAppUtilErrorCode = 2148533761;
pub const SCE_APPUTIL_ERROR_NOT_MOUNTED: SceAppUtilErrorCode = 2148533764;
pub const SCE_APPUTIL_ERROR_PARAMETER: SceAppUtilErrorCode = 2148533760;
pub const SCE_APPUTIL_ERROR_PASSCODE_MISMATCH: SceAppUtilErrorCode = 2148533766;
pub const SCE_APPUTIL_ERROR_PHOTO_DEVICE_NOT_FOUND: SceAppUtilErrorCode = 2148533888;
pub const SCE_APPUTIL_ERROR_SAVEDATA_NO_SPACE_FS: SceAppUtilErrorCode = 2148533827;
pub const SCE_APPUTIL_ERROR_SAVEDATA_NO_SPACE_QUOTA: SceAppUtilErrorCode = 2148533826;
pub const SCE_APPUTIL_ERROR_SAVEDATA_SLOT_EXISTS: SceAppUtilErrorCode = 2148533824;
pub const SCE_APPUTIL_ERROR_SAVEDATA_SLOT_NOT_FOUND: SceAppUtilErrorCode = 2148533825;
pub const SCE_APPUTIL_ERROR_STACKSIZE_TOO_SHORT: SceAppUtilErrorCode = 2148533920;
pub const SCE_APPUTIL_SAVEDATA_DATA_REMOVE_MODE_DEFAULT: SceAppUtilSaveDataRemoveMode = 0;
pub const SCE_APPUTIL_SAVEDATA_DATA_REMOVE_MODE_NO_SLOT: SceAppUtilSaveDataRemoveMode = 1;
pub const SCE_APPUTIL_SAVEDATA_DATA_SAVE_MODE_DIRECTORY: SceAppUtilSaveDataSaveMode = 2;
pub const SCE_APPUTIL_SAVEDATA_DATA_SAVE_MODE_FILE: SceAppUtilSaveDataSaveMode = 0;
pub const SCE_ATRAC_ALIGNMENT_SIZE: u32 = 256;
pub const SCE_ATRAC_AT9_MAX_CH_IN_DECODER: u32 = 2;
pub const SCE_ATRAC_AT9_MAX_FRAME_SAMPLES: u32 = 256;
pub const SCE_ATRAC_AT9_MAX_OUTPUT_FRAMES: u32 = 8;
pub const SCE_ATRAC_AT9_MAX_TOTAL_CH: u32 = 16;
pub const SCE_ATRAC_AT9_MIN_LOOP_SAMPLES: u32 = 3072;
pub const SCE_ATRAC_DECODER_STATUS_ALL_DATA_IS_ON_MEMORY: SceAtracDecoderStatus = 2;
pub const SCE_ATRAC_DECODER_STATUS_ALL_DATA_WAS_DECODED: SceAtracDecoderStatus = 1;
pub const SCE_ATRAC_DECODER_STATUS_LOOP_PART_IS_ON_MEMORY: SceAtracDecoderStatus = 8;
pub const SCE_ATRAC_DECODER_STATUS_NONLOOP_PART_IS_ON_MEMORY: SceAtracDecoderStatus = 4;
pub const SCE_ATRAC_ERROR_ADDED_DATA_IS_TOO_BIG: SceAtracErrorCode = 2153971731;
pub const SCE_ATRAC_ERROR_ALL_DATA_WAS_DECODED: SceAtracErrorCode = 2153971729;
pub const SCE_ATRAC_ERROR_ALREADY_CREATED: SceAtracErrorCode = 2153971718;
pub const SCE_ATRAC_ERROR_DATA_SHORTAGE_IN_BUFFER: SceAtracErrorCode = 2153971728;
pub const SCE_ATRAC_ERROR_INVALID_ALIGNMENT: SceAtracErrorCode = 2153971717;
pub const SCE_ATRAC_ERROR_INVALID_DATA: SceAtracErrorCode = 2153971722;
pub const SCE_ATRAC_ERROR_INVALID_HANDLE: SceAtracErrorCode = 2153971724;
pub const SCE_ATRAC_ERROR_INVALID_LOOP_NUM: SceAtracErrorCode = 2153971760;
pub const SCE_ATRAC_ERROR_INVALID_LOOP_STATUS: SceAtracErrorCode = 2153971735;
pub const SCE_ATRAC_ERROR_INVALID_MAX_OUTPUT_SAMPLES: SceAtracErrorCode = 2153971730;
pub const SCE_ATRAC_ERROR_INVALID_POINTER: SceAtracErrorCode = 2153971712;
pub const SCE_ATRAC_ERROR_INVALID_SAMPLE: SceAtracErrorCode = 2153971733;
pub const SCE_ATRAC_ERROR_INVALID_SIZE: SceAtracErrorCode = 2153971713;
pub const SCE_ATRAC_ERROR_INVALID_TOTAL_CH: SceAtracErrorCode = 2153971716;
pub const SCE_ATRAC_ERROR_INVALID_TYPE: SceAtracErrorCode = 2153971715;
pub const SCE_ATRAC_ERROR_INVALID_WORD_LENGTH: SceAtracErrorCode = 2153971714;
pub const SCE_ATRAC_ERROR_MAIN_BUFFER_SIZE_IS_TOO_SMALL: SceAtracErrorCode = 2153971726;
pub const SCE_ATRAC_ERROR_NEED_SUB_BUFFER: SceAtracErrorCode = 2153971732;
pub const SCE_ATRAC_ERROR_NO_NEED_SUB_BUFFER: SceAtracErrorCode = 2153971734;
pub const SCE_ATRAC_ERROR_NOT_CREATED: SceAtracErrorCode = 2153971719;
pub const SCE_ATRAC_ERROR_READ_SIZE_IS_TOO_SMALL: SceAtracErrorCode = 2153971723;
pub const SCE_ATRAC_ERROR_READ_SIZE_OVER_BUFFER: SceAtracErrorCode = 2153971725;
pub const SCE_ATRAC_ERROR_REMAIN_VALID_HANDLE: SceAtracErrorCode = 2153971736;
pub const SCE_ATRAC_ERROR_SHORTAGE_OF_CH: SceAtracErrorCode = 2153971720;
pub const SCE_ATRAC_ERROR_SUB_BUFFER_SIZE_IS_TOO_SMALL: SceAtracErrorCode = 2153971727;
pub const SCE_ATRAC_ERROR_UNSUPPORTED_DATA: SceAtracErrorCode = 2153971721;
pub const SCE_ATRAC_INFINITE_LOOP_NUM: i32 = -1;
pub const SCE_ATRAC_INFINITE_SAMPLES: i32 = -1;
pub const SCE_ATRAC_LOOP_STATUS_NON_RESETABLE_PART: SceAtracLoopStatus = 0;
pub const SCE_ATRAC_LOOP_STATUS_RESETABLE_PART: SceAtracLoopStatus = 1;
pub const SCE_ATRAC_MAX_OUTPUT_SAMPLES: u32 = 2048;
pub const SCE_ATRAC_TYPE_AT9: u32 = 8195;
pub const SCE_ATRAC_WORD_LENGTH_16BITS: u32 = 16;
pub const SCE_AUDIO_ALC_MODE1: SceAudioOutAlcMode = 1;
pub const SCE_AUDIO_ALC_MODE_MAX: SceAudioOutAlcMode = 2;
pub const SCE_AUDIO_ALC_OFF: SceAudioOutAlcMode = 0;
pub const SCE_AUDIODEC_AAC_ERROR_INVALID_CH: SceAudiodecErrorCode = 2155819008;
pub const SCE_AUDIODEC_AAC_EXTRA_ACCESS_SIZE: u32 = 0;
pub const SCE_AUDIODEC_AAC_MAX_CH_IN_DECODER: u32 = 2;
pub const SCE_AUDIODEC_AAC_MAX_ES_SIZE: u32 = 1536;
pub const SCE_AUDIODEC_AAC_MAX_NFRAMES: u32 = 1;
pub const SCE_AUDIODEC_AAC_MAX_NSTREAMS: u32 = 6;
pub const SCE_AUDIODEC_AAC_MAX_SAMPLES: u32 = 2048;
pub const SCE_AUDIODEC_AAC_MAX_STREAMS: u32 = 8;
pub const SCE_AUDIODEC_ALIGNMENT_SIZE: u32 = 256;
pub const SCE_AUDIODEC_AT9_ERROR_INVALID_CONFIG: SceAudiodecErrorCode = 2155814912;
pub const SCE_AUDIODEC_AT9_EXTRA_ACCESS_SIZE: u32 = 0;
pub const SCE_AUDIODEC_AT9_MAX_CH_IN_DECODER: u32 = 2;
pub const SCE_AUDIODEC_AT9_MAX_CH_IN_LIBRARY: u32 = 16;
pub const SCE_AUDIODEC_AT9_MAX_ES_SIZE: u32 = 1024;
pub const SCE_AUDIODEC_AT9_MAX_NFRAMES: u32 = 8;
pub const SCE_AUDIODEC_AT9_MAX_NSTREAMS: u32 = 6;
pub const SCE_AUDIODEC_AT9_MAX_SAMPLES: u32 = 256;
pub const SCE_AUDIODEC_CELP_BIT_RATE_10700BPS: SceAudiodecCelpBitrate = 10700;
pub const SCE_AUDIODEC_CELP_BIT_RATE_11800BPS: SceAudiodecCelpBitrate = 11800;
pub const SCE_AUDIODEC_CELP_BIT_RATE_12200BPS: SceAudiodecCelpBitrate = 12200;
pub const SCE_AUDIODEC_CELP_BIT_RATE_3850BPS: SceAudiodecCelpBitrate = 3850;
pub const SCE_AUDIODEC_CELP_BIT_RATE_4650BPS: SceAudiodecCelpBitrate = 4650;
pub const SCE_AUDIODEC_CELP_BIT_RATE_5700BPS: SceAudiodecCelpBitrate = 5700;
pub const SCE_AUDIODEC_CELP_BIT_RATE_6600BPS: SceAudiodecCelpBitrate = 6600;
pub const SCE_AUDIODEC_CELP_BIT_RATE_7300BPS: SceAudiodecCelpBitrate = 7300;
pub const SCE_AUDIODEC_CELP_BIT_RATE_8700BPS: SceAudiodecCelpBitrate = 8700;
pub const SCE_AUDIODEC_CELP_BIT_RATE_9900BPS: SceAudiodecCelpBitrate = 9900;
pub const SCE_AUDIODEC_CELP_ERROR_INVALID_CONFIG: SceAudiodecErrorCode = 2155821056;
pub const SCE_AUDIODEC_CELP_EXTRA_ACCESS_SIZE: u32 = 0;
pub const SCE_AUDIODEC_CELP_MAX_CH_IN_DECODER: u32 = 1;
pub const SCE_AUDIODEC_CELP_MAX_ES_SIZE: u32 = 24;
pub const SCE_AUDIODEC_CELP_MAX_NFRAMES: u32 = 1;
pub const SCE_AUDIODEC_CELP_MAX_NSTREAMS: u32 = 7;
pub const SCE_AUDIODEC_CELP_MAX_SAMPLES: u32 = 320;
pub const SCE_AUDIODEC_CELP_MAX_STREAMS: u32 = 8;
pub const SCE_AUDIODEC_CELP_MPE: u32 = 0;
pub const SCE_AUDIODEC_CELP_SAMPLING_RATE_8KHZ: u32 = 8000;
pub const SCE_AUDIODEC_ERROR_A_HANDLE_IN_USE: SceAudiodecErrorCode = 2155806726;
pub const SCE_AUDIODEC_ERROR_ALL_HANDLES_IN_USE: SceAudiodecErrorCode = 2155806727;
pub const SCE_AUDIODEC_ERROR_ALREADY_INITIALIZED: SceAudiodecErrorCode = 2155806723;
pub const SCE_AUDIODEC_ERROR_API_FAIL: SceAudiodecErrorCode = 2155806720;
pub const SCE_AUDIODEC_ERROR_BUSY: SceAudiodecErrorCode = 2155806739;
pub const SCE_AUDIODEC_ERROR_CH_SHORTAGE: SceAudiodecErrorCode = 2155806731;
pub const SCE_AUDIODEC_ERROR_DIFFERENT_TYPES: SceAudiodecErrorCode = 2155806737;
pub const SCE_AUDIODEC_ERROR_INVALID_HANDLE: SceAudiodecErrorCode = 2155806729;
pub const SCE_AUDIODEC_ERROR_INVALID_INIT_PARAM: SceAudiodecErrorCode = 2155806722;
pub const SCE_AUDIODEC_ERROR_INVALID_NFRAMES: SceAudiodecErrorCode = 2155806735;
pub const SCE_AUDIODEC_ERROR_INVALID_NSTREAMS: SceAudiodecErrorCode = 2155806736;
pub const SCE_AUDIODEC_ERROR_INVALID_PTR: SceAudiodecErrorCode = 2155806728;
pub const SCE_AUDIODEC_ERROR_INVALID_SIZE: SceAudiodecErrorCode = 2155806733;
pub const SCE_AUDIODEC_ERROR_INVALID_TYPE: SceAudiodecErrorCode = 2155806721;
pub const SCE_AUDIODEC_ERROR_INVALID_WORD_LENGTH: SceAudiodecErrorCode = 2155806732;
pub const SCE_AUDIODEC_ERROR_NOT_HANDLE_IN_USE: SceAudiodecErrorCode = 2155806730;
pub const SCE_AUDIODEC_ERROR_NOT_INITIALIZED: SceAudiodecErrorCode = 2155806725;
pub const SCE_AUDIODEC_ERROR_OUT_OF_MEMORY: SceAudiodecErrorCode = 2155806724;
pub const SCE_AUDIODEC_ERROR_SAME_HANDLES: SceAudiodecErrorCode = 2155806738;
pub const SCE_AUDIODEC_ERROR_UNSUPPORTED: SceAudiodecErrorCode = 2155806734;
pub const SCE_AUDIODEC_MP3_ERROR_INVALID_CH: SceAudiodecErrorCode = 2155816960;
pub const SCE_AUDIODEC_MP3_ERROR_INVALID_MPEG_VERSION: SceAudiodecErrorCode = 2155816961;
pub const SCE_AUDIODEC_MP3_EXTRA_ACCESS_SIZE: u32 = 0;
pub const SCE_AUDIODEC_MP3_MAX_CH_IN_DECODER: u32 = 2;
pub const SCE_AUDIODEC_MP3_MAX_ES_SIZE: u32 = 1441;
pub const SCE_AUDIODEC_MP3_MAX_NFRAMES: u32 = 1;
pub const SCE_AUDIODEC_MP3_MAX_NSTREAMS: u32 = 6;
pub const SCE_AUDIODEC_MP3_MAX_SAMPLES: u32 = 1152;
pub const SCE_AUDIODEC_MP3_MAX_STREAMS: u32 = 8;
pub const SCE_AUDIODEC_MP3_MPEG_VERSION_1: SceAudiodecMpegVersion = 3;
pub const SCE_AUDIODEC_MP3_MPEG_VERSION_2: SceAudiodecMpegVersion = 2;
pub const SCE_AUDIODEC_MP3_MPEG_VERSION_2_5: SceAudiodecMpegVersion = 0;
pub const SCE_AUDIODEC_MP3_MPEG_VERSION_RESERVED: SceAudiodecMpegVersion = 1;
pub const SCE_AUDIODEC_TYPE_AAC: SceAudiodecType = 4101;
pub const SCE_AUDIODEC_TYPE_AT9: SceAudiodecType = 4099;
pub const SCE_AUDIODEC_TYPE_CELP: SceAudiodecType = 4102;
pub const SCE_AUDIODEC_TYPE_MP3: SceAudiodecType = 4100;
pub const SCE_AUDIODEC_WORD_LENGTH_16BITS: u32 = 16;
pub const SCE_AUDIOENC_CELP_BIT_RATE_10700BPS: SceAudioencCelpBitrate = 10700;
pub const SCE_AUDIOENC_CELP_BIT_RATE_11800BPS: SceAudioencCelpBitrate = 11800;
pub const SCE_AUDIOENC_CELP_BIT_RATE_12200BPS: SceAudioencCelpBitrate = 12200;
pub const SCE_AUDIOENC_CELP_BIT_RATE_3850BPS: SceAudioencCelpBitrate = 3850;
pub const SCE_AUDIOENC_CELP_BIT_RATE_4650BPS: SceAudioencCelpBitrate = 4650;
pub const SCE_AUDIOENC_CELP_BIT_RATE_5700BPS: SceAudioencCelpBitrate = 5700;
pub const SCE_AUDIOENC_CELP_BIT_RATE_6600BPS: SceAudioencCelpBitrate = 6600;
pub const SCE_AUDIOENC_CELP_BIT_RATE_7300BPS: SceAudioencCelpBitrate = 7300;
pub const SCE_AUDIOENC_CELP_BIT_RATE_8700BPS: SceAudioencCelpBitrate = 8700;
pub const SCE_AUDIOENC_CELP_BIT_RATE_9900BPS: SceAudioencCelpBitrate = 9900;
pub const SCE_AUDIOENC_CELP_ERROR_INVALID_CONFIG: SceAudioencCelpErrorCode = 2156269569;
pub const SCE_AUDIOENC_CELP_MAX_ES_SIZE: u32 = 24;
pub const SCE_AUDIOENC_CELP_MAX_SAMPLES: u32 = 320;
pub const SCE_AUDIOENC_CELP_MAX_STREAMS: u32 = 1;
pub const SCE_AUDIOENC_CELP_MPE: u32 = 0;
pub const SCE_AUDIOENC_CELP_SAMPLING_RATE_8KHZ: u32 = 8000;
pub const SCE_AUDIOENC_ERROR_A_HANDLE_IN_USE: SceAudioencErrorCode = 2156265478;
pub const SCE_AUDIOENC_ERROR_ALL_HANDLES_IN_USE: SceAudioencErrorCode = 2156265479;
pub const SCE_AUDIOENC_ERROR_ALREADY_INITIALIZED: SceAudioencErrorCode = 2156265475;
pub const SCE_AUDIOENC_ERROR_API_FAIL: SceAudioencErrorCode = 2156265472;
pub const SCE_AUDIOENC_ERROR_CH_SHORTAGE: SceAudioencErrorCode = 2156265483;
pub const SCE_AUDIOENC_ERROR_INVALID_ALIGNMENT: SceAudioencErrorCode = 2156265486;
pub const SCE_AUDIOENC_ERROR_INVALID_HANDLE: SceAudioencErrorCode = 2156265481;
pub const SCE_AUDIOENC_ERROR_INVALID_INIT_PARAM: SceAudioencErrorCode = 2156265474;
pub const SCE_AUDIOENC_ERROR_INVALID_PTR: SceAudioencErrorCode = 2156265480;
pub const SCE_AUDIOENC_ERROR_INVALID_SIZE: SceAudioencErrorCode = 2156265485;
pub const SCE_AUDIOENC_ERROR_INVALID_TYPE: SceAudioencErrorCode = 2156265473;
pub const SCE_AUDIOENC_ERROR_INVALID_WORD_LENGTH: SceAudioencErrorCode = 2156265484;
pub const SCE_AUDIOENC_ERROR_NOT_HANDLE_IN_USE: SceAudioencErrorCode = 2156265482;
pub const SCE_AUDIOENC_ERROR_NOT_INITIALIZED: SceAudioencErrorCode = 2156265477;
pub const SCE_AUDIOENC_ERROR_OUT_OF_MEMORY: SceAudioencErrorCode = 2156265476;
pub const SCE_AUDIOENC_ERROR_UNSUPPORTED: SceAudioencErrorCode = 2156265487;
pub const SCE_AUDIOENC_TYPE_CELP: u32 = 8198;
pub const SCE_AUDIOENC_WORD_LENGTH_16BITS: u32 = 16;
#[doc = "Tried to input while busy"]
pub const SCE_AUDIO_IN_ERROR_BUSY: SceAudioInErrorCode = 2149974282;
#[doc = "Undefined error"]
pub const SCE_AUDIO_IN_ERROR_FATAL: SceAudioInErrorCode = 2149974272;
#[doc = "Invalid parameter"]
pub const SCE_AUDIO_IN_ERROR_INVALID_PARAMETER: SceAudioInErrorCode = 2149974283;
#[doc = "Invalid pointer value"]
pub const SCE_AUDIO_IN_ERROR_INVALID_POINTER: SceAudioInErrorCode = 2149974277;
#[doc = "Bad value of port number"]
pub const SCE_AUDIO_IN_ERROR_INVALID_PORT: SceAudioInErrorCode = 2149974273;
#[doc = "Invalid port param"]
pub const SCE_AUDIO_IN_ERROR_INVALID_PORT_PARAM: SceAudioInErrorCode = 2149974278;
#[doc = "Invalid port type"]
pub const SCE_AUDIO_IN_ERROR_INVALID_PORT_TYPE: SceAudioInErrorCode = 2149974276;
#[doc = "Invalid sample frequency"]
pub const SCE_AUDIO_IN_ERROR_INVALID_SAMPLE_FREQ: SceAudioInErrorCode = 2149974275;
#[doc = "Invalid sample length"]
pub const SCE_AUDIO_IN_ERROR_INVALID_SIZE: SceAudioInErrorCode = 2149974274;
#[doc = "Port is not opened"]
pub const SCE_AUDIO_IN_ERROR_NOT_OPENED: SceAudioInErrorCode = 2149974281;
#[doc = "Not enough memory"]
pub const SCE_AUDIO_IN_ERROR_OUT_OF_MEMORY: SceAudioInErrorCode = 2149974280;
#[doc = "Cannot open no ports"]
pub const SCE_AUDIO_IN_ERROR_PORT_FULL: SceAudioInErrorCode = 2149974279;
pub const SCE_AUDIO_IN_GETSTATUS_MUTE: SceAudioInParam = 1;
pub const SCE_AUDIO_IN_PARAM_FORMAT_S16_MONO: SceAudioInParam = 0;
pub const SCE_AUDIO_IN_PORT_TYPE_RAW: SceAudioInPortType = 2;
pub const SCE_AUDIO_IN_PORT_TYPE_VOICE: SceAudioInPortType = 0;
pub const SCE_AUDIO_MAX_LEN: u32 = 65472;
pub const SCE_AUDIO_MIN_LEN: u32 = 64;
pub const SCE_AUDIO_OUT_CONFIG_TYPE_FREQ: SceAudioOutConfigType = 1;
pub const SCE_AUDIO_OUT_CONFIG_TYPE_LEN: SceAudioOutConfigType = 0;
pub const SCE_AUDIO_OUT_CONFIG_TYPE_MODE: SceAudioOutConfigType = 2;
pub const SCE_AUDIO_OUT_ERROR_BUSY: SceAudioOutErrorCode = 2149974018;
pub const SCE_AUDIO_OUT_ERROR_INVALID_CONF_TYPE: SceAudioOutErrorCode = 2149974028;
pub const SCE_AUDIO_OUT_ERROR_INVALID_FORMAT: SceAudioOutErrorCode = 2149974023;
pub const SCE_AUDIO_OUT_ERROR_INVALID_FX_TYPE: SceAudioOutErrorCode = 2149974027;
pub const SCE_AUDIO_OUT_ERROR_INVALID_POINTER: SceAudioOutErrorCode = 2149974020;
pub const SCE_AUDIO_OUT_ERROR_INVALID_PORT: SceAudioOutErrorCode = 2149974019;
pub const SCE_AUDIO_OUT_ERROR_INVALID_PORT_TYPE: SceAudioOutErrorCode = 2149974026;
pub const SCE_AUDIO_OUT_ERROR_INVALID_SAMPLE_FREQ: SceAudioOutErrorCode = 2149974024;
pub const SCE_AUDIO_OUT_ERROR_INVALID_SIZE: SceAudioOutErrorCode = 2149974022;
pub const SCE_AUDIO_OUT_ERROR_INVALID_VOLUME: SceAudioOutErrorCode = 2149974025;
pub const SCE_AUDIO_OUT_ERROR_NOT_OPENED: SceAudioOutErrorCode = 2149974017;
pub const SCE_AUDIO_OUT_ERROR_OUT_OF_MEMORY: SceAudioOutErrorCode = 2149974029;
pub const SCE_AUDIO_OUT_ERROR_PORT_FULL: SceAudioOutErrorCode = 2149974021;
pub const SCE_AUDIO_OUT_MAX_VOL: u32 = 32768;
pub const SCE_AUDIO_OUT_MODE_MONO: SceAudioOutMode = 0;
pub const SCE_AUDIO_OUT_MODE_STEREO: SceAudioOutMode = 1;
pub const SCE_AUDIO_OUT_PARAM_FORMAT_S16_MONO: SceAudioOutParam = 0;
pub const SCE_AUDIO_OUT_PARAM_FORMAT_S16_STEREO: SceAudioOutParam = 1;
#[doc = "Used for Background Music port"]
pub const SCE_AUDIO_OUT_PORT_TYPE_BGM: SceAudioOutPortType = 1;
#[doc = "Used for main audio output, freq must be set to 48000 Hz"]
pub const SCE_AUDIO_OUT_PORT_TYPE_MAIN: SceAudioOutPortType = 0;
#[doc = "Used for voice chat port"]
pub const SCE_AUDIO_OUT_PORT_TYPE_VOICE: SceAudioOutPortType = 2;
pub const SCE_AUDIO_VOLUME_0DB: u32 = 32768;
#[doc = "Left Channel"]
pub const SCE_AUDIO_VOLUME_FLAG_L_CH: SceAudioOutChannelFlag = 1;
#[doc = "Right Channel"]
pub const SCE_AUDIO_VOLUME_FLAG_R_CH: SceAudioOutChannelFlag = 2;
pub const SCE_AVCDEC_ERROR_ALREADY_USED: SceAvcdecErrorCode = 2153906184;
pub const SCE_AVCDEC_ERROR_ES_BUFFER_FULL: SceAvcdecErrorCode = 2153906186;
pub const SCE_AVCDEC_ERROR_INITIALIZE: SceAvcdecErrorCode = 2153906187;
pub const SCE_AVCDEC_ERROR_INVALID_ARGUMENT_SIZE: SceAvcdecErrorCode = 2153906190;
pub const SCE_AVCDEC_ERROR_INVALID_COLOR_FORMAT: SceAvcdecErrorCode = 2153906182;
pub const SCE_AVCDEC_ERROR_INVALID_PARAM: SceAvcdecErrorCode = 2153906178;
pub const SCE_AVCDEC_ERROR_INVALID_POINTER: SceAvcdecErrorCode = 2153906185;
pub const SCE_AVCDEC_ERROR_INVALID_STATE: SceAvcdecErrorCode = 2153906180;
pub const SCE_AVCDEC_ERROR_INVALID_STREAM: SceAvcdecErrorCode = 2153906189;
pub const SCE_AVCDEC_ERROR_INVALID_TYPE: SceAvcdecErrorCode = 2153906177;
pub const SCE_AVCDEC_ERROR_NOT_INITIALIZE: SceAvcdecErrorCode = 2153906188;
pub const SCE_AVCDEC_ERROR_NOT_PHY_CONTINUOUS_MEMORY: SceAvcdecErrorCode = 2153906183;
pub const SCE_AVCDEC_ERROR_OUT_OF_MEMORY: SceAvcdecErrorCode = 2153906179;
pub const SCE_AVCDEC_ERROR_UNSUPPORT_IMAGE_SIZE: SceAvcdecErrorCode = 2153906181;
pub const SCE_AVCDEC_PIXELFORMAT_RGBA5551: SceAvcdecPixelFormat = 2;
pub const SCE_AVCDEC_PIXELFORMAT_RGBA565: SceAvcdecPixelFormat = 1;
pub const SCE_AVCDEC_PIXELFORMAT_RGBA8888: SceAvcdecPixelFormat = 0;
pub const SCE_AVCDEC_PIXELFORMAT_YUV420_PACKED_RASTER: SceAvcdecPixelFormat = 32;
pub const SCE_AVCDEC_PIXELFORMAT_YUV420_RASTER: SceAvcdecPixelFormat = 16;
#[doc = "Default"]
pub const SCE_AVCONFIG_COLOR_SPACE_MODE_DEFAULT: SceAVConfigColorSpaceMode = 0;
#[doc = "High Contrast Mode"]
pub const SCE_AVCONFIG_COLOR_SPACE_MODE_HIGH_CONTRAST: SceAVConfigColorSpaceMode = 1;
#[doc = "Audio stream type"]
pub const SCE_AVPLAYER_AUDIO: SceAvPlayerStreamType = 1;
pub const SCE_AVPLAYER_ERROR_INVALID_PARAM: SceAvPlayerErrorCode = 2154430465;
pub const SCE_AVPLAYER_ERROR_OUT_OF_MEMORY: SceAvPlayerErrorCode = 2154430467;
#[doc = "Timed text (subtitles) stream type"]
pub const SCE_AVPLAYER_TIMEDTEXT: SceAvPlayerStreamType = 2;
#[doc = "Fast Forward 16x"]
pub const SCE_AVPLAYER_TRICK_SPEED_FAST_FORWARD_16X: SceAvPlayerTrickSpeeds = 1600;
#[doc = "Fast Forward 2x"]
pub const SCE_AVPLAYER_TRICK_SPEED_FAST_FORWARD_2X: SceAvPlayerTrickSpeeds = 200;
#[doc = "Fast Forward 32x"]
pub const SCE_AVPLAYER_TRICK_SPEED_FAST_FORWARD_32X: SceAvPlayerTrickSpeeds = 3200;
#[doc = "Fast Forward 4x"]
pub const SCE_AVPLAYER_TRICK_SPEED_FAST_FORWARD_4X: SceAvPlayerTrickSpeeds = 400;
#[doc = "Fast Forward 8x"]
pub const SCE_AVPLAYER_TRICK_SPEED_FAST_FORWARD_8X: SceAvPlayerTrickSpeeds = 800;
#[doc = "Normal Speed"]
pub const SCE_AVPLAYER_TRICK_SPEED_NORMAL: SceAvPlayerTrickSpeeds = 100;
#[doc = "Rewind 16x"]
pub const SCE_AVPLAYER_TRICK_SPEED_REWIND_16X: SceAvPlayerTrickSpeeds = -1600;
#[doc = "Rewind 32x"]
pub const SCE_AVPLAYER_TRICK_SPEED_REWIND_32X: SceAvPlayerTrickSpeeds = -3200;
#[doc = "Rewind 8x"]
pub const SCE_AVPLAYER_TRICK_SPEED_REWIND_8X: SceAvPlayerTrickSpeeds = -800;
#[doc = "Video stream type"]
pub const SCE_AVPLAYER_VIDEO: SceAvPlayerStreamType = 0;
pub const SCE_BGAPP_UTIL_ERROR_INVALID_ARG: SceBgAppUtilErrorCode = 2148558082;
pub const SCE_BT_ERROR_ACL_TX_BUF_OVERFLOW: SceBtErrorCode = 2150566659;
pub const SCE_BT_ERROR_ACL_TX_CB_OVERFLOW: SceBtErrorCode = 2150566660;
pub const SCE_BT_ERROR_ATT_APPLICATION_ERROR_HI: SceBtErrorCode = 2150573055;
pub const SCE_BT_ERROR_ATT_APPLICATION_ERROR_LO: SceBtErrorCode = 2150572928;
pub const SCE_BT_ERROR_ATT_ATTRIBUTE_NOT_FOUND: SceBtErrorCode = 2150572810;
pub const SCE_BT_ERROR_ATT_ATTRIBUTE_NOT_LONG: SceBtErrorCode = 2150572811;
pub const SCE_BT_ERROR_ATT_BASE: SceBtErrorCode = 2150572800;
pub const SCE_BT_ERROR_ATT_INSUFFICIENT_AUTHENTICATION: SceBtErrorCode = 2150572805;
pub const SCE_BT_ERROR_ATT_INSUFFICIENT_AUTHORIZATION: SceBtErrorCode = 2150572808;
pub const SCE_BT_ERROR_ATT_INSUFFICIENT_ENCRYPTION: SceBtErrorCode = 2150572815;
pub const SCE_BT_ERROR_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE: SceBtErrorCode = 2150572812;
pub const SCE_BT_ERROR_ATT_INSUFFICIENT_RESOURCES: SceBtErrorCode = 2150572817;
pub const SCE_BT_ERROR_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH: SceBtErrorCode = 2150572813;
pub const SCE_BT_ERROR_ATT_INVALID_HANDLE: SceBtErrorCode = 2150572801;
pub const SCE_BT_ERROR_ATT_INVALID_OFFSET: SceBtErrorCode = 2150572807;
pub const SCE_BT_ERROR_ATT_INVALID_PDU: SceBtErrorCode = 2150572804;
pub const SCE_BT_ERROR_ATT_NOT_YET: SceBtErrorCode = 2150574599;
pub const SCE_BT_ERROR_ATT_PEPARE_QUEUE_FULL: SceBtErrorCode = 2150572809;
pub const SCE_BT_ERROR_ATT_READ_INVALID_INTERNAL: SceBtErrorCode = 2150574595;
pub const SCE_BT_ERROR_ATT_READ_INVALID_LENGTH: SceBtErrorCode = 2150574594;
pub const SCE_BT_ERROR_ATT_READ_INVALID_NO: SceBtErrorCode = 2150574593;
pub const SCE_BT_ERROR_ATT_READ_NOT_PERMITTED: SceBtErrorCode = 2150572802;
pub const SCE_BT_ERROR_ATT_REQUEST_NOT_SUPPORTED: SceBtErrorCode = 2150572806;
pub const SCE_BT_ERROR_ATT_UNLIKELY_ERROR: SceBtErrorCode = 2150572814;
pub const SCE_BT_ERROR_ATT_UNSUPPORTED_GROUP_TYPE: SceBtErrorCode = 2150572816;
pub const SCE_BT_ERROR_ATT_WRITE_INVALID_INTERNAL: SceBtErrorCode = 2150574598;
pub const SCE_BT_ERROR_ATT_WRITE_INVALID_LENGTH: SceBtErrorCode = 2150574597;
pub const SCE_BT_ERROR_ATT_WRITE_INVALID_NO: SceBtErrorCode = 2150574596;
pub const SCE_BT_ERROR_ATT_WRITE_NOT_PERMITTED: SceBtErrorCode = 2150572803;
pub const SCE_BT_ERROR_AUDIO_COMBI_NOT_FOUND: SceBtErrorCode = 2150567190;
pub const SCE_BT_ERROR_AUDIO_FREQ_IS_LE: SceBtErrorCode = 2150572553;
pub const SCE_BT_ERROR_AUDIO_FREQ_NOT_CONNECTED: SceBtErrorCode = 2150567183;
pub const SCE_BT_ERROR_AUDIO_INTERNAL_1: SceBtErrorCode = 2150567192;
pub const SCE_BT_ERROR_AUDIO_RECV_BAD_TYPE: SceBtErrorCode = 2150567186;
pub const SCE_BT_ERROR_AUDIO_RECV_BUSY: SceBtErrorCode = 2150567194;
pub const SCE_BT_ERROR_AUDIO_RECV_INVALID_LENGTH: SceBtErrorCode = 2150567178;
pub const SCE_BT_ERROR_AUDIO_RECV_IS_LE: SceBtErrorCode = 2150572552;
pub const SCE_BT_ERROR_AUDIO_RECV_NO_CAP: SceBtErrorCode = 2150567197;
pub const SCE_BT_ERROR_AUDIO_RECV_NOT_CONNECTED: SceBtErrorCode = 2150567176;
pub const SCE_BT_ERROR_AUDIO_RECV_NOT_STARTED: SceBtErrorCode = 2150567177;
pub const SCE_BT_ERROR_AUDIO_RECV_SERV_FAILED: SceBtErrorCode = 2150567198;
pub const SCE_BT_ERROR_AUDIO_SEND_BAD_TYPE: SceBtErrorCode = 2150567185;
pub const SCE_BT_ERROR_AUDIO_SEND_BUSY: SceBtErrorCode = 2150567193;
pub const SCE_BT_ERROR_AUDIO_SEND_INVALID_LENGTH: SceBtErrorCode = 2150567175;
pub const SCE_BT_ERROR_AUDIO_SEND_IS_LE: SceBtErrorCode = 2150572551;
pub const SCE_BT_ERROR_AUDIO_SEND_NO_CAP: SceBtErrorCode = 2150567195;
pub const SCE_BT_ERROR_AUDIO_SEND_NO_CP: SceBtErrorCode = 2150567184;
pub const SCE_BT_ERROR_AUDIO_SEND_NO_L2C: SceBtErrorCode = 2150567191;
pub const SCE_BT_ERROR_AUDIO_SEND_NOT_CONNECTED: SceBtErrorCode = 2150567173;
pub const SCE_BT_ERROR_AUDIO_SEND_NOT_STARTED: SceBtErrorCode = 2150567174;
pub const SCE_BT_ERROR_AUDIO_SEND_SERV_FAILED: SceBtErrorCode = 2150567196;
pub const SCE_BT_ERROR_AUDIO_START_INVALID_SERV: SceBtErrorCode = 2150567179;
pub const SCE_BT_ERROR_AUDIO_START_IS_LE: SceBtErrorCode = 2150572549;
pub const SCE_BT_ERROR_AUDIO_START_NO_CAP: SceBtErrorCode = 2150567170;
pub const SCE_BT_ERROR_AUDIO_START_NOT_CONNECTED: SceBtErrorCode = 2150567169;
pub const SCE_BT_ERROR_AUDIO_START_SERV_FAILED: SceBtErrorCode = 2150567181;
pub const SCE_BT_ERROR_AUDIO_STOP_INVALID_SERV: SceBtErrorCode = 2150567180;
pub const SCE_BT_ERROR_AUDIO_STOP_IS_LE: SceBtErrorCode = 2150572550;
pub const SCE_BT_ERROR_AUDIO_STOP_NO_CAP: SceBtErrorCode = 2150567172;
pub const SCE_BT_ERROR_AUDIO_STOP_NOT_CONNECTED: SceBtErrorCode = 2150567171;
pub const SCE_BT_ERROR_AUDIO_STOP_SERV_FAILED: SceBtErrorCode = 2150567182;
pub const SCE_BT_ERROR_AVCTP_IS_LE: SceBtErrorCode = 2150572547;
pub const SCE_BT_ERROR_AVCTP_NOT_CONNECTED: SceBtErrorCode = 2150565380;
pub const SCE_BT_ERROR_AVCTP_OPEN_NO_L2C: SceBtErrorCode = 2150565377;
pub const SCE_BT_ERROR_AVCTP_READ_NO_VOLUME: SceBtErrorCode = 2150565384;
pub const SCE_BT_ERROR_AVCTP_SEND_BUSY: SceBtErrorCode = 2150565381;
pub const SCE_BT_ERROR_AVCTP_SEND_NO_L2C: SceBtErrorCode = 2150565379;
pub const SCE_BT_ERROR_AVCTP_SEND_NO_PRESS: SceBtErrorCode = 2150565382;
pub const SCE_BT_ERROR_AVCTP_SEND_NO_RELEASE: SceBtErrorCode = 2150565383;
pub const SCE_BT_ERROR_AVCTP_SEND_NOT_RUBY: SceBtErrorCode = 2150565385;
pub const SCE_BT_ERROR_AVDTP_CLOSE_BAD_SERV: SceBtErrorCode = 2150565122;
pub const SCE_BT_ERROR_AVDTP_CLOSE_BAD_STATE: SceBtErrorCode = 2150565123;
pub const SCE_BT_ERROR_AVDTP_OPEN_NO_L2C: SceBtErrorCode = 2150565121;
pub const SCE_BT_ERROR_AVDTP_RECONF_BAD_SERV: SceBtErrorCode = 2150565129;
pub const SCE_BT_ERROR_AVDTP_RECONF_BAD_STATE: SceBtErrorCode = 2150565130;
pub const SCE_BT_ERROR_AVDTP_SEND_BAD_STATE: SceBtErrorCode = 2150565128;
pub const SCE_BT_ERROR_AVDTP_START_BAD_SERV: SceBtErrorCode = 2150565124;
pub const SCE_BT_ERROR_AVDTP_START_BAD_STATE: SceBtErrorCode = 2150565125;
pub const SCE_BT_ERROR_AVDTP_STOP_BAD_SERV: SceBtErrorCode = 2150565126;
pub const SCE_BT_ERROR_AVDTP_STOP_BAD_STATE: SceBtErrorCode = 2150565127;
pub const SCE_BT_ERROR_AVRCP_INVALID_PLAY_STATUS: SceBtErrorCode = 2150568450;
pub const SCE_BT_ERROR_AVRCP_TOO_LONG_TITLE: SceBtErrorCode = 2150568449;
pub const SCE_BT_ERROR_CB_NOT_REGISTERED: SceBtErrorCode = 2150566915;
pub const SCE_BT_ERROR_CB_OVERFLOW: SceBtErrorCode = 2150566916;
pub const SCE_BT_ERROR_CB_TOO_MANY: SceBtErrorCode = 2150566914;
pub const SCE_BT_ERROR_CONF_BT_INACTIVE: SceBtErrorCode = 2150569219;
pub const SCE_BT_ERROR_CONF_CANT_DISABLE_FUNCTION: SceBtErrorCode = 2150569224;
pub const SCE_BT_ERROR_CONF_CANT_ENABLE_FUNCTION: SceBtErrorCode = 2150569223;
pub const SCE_BT_ERROR_CONF_CANT_ENTER: SceBtErrorCode = 2150569248;
pub const SCE_BT_ERROR_CONF_CARD_NOT_FOUND: SceBtErrorCode = 2150569221;
pub const SCE_BT_ERROR_CONF_DISABLE_SUBINTR: SceBtErrorCode = 2150569228;
pub const SCE_BT_ERROR_CONF_ENABLE_SUBINTR: SceBtErrorCode = 2150569227;
pub const SCE_BT_ERROR_CONF_FUNCTION_NOT_FOUND: SceBtErrorCode = 2150569222;
pub const SCE_BT_ERROR_CONF_INVALID_VALUE: SceBtErrorCode = 2150569218;
pub const SCE_BT_ERROR_CONF_NOT_READY: SceBtErrorCode = 2150569217;
pub const SCE_BT_ERROR_CONF_OFF_TIMEOUT: SceBtErrorCode = 2150569230;
pub const SCE_BT_ERROR_CONF_ON_TIMEOUT: SceBtErrorCode = 2150569229;
pub const SCE_BT_ERROR_CONF_REGISTER_SUBINTR_HANDLER: SceBtErrorCode = 2150569225;
pub const SCE_BT_ERROR_CONF_RELEASE_SUBINTR_HANDLER: SceBtErrorCode = 2150569226;
pub const SCE_BT_ERROR_CONF_SUSPEND_TIMEOUT: SceBtErrorCode = 2150569231;
pub const SCE_BT_ERROR_CONF_TIMEOUT: SceBtErrorCode = 2150569220;
pub const SCE_BT_ERROR_CONNECT_START_BUSY: SceBtErrorCode = 2150564356;
pub const SCE_BT_ERROR_CONNECT_START_CONNECTED: SceBtErrorCode = 2150564362;
pub const SCE_BT_ERROR_CONNECT_START_DELETING: SceBtErrorCode = 2150564366;
pub const SCE_BT_ERROR_CONNECT_START_IS_LE: SceBtErrorCode = 2150572546;
pub const SCE_BT_ERROR_CONNECT_START_NO_REG: SceBtErrorCode = 2150564354;
pub const SCE_BT_ERROR_CONNECT_START_NOT_CONNECTABLE: SceBtErrorCode = 2150564355;
pub const SCE_BT_ERROR_CONNECT_START_REG_FULL: SceBtErrorCode = 2150564361;
pub const SCE_BT_ERROR_CONNECT_START_TOO_MANY: SceBtErrorCode = 2150564365;
pub const SCE_BT_ERROR_COPYIN_FAILED: SceBtErrorCode = 2150566665;
pub const SCE_BT_ERROR_COPYOUT_FAILED: SceBtErrorCode = 2150566666;
pub const SCE_BT_ERROR_DISCONNECT_START_NOT_CONNECTED: SceBtErrorCode = 2150564357;
pub const SCE_BT_ERROR_GATT_BUSY: SceBtErrorCode = 2150573059;
pub const SCE_BT_ERROR_GATT_DISCONNECT: SceBtErrorCode = 2150573066;
pub const SCE_BT_ERROR_GATT_ENTER: SceBtErrorCode = 2150573068;
pub const SCE_BT_ERROR_GATT_INVALID_FLAGS: SceBtErrorCode = 2150573061;
pub const SCE_BT_ERROR_GATT_INVALID_HANDLE: SceBtErrorCode = 2150573060;
pub const SCE_BT_ERROR_GATT_INVALID_NO: SceBtErrorCode = 2150573057;
pub const SCE_BT_ERROR_GATT_INVALID_SIZE: SceBtErrorCode = 2150573062;
pub const SCE_BT_ERROR_GATT_NOT_CONNECTED: SceBtErrorCode = 2150573058;
pub const SCE_BT_ERROR_GATT_NOT_LE: SceBtErrorCode = 2150573063;
pub const SCE_BT_ERROR_GATT_NOT_YET: SceBtErrorCode = 2150573065;
pub const SCE_BT_ERROR_GATT_TOO_BIG_BUFFER: SceBtErrorCode = 2150573069;
pub const SCE_BT_ERROR_GATT_TOO_BIG_RECORD: SceBtErrorCode = 2150573064;
pub const SCE_BT_ERROR_GATT_TSLEEP: SceBtErrorCode = 2150573067;
pub const SCE_BT_ERROR_GET_DEBUG_INFO_INVALID_ARGUMENT: SceBtErrorCode = 2150572293;
pub const SCE_BT_ERROR_GET_DEBUG_INFO_INVALID_REQUEST: SceBtErrorCode = 2150572289;
pub const SCE_BT_ERROR_GET_DEBUG_INFO_INVALID_SIZE: SceBtErrorCode = 2150572291;
pub const SCE_BT_ERROR_GET_DEBUG_INFO_INVALID_STATE: SceBtErrorCode = 2150572295;
pub const SCE_BT_ERROR_GET_DEBUG_INFO_NOT_CONNECTED: SceBtErrorCode = 2150572297;
pub const SCE_BT_ERROR_GET_JACK_STATUS_NOT_CONNECTED: SceBtErrorCode = 2150576897;
pub const SCE_BT_ERROR_GET_NAME_NO_DEVICE: SceBtErrorCode = 2150566913;
pub const SCE_BT_ERROR_HCI_TX_OVERFLOW: SceBtErrorCode = 2150566658;
pub const SCE_BT_ERROR_HID_CLOSE_NO_L2C: SceBtErrorCode = 2150566146;
pub const SCE_BT_ERROR_HID_INVALID_BUFFER_ADDRESS: SceBtErrorCode = 2150566151;
pub const SCE_BT_ERROR_HID_INVALID_IDLE: SceBtErrorCode = 2150566153;
pub const SCE_BT_ERROR_HID_INVALID_LENGTH: SceBtErrorCode = 2150566157;
pub const SCE_BT_ERROR_HID_INVALID_PROTOCOL: SceBtErrorCode = 2150566152;
pub const SCE_BT_ERROR_HID_INVALID_REPORT_ID: SceBtErrorCode = 2150566158;
pub const SCE_BT_ERROR_HID_INVALID_REQUEST_TYPE: SceBtErrorCode = 2150566150;
pub const SCE_BT_ERROR_HID_IS_LE: SceBtErrorCode = 2150572548;
pub const SCE_BT_ERROR_HID_NO_CAP: SceBtErrorCode = 2150566149;
pub const SCE_BT_ERROR_HID_NOT_CONNECTED: SceBtErrorCode = 2150566148;
pub const SCE_BT_ERROR_HID_NOT_YET: SceBtErrorCode = 2150566156;
pub const SCE_BT_ERROR_HID_OPEN_NO_L2C: SceBtErrorCode = 2150566145;
pub const SCE_BT_ERROR_HID_OVERWRITE_REQ: SceBtErrorCode = 2150566159;
pub const SCE_BT_ERROR_HID_RECV_INVALID_LENGTH: SceBtErrorCode = 2150567426;
pub const SCE_BT_ERROR_HID_RECV_NOT_CONNECTED: SceBtErrorCode = 2150567425;
pub const SCE_BT_ERROR_HID_SEND_NO_L2C: SceBtErrorCode = 2150566147;
pub const SCE_BT_ERROR_INQUIRY_START_BUSY: SceBtErrorCode = 2150564353;
pub const SCE_BT_ERROR_JEDI_SNIFF_NOT_CONNECTED: SceBtErrorCode = 2150577665;
pub const SCE_BT_ERROR_JEDI_SNIFF_NOT_JEDI: SceBtErrorCode = 2150577666;
pub const SCE_BT_ERROR_JEDI_VOLUME_GAIN_NOT_CONNECTED: SceBtErrorCode = 2150577409;
pub const SCE_BT_ERROR_JUMBO_UNLOCK_NOT_OWNER: SceBtErrorCode = 2150566657;
pub const SCE_BT_ERROR_KPROC_CREATE: SceBtErrorCode = 2150572034;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_BUSY: SceBtErrorCode = 2150574349;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_CONNECTED: SceBtErrorCode = 2150574347;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_FULL: SceBtErrorCode = 2150574348;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_INTERVAL_MAX: SceBtErrorCode = 2150574342;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_INTERVAL_MIN: SceBtErrorCode = 2150574341;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_LATENCY: SceBtErrorCode = 2150574343;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_OWN_ADDRESS_TYPE: SceBtErrorCode = 2150574340;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_PEER_ADDRESS: SceBtErrorCode = 2150574339;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_SCAN_INTERVAL: SceBtErrorCode = 2150574337;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_SCAN_WINDOW: SceBtErrorCode = 2150574338;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_INVALID_TIMEOUT: SceBtErrorCode = 2150574344;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_REG_ERROR: SceBtErrorCode = 2150574346;
pub const SCE_BT_ERROR_LE_CREATE_CONNECTION_REG_FULL: SceBtErrorCode = 2150574345;
pub const SCE_BT_ERROR_LE_GET_ADVERTISING_NOT_FOUND: SceBtErrorCode = 2150574081;
pub const SCE_BT_ERROR_LE_NOT_SUPPORTED: SceBtErrorCode = 2150574849;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_DIRECT_ADDRESS: SceBtErrorCode = 2150573575;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_DIRECT_ADDRESS_TYPE: SceBtErrorCode = 2150573574;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_INTERVAL_MAX: SceBtErrorCode = 2150573572;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_INTERVAL_MIN: SceBtErrorCode = 2150573571;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_LENGTH: SceBtErrorCode = 2150573570;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_OWN_ADDRESS_TYPE: SceBtErrorCode = 2150573573;
pub const SCE_BT_ERROR_LE_SET_ADVERTISING_INVALID_REQ: SceBtErrorCode = 2150573569;
pub const SCE_BT_ERROR_LE_SET_SCAN_INVALID_INTERVAL: SceBtErrorCode = 2150573827;
pub const SCE_BT_ERROR_LE_SET_SCAN_INVALID_LENGTH: SceBtErrorCode = 2150573826;
pub const SCE_BT_ERROR_LE_SET_SCAN_INVALID_OWN_ADDRESS_TYPE: SceBtErrorCode = 2150573829;
pub const SCE_BT_ERROR_LE_SET_SCAN_INVALID_REQ: SceBtErrorCode = 2150573825;
pub const SCE_BT_ERROR_LE_SET_SCAN_INVALID_WINDOW: SceBtErrorCode = 2150573828;
pub const SCE_BT_ERROR_NOTIMP: SceBtErrorCode = 2150572033;
pub const SCE_BT_ERROR_NOT_READY: SceBtErrorCode = 2150576641;
pub const SCE_BT_ERROR_NOT_SUPPORTED_DEVICE: SceBtErrorCode = 2150577155;
pub const SCE_BT_ERROR_PAIRING_OOB_CAN_NOT_DISCONNECT: SceBtErrorCode = 2150576387;
pub const SCE_BT_ERROR_PAIRING_OOB_FULL: SceBtErrorCode = 2150576386;
pub const SCE_BT_ERROR_PAIRING_OOB_INTERNAL_ERROR: SceBtErrorCode = 2150576388;
pub const SCE_BT_ERROR_PAIRING_OOB_TIMEOUT: SceBtErrorCode = 2150576385;
pub const SCE_BT_ERROR_PIN_INVALID_LENGTH: SceBtErrorCode = 2150564358;
pub const SCE_BT_ERROR_PIN_IS_LE: SceBtErrorCode = 2150572545;
pub const SCE_BT_ERROR_REG_CANNOT_LOAD: SceBtErrorCode = 2150564106;
pub const SCE_BT_ERROR_REG_CANNOT_OPEN: SceBtErrorCode = 2150564107;
pub const SCE_BT_ERROR_REG_CANNOT_READ: SceBtErrorCode = 2150564108;
pub const SCE_BT_ERROR_REG_CANNOT_WRITE: SceBtErrorCode = 2150564109;
pub const SCE_BT_ERROR_REG_DELETE_CONNECTING: SceBtErrorCode = 2150564105;
pub const SCE_BT_ERROR_REG_DELETE_NO_ENTRY: SceBtErrorCode = 2150564098;
pub const SCE_BT_ERROR_REG_GET_HID_DESC_NO_REG: SceBtErrorCode = 2150564103;
pub const SCE_BT_ERROR_REG_GET_HID_DESC_TOO_SHORT: SceBtErrorCode = 2150564104;
pub const SCE_BT_ERROR_REG_NOT_READY: SceBtErrorCode = 2150564097;
pub const SCE_BT_ERROR_REG_SET_HID_DESC_BAD_ARG: SceBtErrorCode = 2150564101;
pub const SCE_BT_ERROR_REG_SET_HID_DESC_NO_REG: SceBtErrorCode = 2150564102;
pub const SCE_BT_ERROR_REG_UPDATE_CANNOT_SAVE: SceBtErrorCode = 2150564099;
pub const SCE_BT_ERROR_SDIO_DISABLE_FUNCTION: SceBtErrorCode = 2150572041;
pub const SCE_BT_ERROR_SDIO_ENABLE_FUNCTION: SceBtErrorCode = 2150572040;
pub const SCE_BT_ERROR_SDIO_GET_FUNCTION: SceBtErrorCode = 2150572035;
pub const SCE_BT_ERROR_SDIO_LOCK: SceBtErrorCode = 2150572038;
pub const SCE_BT_ERROR_SDIO_READ_DIR: SceBtErrorCode = 2150572044;
pub const SCE_BT_ERROR_SDIO_READ_FIX: SceBtErrorCode = 2150572046;
pub const SCE_BT_ERROR_SDIO_REGISTER_INTR_HANDLER: SceBtErrorCode = 2150572036;
pub const SCE_BT_ERROR_SDIO_SET_BLOCK_LEN: SceBtErrorCode = 2150572042;
pub const SCE_BT_ERROR_SDIO_SET_BUS_SPEED: SceBtErrorCode = 2150572043;
pub const SCE_BT_ERROR_SDIO_UNLOCK: SceBtErrorCode = 2150572039;
pub const SCE_BT_ERROR_SDIO_UNREGISTER_INTR_HANDLER: SceBtErrorCode = 2150572037;
pub const SCE_BT_ERROR_SDIO_WRITE_DIR: SceBtErrorCode = 2150572045;
pub const SCE_BT_ERROR_SDIO_WRITE_FIX: SceBtErrorCode = 2150572047;
pub const SCE_BT_ERROR_SDP_OPEN_NO_L2C: SceBtErrorCode = 2150564360;
pub const SCE_BT_ERROR_SET_DEBUG_INFO_INVALID_ARGUMENT: SceBtErrorCode = 2150572294;
pub const SCE_BT_ERROR_SET_DEBUG_INFO_INVALID_REQUEST: SceBtErrorCode = 2150572290;
pub const SCE_BT_ERROR_SET_DEBUG_INFO_INVALID_SIZE: SceBtErrorCode = 2150572292;
pub const SCE_BT_ERROR_SET_DEBUG_INFO_INVALID_STATE: SceBtErrorCode = 2150572296;
pub const SCE_BT_ERROR_SET_DEBUG_INFO_NOT_CONNECTED: SceBtErrorCode = 2150572298;
pub const SCE_BT_ERROR_SM_INVALID_CONFIRM_REPLY: SceBtErrorCode = 2150573317;
pub const SCE_BT_ERROR_SM_INVALID_KEY_LENGTH: SceBtErrorCode = 2150573313;
pub const SCE_BT_ERROR_SM_NO_REQ: SceBtErrorCode = 2150573315;
pub const SCE_BT_ERROR_SM_NOT_DIGIT: SceBtErrorCode = 2150573314;
pub const SCE_BT_ERROR_SM_NOT_NEEDED_PIN: SceBtErrorCode = 2150573316;
pub const SCE_BT_ERROR_TIMER_CANCEL_BAD_ID: SceBtErrorCode = 2150566661;
pub const SCE_BT_ERROR_TIMER_CANCEL_NOT_INITIALIZED: SceBtErrorCode = 2150566662;
pub const SCE_BT_ERROR_TIMER_SET_NO_SPACE: SceBtErrorCode = 2150566664;
pub const SCE_BT_ERROR_TIMER_SET_NOT_INITIALIZED: SceBtErrorCode = 2150566663;
pub const SCE_BT_ERROR_TOO_MANY_CONNECTION: SceBtErrorCode = 2150577153;
pub const SCE_BT_ERROR_TOO_MANY_HID: SceBtErrorCode = 2150577154;
pub const SCE_BT_ERROR_TSLEEP: SceBtErrorCode = 2150572048;
pub const SCE_BT_ERROR_USER_CONFIRM_NOT_CONNECTED: SceBtErrorCode = 2150564359;
#[doc = "50 Hz mode"]
pub const SCE_CAMERA_ANTIFLICKER_50HZ: SceCameraAntiFlicker = 2;
#[doc = "50 Hz mode"]
pub const SCE_CAMERA_ANTIFLICKER_60HZ: SceCameraAntiFlicker = 3;
#[doc = "Automatic mode"]
pub const SCE_CAMERA_ANTIFLICKER_AUTO: SceCameraAntiFlicker = 1;
#[doc = "Disabled"]
pub const SCE_CAMERA_BACKLIGHT_OFF: SceCameraBacklight = 0;
#[doc = "Enabled"]
pub const SCE_CAMERA_BACKLIGHT_ON: SceCameraBacklight = 1;
#[doc = "Retro camera"]
pub const SCE_CAMERA_DEVICE_BACK: SceCameraDevice = 1;
#[doc = "Front camera"]
pub const SCE_CAMERA_DEVICE_FRONT: SceCameraDevice = 0;
pub const SCE_CAMERA_EFFECT_BLACKWHITE: SceCameraEffect = 2;
pub const SCE_CAMERA_EFFECT_BLUE: SceCameraEffect = 4;
pub const SCE_CAMERA_EFFECT_GREEN: SceCameraEffect = 6;
pub const SCE_CAMERA_EFFECT_NEGATIVE: SceCameraEffect = 1;
pub const SCE_CAMERA_EFFECT_NORMAL: SceCameraEffect = 0;
pub const SCE_CAMERA_EFFECT_RED: SceCameraEffect = 5;
pub const SCE_CAMERA_EFFECT_SEPIA: SceCameraEffect = 3;
pub const SCE_CAMERA_ERROR_ALREADY_INIT: SceCameraErrorCode = 2150498305;
pub const SCE_CAMERA_ERROR_ALREADY_OPEN: SceCameraErrorCode = 2150498307;
pub const SCE_CAMERA_ERROR_ALREADY_READ: SceCameraErrorCode = 2150498319;
pub const SCE_CAMERA_ERROR_ALREADY_START: SceCameraErrorCode = 2150498309;
pub const SCE_CAMERA_ERROR_ATTRIBUTE_UNKNOWN: SceCameraErrorCode = 2150498316;
pub const SCE_CAMERA_ERROR_BAD_FRAMERATE: SceCameraErrorCode = 2150498313;
pub const SCE_CAMERA_ERROR_DATA_RANGE_UNKNOWN: SceCameraErrorCode = 2150498321;
pub const SCE_CAMERA_ERROR_EXCLUSIVE: SceCameraErrorCode = 2150498315;
pub const SCE_CAMERA_ERROR_FATAL: SceCameraErrorCode = 2150498559;
pub const SCE_CAMERA_ERROR_FORMAT_UNKNOWN: SceCameraErrorCode = 2150498311;
pub const SCE_CAMERA_ERROR_MAX_PROCESS: SceCameraErrorCode = 2150498317;
pub const SCE_CAMERA_ERROR_NOT_ACTIVE: SceCameraErrorCode = 2150498318;
pub const SCE_CAMERA_ERROR_NOT_INIT: SceCameraErrorCode = 2150498306;
pub const SCE_CAMERA_ERROR_NOT_MOUNTED: SceCameraErrorCode = 2150498320;
pub const SCE_CAMERA_ERROR_NOT_OPEN: SceCameraErrorCode = 2150498308;
pub const SCE_CAMERA_ERROR_NOT_START: SceCameraErrorCode = 2150498310;
pub const SCE_CAMERA_ERROR_OTHER_ALREADY_START: SceCameraErrorCode = 2150498322;
pub const SCE_CAMERA_ERROR_PARAM: SceCameraErrorCode = 2150498304;
pub const SCE_CAMERA_ERROR_RESOLUTION_UNKNOWN: SceCameraErrorCode = 2150498312;
pub const SCE_CAMERA_ERROR_TIMEOUT: SceCameraErrorCode = 2150498314;
#[doc = "-1.0"]
pub const SCE_CAMERA_EV_NEGATIVE_10: SceCameraExposureCompensation = -10;
#[doc = "-1.3"]
pub const SCE_CAMERA_EV_NEGATIVE_13: SceCameraExposureCompensation = -13;
#[doc = "-1.5"]
pub const SCE_CAMERA_EV_NEGATIVE_15: SceCameraExposureCompensation = -15;
#[doc = "-1.7"]
pub const SCE_CAMERA_EV_NEGATIVE_17: SceCameraExposureCompensation = -17;
#[doc = "-2.0"]
pub const SCE_CAMERA_EV_NEGATIVE_20: SceCameraExposureCompensation = -20;
#[doc = "-0.3"]
pub const SCE_CAMERA_EV_NEGATIVE_3: SceCameraExposureCompensation = -3;
#[doc = "-0.5"]
pub const SCE_CAMERA_EV_NEGATIVE_5: SceCameraExposureCompensation = -5;
#[doc = "-0.7"]
pub const SCE_CAMERA_EV_NEGATIVE_7: SceCameraExposureCompensation = -7;
#[doc = "+0.0"]
pub const SCE_CAMERA_EV_POSITIVE_0: SceCameraExposureCompensation = 0;
#[doc = "+1.0"]
pub const SCE_CAMERA_EV_POSITIVE_10: SceCameraExposureCompensation = 10;
#[doc = "+1.3"]
pub const SCE_CAMERA_EV_POSITIVE_13: SceCameraExposureCompensation = 13;
#[doc = "+1.5"]
pub const SCE_CAMERA_EV_POSITIVE_15: SceCameraExposureCompensation = 15;
#[doc = "+1.7"]
pub const SCE_CAMERA_EV_POSITIVE_17: SceCameraExposureCompensation = 17;
#[doc = "+2.0"]
pub const SCE_CAMERA_EV_POSITIVE_20: SceCameraExposureCompensation = 20;
#[doc = "+0.3"]
pub const SCE_CAMERA_EV_POSITIVE_3: SceCameraExposureCompensation = 3;
#[doc = "+0.5"]
pub const SCE_CAMERA_EV_POSITIVE_5: SceCameraExposureCompensation = 5;
#[doc = "+0.7"]
pub const SCE_CAMERA_EV_POSITIVE_7: SceCameraExposureCompensation = 7;
#[doc = "ABGR pixels"]
pub const SCE_CAMERA_FORMAT_ABGR: SceCameraFormat = 5;
#[doc = "ARGB pixels"]
pub const SCE_CAMERA_FORMAT_ARGB: SceCameraFormat = 4;
#[doc = "Invalid format"]
pub const SCE_CAMERA_FORMAT_INVALID: SceCameraFormat = 0;
#[doc = "8 bit raw data"]
pub const SCE_CAMERA_FORMAT_RAW8: SceCameraFormat = 6;
#[doc = "YUV420 planes"]
pub const SCE_CAMERA_FORMAT_YUV420_PLANE: SceCameraFormat = 3;
#[doc = "YUV422 pixels packed"]
pub const SCE_CAMERA_FORMAT_YUV422_PACKED: SceCameraFormat = 2;
#[doc = "YUV422 planes"]
pub const SCE_CAMERA_FORMAT_YUV422_PLANE: SceCameraFormat = 1;
#[doc = "10 fps"]
pub const SCE_CAMERA_FRAMERATE_10_FPS: SceCameraFrameRate = 10;
#[doc = "120 fps (> **Note:** Resolution must be QVGA or lower)"]
pub const SCE_CAMERA_FRAMERATE_120_FPS: SceCameraFrameRate = 120;
#[doc = "15 fps"]
pub const SCE_CAMERA_FRAMERATE_15_FPS: SceCameraFrameRate = 15;
#[doc = "20 fps"]
pub const SCE_CAMERA_FRAMERATE_20_FPS: SceCameraFrameRate = 20;
#[doc = "30 fps"]
pub const SCE_CAMERA_FRAMERATE_30_FPS: SceCameraFrameRate = 30;
#[doc = "3.75 fps"]
pub const SCE_CAMERA_FRAMERATE_3_FPS: SceCameraFrameRate = 3;
#[doc = "5 fps"]
pub const SCE_CAMERA_FRAMERATE_5_FPS: SceCameraFrameRate = 5;
#[doc = "60 fps"]
pub const SCE_CAMERA_FRAMERATE_60_FPS: SceCameraFrameRate = 60;
#[doc = "7.5 fps"]
pub const SCE_CAMERA_FRAMERATE_7_FPS: SceCameraFrameRate = 7;
pub const SCE_CAMERA_GAIN_1: SceCameraGain = 1;
pub const SCE_CAMERA_GAIN_10: SceCameraGain = 10;
pub const SCE_CAMERA_GAIN_11: SceCameraGain = 11;
pub const SCE_CAMERA_GAIN_12: SceCameraGain = 12;
pub const SCE_CAMERA_GAIN_13: SceCameraGain = 13;
pub const SCE_CAMERA_GAIN_14: SceCameraGain = 14;
pub const SCE_CAMERA_GAIN_15: SceCameraGain = 15;
pub const SCE_CAMERA_GAIN_16: SceCameraGain = 16;
pub const SCE_CAMERA_GAIN_2: SceCameraGain = 2;
pub const SCE_CAMERA_GAIN_3: SceCameraGain = 3;
pub const SCE_CAMERA_GAIN_4: SceCameraGain = 4;
pub const SCE_CAMERA_GAIN_5: SceCameraGain = 5;
pub const SCE_CAMERA_GAIN_6: SceCameraGain = 6;
pub const SCE_CAMERA_GAIN_7: SceCameraGain = 7;
pub const SCE_CAMERA_GAIN_8: SceCameraGain = 8;
pub const SCE_CAMERA_GAIN_9: SceCameraGain = 9;
pub const SCE_CAMERA_GAIN_AUTO: SceCameraGain = 0;
#[doc = "ISO100/21�"]
pub const SCE_CAMERA_ISO_100: SceCameraISO = 100;
#[doc = "ISO200/24�"]
pub const SCE_CAMERA_ISO_200: SceCameraISO = 200;
#[doc = "ISO400/27�"]
pub const SCE_CAMERA_ISO_400: SceCameraISO = 400;
#[doc = "Automatic mode"]
pub const SCE_CAMERA_ISO_AUTO: SceCameraISO = 1;
#[doc = "10 lux or below"]
pub const SCE_CAMERA_NIGHTMODE_LESS10: SceCameraNightmode = 1;
#[doc = "100 lux or below"]
pub const SCE_CAMERA_NIGHTMODE_LESS100: SceCameraNightmode = 2;
#[doc = "Disabled"]
pub const SCE_CAMERA_NIGHTMODE_OFF: SceCameraNightmode = 0;
#[doc = "100 lux or over"]
pub const SCE_CAMERA_NIGHTMODE_OVER100: SceCameraNightmode = 3;
#[doc = "Exclusive mode"]
pub const SCE_CAMERA_PRIORITY_EXCLUSIVE: SceCameraPriority = 1;
#[doc = "Share mode"]
pub const SCE_CAMERA_PRIORITY_SHARE: SceCameraPriority = 0;
#[doc = "Invalid resolution"]
pub const SCE_CAMERA_RESOLUTION_0_0: SceCameraResolution = 0;
#[doc = "QQVGA resolution"]
pub const SCE_CAMERA_RESOLUTION_160_120: SceCameraResolution = 3;
#[doc = "QCIF resolution"]
pub const SCE_CAMERA_RESOLUTION_176_144: SceCameraResolution = 5;
#[doc = "QVGA resolution"]
pub const SCE_CAMERA_RESOLUTION_320_240: SceCameraResolution = 2;
#[doc = "CIF resolution"]
pub const SCE_CAMERA_RESOLUTION_352_288: SceCameraResolution = 4;
#[doc = "PSP resolution"]
pub const SCE_CAMERA_RESOLUTION_480_272: SceCameraResolution = 6;
#[doc = "NGP resolution"]
pub const SCE_CAMERA_RESOLUTION_640_360: SceCameraResolution = 8;
#[doc = "VGA resolution"]
pub const SCE_CAMERA_RESOLUTION_640_480: SceCameraResolution = 1;
#[doc = "Flip mode"]
pub const SCE_CAMERA_REVERSE_FLIP: SceCameraReverse = 2;
#[doc = "Mirror mode"]
pub const SCE_CAMERA_REVERSE_MIRROR: SceCameraReverse = 1;
#[doc = "Mirror + Flip mode"]
pub const SCE_CAMERA_REVERSE_MIRROR_FLIP: SceCameraReverse = 3;
#[doc = "Reverse mode off"]
pub const SCE_CAMERA_REVERSE_OFF: SceCameraReverse = 0;
#[doc = "0.0"]
pub const SCE_CAMERA_SATURATION_0: SceCameraSaturation = 0;
#[doc = "1.0"]
pub const SCE_CAMERA_SATURATION_10: SceCameraSaturation = 10;
#[doc = "2.0"]
pub const SCE_CAMERA_SATURATION_20: SceCameraSaturation = 20;
#[doc = "3.0"]
pub const SCE_CAMERA_SATURATION_30: SceCameraSaturation = 30;
#[doc = "4.0"]
pub const SCE_CAMERA_SATURATION_40: SceCameraSaturation = 40;
#[doc = "0.5"]
pub const SCE_CAMERA_SATURATION_5: SceCameraSaturation = 5;
#[doc = "100%"]
pub const SCE_CAMERA_SHARPNESS_100: SceCameraSharpness = 1;
#[doc = "200%"]
pub const SCE_CAMERA_SHARPNESS_200: SceCameraSharpness = 2;
#[doc = "300%"]
pub const SCE_CAMERA_SHARPNESS_300: SceCameraSharpness = 3;
#[doc = "400%"]
pub const SCE_CAMERA_SHARPNESS_400: SceCameraSharpness = 4;
#[doc = "Automatic mode"]
pub const SCE_CAMERA_WB_AUTO: SceCameraWhiteBalance = 0;
#[doc = "Cool White Fluorescent mode"]
pub const SCE_CAMERA_WB_CWF: SceCameraWhiteBalance = 2;
#[doc = "Daylight mode"]
pub const SCE_CAMERA_WB_DAY: SceCameraWhiteBalance = 1;
#[doc = "Standard Light Source A mode"]
pub const SCE_CAMERA_WB_SLSA: SceCameraWhiteBalance = 4;
pub const SCE_COMMON_DIALOG_ERROR_BUSY: SceCommonDialogErrorCode = 2147615745;
pub const SCE_COMMON_DIALOG_ERROR_GXM_IS_UNINITIALIZED: SceCommonDialogErrorCode = 2147615798;
pub const SCE_COMMON_DIALOG_ERROR_ILLEGAL_CALLER_THREAD: SceCommonDialogErrorCode = 2147615750;
pub const SCE_COMMON_DIALOG_ERROR_IME_IN_USE: SceCommonDialogErrorCode = 2147615792;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_ARGUMENT: SceCommonDialogErrorCode = 2147615747;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_BG_COLOR: SceCommonDialogErrorCode = 2147615796;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_COLOR_FORMAT: SceCommonDialogErrorCode = 2147615776;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_DIMMER_COLOR: SceCommonDialogErrorCode = 2147615797;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_ENTER_BUTTON_ASSIGN: SceCommonDialogErrorCode =
    2147615794;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_INFOBAR_PARAM: SceCommonDialogErrorCode = 2147615795;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_LANGUAGE: SceCommonDialogErrorCode = 2147615793;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_SURFACE_RESOLUTION: SceCommonDialogErrorCode = 2147615777;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_SURFACE_STRIDE: SceCommonDialogErrorCode = 2147615778;
pub const SCE_COMMON_DIALOG_ERROR_INVALID_SURFACE_TYPE: SceCommonDialogErrorCode = 2147615779;
pub const SCE_COMMON_DIALOG_ERROR_NOT_AVAILABLE: SceCommonDialogErrorCode = 2147615752;
pub const SCE_COMMON_DIALOG_ERROR_NOT_CONFIGURED: SceCommonDialogErrorCode = 2147615751;
pub const SCE_COMMON_DIALOG_ERROR_NOT_FINISHED: SceCommonDialogErrorCode = 2147615760;
pub const SCE_COMMON_DIALOG_ERROR_NOT_IN_USE: SceCommonDialogErrorCode = 2147615761;
pub const SCE_COMMON_DIALOG_ERROR_NOT_RUNNING: SceCommonDialogErrorCode = 2147615748;
pub const SCE_COMMON_DIALOG_ERROR_NOT_SUPPORTED: SceCommonDialogErrorCode = 2147615749;
pub const SCE_COMMON_DIALOG_ERROR_NULL: SceCommonDialogErrorCode = 2147615746;
pub const SCE_COMMON_DIALOG_ERROR_UNEXPECTED_FATAL: SceCommonDialogErrorCode = 2147615871;
pub const SCE_COMMON_DIALOG_ERROR_WITHIN_SCENE: SceCommonDialogErrorCode = 2147615780;
pub const SCE_COMMON_DIALOG_MAGIC_NUMBER: u32 = 3234963721;
pub const SCE_COMMON_DIALOG_RESULT_ABORTED: SceCommonDialogResult = 2;
pub const SCE_COMMON_DIALOG_RESULT_OK: SceCommonDialogResult = 0;
pub const SCE_COMMON_DIALOG_RESULT_USER_CANCELED: SceCommonDialogResult = 1;
pub const SCE_COMMON_DIALOG_STATUS_FINISHED: SceCommonDialogStatus = 2;
pub const SCE_COMMON_DIALOG_STATUS_NONE: SceCommonDialogStatus = 0;
pub const SCE_COMMON_DIALOG_STATUS_RUNNING: SceCommonDialogStatus = 1;
pub const SCE_COMPAT_CACHE_INVALIDATE: SceCompatCacheMode = 1;
pub const SCE_COMPAT_CACHE_NONE: SceCompatCacheMode = 0;
pub const SCE_COMPAT_CACHE_WRITEBACK: SceCompatCacheMode = 2;
pub const SCE_COMPAT_PERIPHERAL_HPREMOTE_IS_HEADPHONE_EXIST: SceCompatPeripheralMode = 4;
pub const SCE_COMPAT_PERIPHERAL_POWER_GET_BATTERY_LIFETIME: SceCompatPeripheralMode = 2;
pub const SCE_COMPAT_PERIPHERAL_POWER_GET_BATTERY_PERCENT: SceCompatPeripheralMode = 3;
pub const SCE_COMPAT_PERIPHERAL_POWER_IS_SUSPEND_REQUIRED: SceCompatPeripheralMode = 1;
pub const SCE_CST_AT: u32 = 16;
pub const SCE_CST_CT: u32 = 8;
pub const SCE_CST_MODE: u32 = 1;
pub const SCE_CST_MT: u32 = 32;
pub const SCE_CST_SIZE: u32 = 4;
#[doc = "Circle button."]
pub const SCE_CTRL_CIRCLE: SceCtrlButtons = 8192;
#[doc = "Cross button."]
pub const SCE_CTRL_CROSS: SceCtrlButtons = 16384;
#[doc = "Down D-Pad button."]
pub const SCE_CTRL_DOWN: SceCtrlButtons = 64;
pub const SCE_CTRL_ERROR_FATAL: SceCtrlErrorCode = 2150891775;
pub const SCE_CTRL_ERROR_INVALID_ARG: SceCtrlErrorCode = 2150891521;
pub const SCE_CTRL_ERROR_INVALID_MODE: SceCtrlErrorCode = 2150891554;
pub const SCE_CTRL_ERROR_NO_DEVICE: SceCtrlErrorCode = 2150891552;
pub const SCE_CTRL_ERROR_NOT_SUPPORTED: SceCtrlErrorCode = 2150891553;
pub const SCE_CTRL_ERROR_PRIV_REQUIRED: SceCtrlErrorCode = 2150891522;
#[doc = "Headphone plugged in."]
pub const SCE_CTRL_HEADPHONE: SceCtrlButtons = 524288;
#[doc = "Input not available because intercepted by another application"]
pub const SCE_CTRL_INTERCEPTED: SceCtrlButtons = 65536;
#[doc = "L1 button."]
pub const SCE_CTRL_L1: SceCtrlButtons = 1024;
#[doc = "L2 button."]
pub const SCE_CTRL_L2: SceCtrlButtons = 256;
#[doc = "L3 button."]
pub const SCE_CTRL_L3: SceCtrlButtons = 2;
#[doc = "Left D-Pad button."]
pub const SCE_CTRL_LEFT: SceCtrlButtons = 128;
#[doc = "Left trigger."]
pub const SCE_CTRL_LTRIGGER: SceCtrlButtons = 256;
#[doc = "Digital buttons + Analog support."]
pub const SCE_CTRL_MODE_ANALOG: SceCtrlPadInputMode = 1;
#[doc = "Same as ::SCE_CTRL_MODE_ANALOG, but with larger range for analog sticks."]
pub const SCE_CTRL_MODE_ANALOG_WIDE: SceCtrlPadInputMode = 2;
#[doc = "Digital buttons only."]
pub const SCE_CTRL_MODE_DIGITAL: SceCtrlPadInputMode = 0;
#[doc = "Power button."]
pub const SCE_CTRL_POWER: SceCtrlButtons = 1073741824;
#[doc = "Playstation (Home) button."]
pub const SCE_CTRL_PSBUTTON: SceCtrlButtons = 65536;
#[doc = "R1 button."]
pub const SCE_CTRL_R1: SceCtrlButtons = 2048;
#[doc = "R2 button."]
pub const SCE_CTRL_R2: SceCtrlButtons = 512;
#[doc = "R3 button."]
pub const SCE_CTRL_R3: SceCtrlButtons = 4;
#[doc = "Right D-Pad button."]
pub const SCE_CTRL_RIGHT: SceCtrlButtons = 32;
#[doc = "Right trigger."]
pub const SCE_CTRL_RTRIGGER: SceCtrlButtons = 512;
#[doc = "Select button."]
pub const SCE_CTRL_SELECT: SceCtrlButtons = 1;
#[doc = "Square button."]
pub const SCE_CTRL_SQUARE: SceCtrlButtons = 32768;
#[doc = "Start button."]
pub const SCE_CTRL_START: SceCtrlButtons = 8;
#[doc = "Triangle button."]
pub const SCE_CTRL_TRIANGLE: SceCtrlButtons = 4096;
#[doc = "DualShock 3"]
pub const SCE_CTRL_TYPE_DS3: SceCtrlExternalInputMode = 4;
#[doc = "DualShock 4"]
pub const SCE_CTRL_TYPE_DS4: SceCtrlExternalInputMode = 8;
#[doc = "Physical controller for VITA"]
pub const SCE_CTRL_TYPE_PHY: SceCtrlExternalInputMode = 1;
#[doc = "Unpaired controller"]
pub const SCE_CTRL_TYPE_UNPAIRED: SceCtrlExternalInputMode = 0;
#[doc = "Virtual controller for PSTV"]
pub const SCE_CTRL_TYPE_VIRT: SceCtrlExternalInputMode = 2;
#[doc = "Up D-Pad button."]
pub const SCE_CTRL_UP: SceCtrlButtons = 16;
#[doc = "Volume down button."]
pub const SCE_CTRL_VOLDOWN: SceCtrlButtons = 2097152;
#[doc = "Volume up button."]
pub const SCE_CTRL_VOLUP: SceCtrlButtons = 1048576;
pub const SCE_CTYPE_CONTROL: SceCTypeFlag = 8;
pub const SCE_CTYPE_HEX_CASE: SceCTypeFlag = 64;
pub const SCE_CTYPE_INVISIBLE: SceCTypeFlag = 32;
pub const SCE_CTYPE_LOWERCASE: SceCTypeFlag = 2;
pub const SCE_CTYPE_NONE: SceCTypeFlag = 0;
pub const SCE_CTYPE_NUMBER: SceCTypeFlag = 4;
pub const SCE_CTYPE_SYMBOL: SceCTypeFlag = 16;
pub const SCE_CTYPE_UPPERCASE: SceCTypeFlag = 1;
pub const SCE_DBG_BREAK_ON_ASSERT: u32 = 1;
pub const SCE_DBG_LOG_LEVEL_DEBUG: SceDbgLogLevel = 1;
pub const SCE_DBG_LOG_LEVEL_ERROR: SceDbgLogLevel = 4;
pub const SCE_DBG_LOG_LEVEL_INFO: SceDbgLogLevel = 2;
pub const SCE_DBG_LOG_LEVEL_TRACE: SceDbgLogLevel = 0;
pub const SCE_DBG_LOG_LEVEL_WARNING: SceDbgLogLevel = 3;
pub const SCE_DBG_NUM_LOG_LEVELS: SceDbgLogLevel = 5;
#[doc = "Alias name"]
pub const SCE_DEV_TYPE_ALIAS: SceIoDevType = 32;
#[doc = "Block device"]
pub const SCE_DEV_TYPE_BLOCK: SceIoDevType = 4;
#[doc = "Character device"]
pub const SCE_DEV_TYPE_CHAR: SceIoDevType = 1;
#[doc = "File system device"]
pub const SCE_DEV_TYPE_FS: SceIoDevType = 16;
#[doc = "Mount point"]
pub const SCE_DEV_TYPE_MOUNTPT: SceIoDevType = 64;
#[doc = "Dummy device"]
pub const SCE_DEV_TYPE_NULL: SceIoDevType = 0;
pub const SCE_DISPLAY_ERROR_INVALID_ADDR: SceDisplayErrorCode = 2150170626;
pub const SCE_DISPLAY_ERROR_INVALID_HEAD: SceDisplayErrorCode = 2150170624;
pub const SCE_DISPLAY_ERROR_INVALID_PITCH: SceDisplayErrorCode = 2150170628;
pub const SCE_DISPLAY_ERROR_INVALID_PIXELFORMAT: SceDisplayErrorCode = 2150170627;
pub const SCE_DISPLAY_ERROR_INVALID_RESOLUTION: SceDisplayErrorCode = 2150170629;
pub const SCE_DISPLAY_ERROR_INVALID_UPDATETIMING: SceDisplayErrorCode = 2150170630;
pub const SCE_DISPLAY_ERROR_INVALID_VALUE: SceDisplayErrorCode = 2150170625;
pub const SCE_DISPLAY_ERROR_NO_FRAME_BUFFER: SceDisplayErrorCode = 2150170631;
pub const SCE_DISPLAY_ERROR_NO_OUTPUT_SIGNAL: SceDisplayErrorCode = 2150170633;
pub const SCE_DISPLAY_ERROR_NO_PIXEL_DATA: SceDisplayErrorCode = 2150170632;
pub const SCE_DISPLAY_ERROR_OK: SceDisplayErrorCode = 0;
pub const SCE_DISPLAY_PIXELFORMAT_A2B10G10R10: SceDisplayPixelFormat = 1619001344;
pub const SCE_DISPLAY_PIXELFORMAT_A8B8G8R8: SceDisplayPixelFormat = 0;
#[doc = "Buffer change effective next frame"]
pub const __SCE_DISPLAY_SETBUF: SceDisplaySetBufSync = 4294967295;
#[doc = "Buffer change effective immediately"]
pub const SCE_DISPLAY_SETBUF_IMMEDIATE: SceDisplaySetBufSync = 0;
#[doc = "Buffer change effective next frame"]
pub const SCE_DISPLAY_SETBUF_NEXTFRAME: SceDisplaySetBufSync = 1;
pub const SCE_DSI_ERROR_HEAD_NOT_ENABLED: SceDsiErrorCode = 2151613955;
pub const SCE_DSI_ERROR_INVALID_HEAD: SceDsiErrorCode = 2151613952;
pub const SCE_DSI_ERROR_INVALID_PARAM: SceDsiErrorCode = 2151613954;
pub const SCE_DSI_ERROR_INVALID_STATE: SceDsiErrorCode = 2151613953;
pub const SCE_DSI_HEAD_HDMI: SceDsiHead = 1;
pub const SCE_DSI_HEAD_OLED_LCD: SceDsiHead = 0;
pub const SCE_ERROR_NET_ADHOC_ALREADY_CREATED: ScePspnetAdhocErrorCode = 2151745306;
pub const SCE_ERROR_NET_ADHOC_ALREADY_INITIALIZED: ScePspnetAdhocErrorCode = 2151745299;
pub const SCE_ERROR_NET_ADHOC_BUSY: ScePspnetAdhocErrorCode = 2151745300;
pub const SCE_ERROR_NET_ADHOC_CONNECTION_REFUSED: ScePspnetAdhocErrorCode = 2151745304;
pub const SCE_ERROR_NET_ADHOCCTL_ALREADY_INITIALIZED: ScePspnetAdhocctlErrorCode = 2151746311;
pub const SCE_ERROR_NET_ADHOCCTL_INVALID_ARG: ScePspnetAdhocctlErrorCode = 2151746308;
pub const SCE_ERROR_NET_ADHOCCTL_NOT_INITIALIZED: ScePspnetAdhocctlErrorCode = 2151746312;
pub const SCE_ERROR_NET_ADHOC_DISCONNECTED: ScePspnetAdhocErrorCode = 2151745292;
pub const SCE_ERROR_NET_ADHOC_EXCEPTION_EVENT: ScePspnetAdhocErrorCode = 2151745303;
pub const SCE_ERROR_NET_ADHOC_INVALID_ADDR: ScePspnetAdhocErrorCode = 2151745282;
pub const SCE_ERROR_NET_ADHOC_INVALID_ALIGNMENT: ScePspnetAdhocErrorCode = 2151745309;
pub const SCE_ERROR_NET_ADHOC_INVALID_ARG: ScePspnetAdhocErrorCode = 2151745297;
pub const SCE_ERROR_NET_ADHOC_INVALID_BUFLEN: ScePspnetAdhocErrorCode = 2151745284;
pub const SCE_ERROR_NET_ADHOC_INVALID_DATALEN: ScePspnetAdhocErrorCode = 2151745285;
pub const SCE_ERROR_NET_ADHOC_INVALID_PORT: ScePspnetAdhocErrorCode = 2151745283;
pub const SCE_ERROR_NET_ADHOC_INVALID_SOCKET_ID: ScePspnetAdhocErrorCode = 2151745281;
pub const SCE_ERROR_NET_ADHOC_NO_ENTRY: ScePspnetAdhocErrorCode = 2151745302;
pub const SCE_ERROR_NET_ADHOC_NOT_CONNECTED: ScePspnetAdhocErrorCode = 2151745291;
pub const SCE_ERROR_NET_ADHOC_NOT_CREATED: ScePspnetAdhocErrorCode = 2151745308;
pub const SCE_ERROR_NET_ADHOC_NOT_ENOUGH_SPACE: ScePspnetAdhocErrorCode = 2151745286;
pub const SCE_ERROR_NET_ADHOC_NOT_IN_GAMEMODE: ScePspnetAdhocErrorCode = 2151745307;
pub const SCE_ERROR_NET_ADHOC_NOT_INITIALIZED: ScePspnetAdhocErrorCode = 2151745298;
pub const SCE_ERROR_NET_ADHOC_NOT_LISTENED: ScePspnetAdhocErrorCode = 2151745294;
pub const SCE_ERROR_NET_ADHOC_NOT_OPENED: ScePspnetAdhocErrorCode = 2151745293;
pub const SCE_ERROR_NET_ADHOC_PORT_IN_USE: ScePspnetAdhocErrorCode = 2151745290;
pub const SCE_ERROR_NET_ADHOC_PORT_NOT_AVAIL: ScePspnetAdhocErrorCode = 2151745296;
pub const SCE_ERROR_NET_ADHOC_SOCKET_ALERTED: ScePspnetAdhocErrorCode = 2151745288;
pub const SCE_ERROR_NET_ADHOC_SOCKET_DELETED: ScePspnetAdhocErrorCode = 2151745287;
pub const SCE_ERROR_NET_ADHOC_SOCKET_ID_NOT_AVAIL: ScePspnetAdhocErrorCode = 2151745295;
pub const SCE_ERROR_NET_ADHOC_THREAD_ABORTED: ScePspnetAdhocErrorCode = 2151745305;
pub const SCE_ERROR_NET_ADHOC_TIMEOUT: ScePspnetAdhocErrorCode = 2151745301;
pub const SCE_ERROR_NET_ADHOC_WOULD_BLOCK: ScePspnetAdhocErrorCode = 2151745289;
#[doc = "Use SCE_KERNEL_ATTR_OPENABLE"]
pub const SCE_EVENT_OPENABLE: SceEventFlagAttributes = 128;
#[doc = "Use SCE_KERNEL_ATTR_THREAD_FIFO"]
pub const SCE_EVENT_THREAD_FIFO: SceEventFlagAttributes = 0;
#[doc = "Use SCE_KERNEL_ATTR_THREAD_PRIO"]
pub const SCE_EVENT_THREAD_PRIO: SceEventFlagAttributes = 8192;
#[doc = "Wait for all bits in the pattern to be set"]
pub const SCE_EVENT_WAITAND: SceEventFlagWaitTypes = 0;
#[doc = "Clear all the bits when it matches"]
pub const SCE_EVENT_WAITCLEAR: SceEventFlagWaitTypes = 2;
#[doc = "Clear the wait pattern when it matches"]
pub const SCE_EVENT_WAITCLEAR_PAT: SceEventFlagWaitTypes = 4;
#[doc = "Sync object can be waited upon by multiple threads."]
pub const SCE_EVENT_WAITMULTIPLE: SceEventFlagAttributes = 4096;
#[doc = "Wait for one or more bits in the pattern to be set"]
pub const SCE_EVENT_WAITOR: SceEventFlagWaitTypes = 1;
#[doc = "Sync object can only be waited upon by one thread."]
pub const SCE_EVENT_WAITSINGLE: SceEventFlagAttributes = 0;
pub const SCE_EXCP_DABT: SceExcpKind = 4;
pub const SCE_EXCP_FIQ: SceExcpKind = 7;
pub const SCE_EXCP_IRQ: SceExcpKind = 6;
#[doc = "Exception handled"]
pub const SCE_EXCPMGR_EXCEPTION_HANDLED: SceExcpHandlingCode = 0;
pub const SCE_EXCPMGR_EXCEPTION_HANDLING_CODE_2: SceExcpHandlingCode = 2;
pub const SCE_EXCPMGR_EXCEPTION_HANDLING_CODE_4: SceExcpHandlingCode = 4;
#[doc = "Exception not handled - kills app with C2-12828-1"]
pub const SCE_EXCPMGR_EXCEPTION_NOT_HANDLED: SceExcpHandlingCode = 1;
#[doc = "Fatal exception - panics the kernel"]
pub const SCE_EXCPMGR_EXCEPTION_NOT_HANDLED_FATAL: SceExcpHandlingCode = 3;
pub const SCE_EXCP_PABT: SceExcpKind = 3;
pub const SCE_EXCP_RESET: SceExcpKind = 0;
pub const SCE_EXCP_SVC: SceExcpKind = 2;
pub const SCE_EXCP_UNDEF_INSTRUCTION: SceExcpKind = 1;
pub const SCE_EXCP_UNUSED: SceExcpKind = 5;
pub const SCE_FALSE: _bindgen_ty_1 = 0;
pub const SCE_FIBER_ERROR_AGAIN: SceFiberErrorCode = 2153316360;
pub const SCE_FIBER_ERROR_ALIGNMENT: SceFiberErrorCode = 2153316354;
pub const SCE_FIBER_ERROR_BUSY: SceFiberErrorCode = 2153316359;
pub const SCE_FIBER_ERROR_FATAL: SceFiberErrorCode = 2153316361;
pub const SCE_FIBER_ERROR_INVALID: SceFiberErrorCode = 2153316356;
pub const SCE_FIBER_ERROR_NULL: SceFiberErrorCode = 2153316353;
pub const SCE_FIBER_ERROR_PERMISSION: SceFiberErrorCode = 2153316357;
pub const SCE_FIBER_ERROR_RANGE: SceFiberErrorCode = 2153316355;
pub const SCE_FIBER_ERROR_STATE: SceFiberErrorCode = 2153316358;
pub const SCE_FIOS2_OVERLAY_PATH_MAX_LENGTH: u32 = 291;
pub const SCE_FIOS2_OVERLAY_PATH_SIZE: u32 = 292;
pub const SCE_FIOS_OVERLAY_TYPE_NEWER: SceFiosOverlayType = 2;
pub const SCE_FIOS_OVERLAY_TYPE_OPAQUE: SceFiosOverlayType = 0;
pub const SCE_FIOS_OVERLAY_TYPE_TRANSLUCENT: SceFiosOverlayType = 1;
pub const SCE_FIOS_OVERLAY_TYPE_WRITABLE: SceFiosOverlayType = 3;
pub const SCE_FONT_ERROR_HANDLER_OPEN_FAILED: SceFontErrorCode = 2152071173;
pub const SCE_FONT_ERROR_INVALID_FONT_DATA: SceFontErrorCode = 2152071178;
pub const SCE_FONT_ERROR_INVALID_LIBID: SceFontErrorCode = 2152071170;
pub const SCE_FONT_ERROR_INVALID_PARAMETER: SceFontErrorCode = 2152071171;
pub const SCE_FONT_ERROR_OUT_OF_MEMORY: SceFontErrorCode = 2152071169;
pub const SCE_FONT_ERROR_TOO_MANY_OPEN_FONTS: SceFontErrorCode = 2152071177;
pub const SCE_FONT_FAMILY_DEFAULT: SceFontFamilyCode = 0;
pub const SCE_FONT_FAMILY_ROUNDED: SceFontFamilyCode = 3;
pub const SCE_FONT_FAMILY_SANS_SERIF: SceFontFamilyCode = 1;
pub const SCE_FONT_FAMILY_SERIF: SceFontFamilyCode = 2;
pub const SCE_FONT_LANGUAGE_CHINESE: SceFontLanguageCode = 4;
pub const SCE_FONT_LANGUAGE_CJK: SceFontLanguageCode = 5;
pub const SCE_FONT_LANGUAGE_DEFAULT: SceFontLanguageCode = 0;
pub const SCE_FONT_LANGUAGE_JAPANESE: SceFontLanguageCode = 1;
pub const SCE_FONT_LANGUAGE_KOREAN: SceFontLanguageCode = 3;
pub const SCE_FONT_LANGUAGE_LATIN: SceFontLanguageCode = 2;
#[doc = "1 pixel in 3 bytes (RGB)"]
pub const SCE_FONT_PIXELFORMAT_24: SceFontPixelFormatCode = 3;
#[doc = "1 pixel in 4 bytes (RGBA)"]
pub const SCE_FONT_PIXELFORMAT_32: SceFontPixelFormatCode = 4;
#[doc = "2 pixels packed in 1 byte (natural order)"]
pub const SCE_FONT_PIXELFORMAT_4: SceFontPixelFormatCode = 0;
#[doc = "2 pixels packed in 1 byte (reversed order)"]
pub const SCE_FONT_PIXELFORMAT_4_REV: SceFontPixelFormatCode = 1;
#[doc = "1 pixel in 1 byte"]
pub const SCE_FONT_PIXELFORMAT_8: SceFontPixelFormatCode = 2;
pub const SCE_FONT_STYLE_B: SceFontStyleCode = 104;
pub const SCE_FONT_STYLE_BLACK: SceFontStyleCode = 7;
pub const SCE_FONT_STYLE_BLACK_ITALIC: SceFontStyleCode = 8;
pub const SCE_FONT_STYLE_BOLD: SceFontStyleCode = 5;
pub const SCE_FONT_STYLE_BOLD_ITALIC: SceFontStyleCode = 6;
#[doc = "Demi-Bold / semi-bold"]
pub const SCE_FONT_STYLE_DB: SceFontStyleCode = 103;
pub const SCE_FONT_STYLE_DEFAULT: SceFontStyleCode = 0;
pub const SCE_FONT_STYLE_EB: SceFontStyleCode = 105;
pub const SCE_FONT_STYLE_ITALIC: SceFontStyleCode = 2;
pub const SCE_FONT_STYLE_L: SceFontStyleCode = 101;
pub const SCE_FONT_STYLE_M: SceFontStyleCode = 102;
pub const SCE_FONT_STYLE_NARROW: SceFontStyleCode = 3;
pub const SCE_FONT_STYLE_NARROW_ITALIC: SceFontStyleCode = 4;
pub const SCE_FONT_STYLE_REGULAR: SceFontStyleCode = 1;
pub const SCE_FONT_STYLE_UB: SceFontStyleCode = 106;
pub const SCE_GPIO_ERROR_INVALID_BUS: SceGpioErrorCode = 2151612672;
pub const SCE_GPIO_ERROR_INVALID_MODE: SceGpioErrorCode = 2151612674;
pub const SCE_GPIO_ERROR_INVALID_PORT: SceGpioErrorCode = 2151612673;
pub const SCE_GPIO_PORT_MASK_LED_GAMECARD: SceGpioPortMasks = 64;
pub const SCE_GPIO_PORT_MASK_LED_PS_BUTTON: SceGpioPortMasks = 128;
pub const SCE_GPIO_PORT_MODE_INPUT: SceGpioPortMode = 1;
pub const SCE_GPIO_PORT_MODE_OUTPUT: SceGpioPortMode = 0;
pub const SCE_GUID_ALL_PROCESS: _bindgen_ty_2 = 65569;
pub const SCE_GUID_CLEANER_THREAD: _bindgen_ty_2 = 65559;
pub const SCE_GUID_DUMMY_PROCESS_GAME: _bindgen_ty_2 = 65555;
pub const SCE_GUID_DUMMY_PROCESS_SYSTEM: _bindgen_ty_2 = 65557;
pub const SCE_GUID_GLOBAL_WORK_QUEUE: _bindgen_ty_2 = 65571;
pub const SCE_GUID_GUID_ENTRY_HEAP: _bindgen_ty_2 = 65539;
pub const SCE_GUID_IDLE_THREAD_0: _bindgen_ty_2 = 65561;
pub const SCE_GUID_IDLE_THREAD_1: _bindgen_ty_2 = 65563;
pub const SCE_GUID_IDLE_THREAD_2: _bindgen_ty_2 = 65565;
pub const SCE_GUID_IDLE_THREAD_3: _bindgen_ty_2 = 65567;
pub const SCE_GUID_KERNEL_ADDRESS_SPACE: _bindgen_ty_2 = 65543;
pub const SCE_GUID_KERNEL_FIXED_HEAP_128B: _bindgen_ty_2 = 65595;
pub const SCE_GUID_KERNEL_FIXED_HEAP_16B: _bindgen_ty_2 = 65587;
pub const SCE_GUID_KERNEL_FIXED_HEAP_256B: _bindgen_ty_2 = 65597;
pub const SCE_GUID_KERNEL_FIXED_HEAP_32B: _bindgen_ty_2 = 65589;
pub const SCE_GUID_KERNEL_FIXED_HEAP_48B: _bindgen_ty_2 = 65591;
pub const SCE_GUID_KERNEL_FIXED_HEAP_512B: _bindgen_ty_2 = 65599;
pub const SCE_GUID_KERNEL_FIXED_HEAP_64B: _bindgen_ty_2 = 65593;
pub const SCE_GUID_KERNEL_FIXED_HEAP_L2_OBJECT: _bindgen_ty_2 = 65601;
pub const SCE_GUID_KERNEL_HEAP: _bindgen_ty_2 = 65547;
pub const SCE_GUID_KERNEL_HEAP_TOOL: _bindgen_ty_2 = 65579;
pub const SCE_GUID_KERNEL_HEAP_UNCACHE: _bindgen_ty_2 = 65549;
pub const SCE_GUID_KERNEL_PROCESS_ID: _bindgen_ty_2 = 65541;
pub const SCE_GUID_PART_CDRAM: _bindgen_ty_2 = 65607;
pub const SCE_GUID_PART_IO: _bindgen_ty_2 = 65605;
pub const SCE_GUID_PART_KMP: _bindgen_ty_2 = 65615;
pub const SCE_GUID_PART_ROOT: _bindgen_ty_2 = 65545;
pub const SCE_GUID_PART_ROOT_TOOL: _bindgen_ty_2 = 65621;
pub const SCE_GUID_PART_ROOT_TOOL_UNCACHE: _bindgen_ty_2 = 65623;
pub const SCE_GUID_PART_ROOT_UNCACHE: _bindgen_ty_2 = 65613;
pub const SCE_GUID_PART_ROOT_UNCACHE_GPU_GAME: _bindgen_ty_2 = 65617;
pub const SCE_GUID_PART_TMP: _bindgen_ty_2 = 65611;
pub const SCE_GUID_PART_TMP_FS_GAME: _bindgen_ty_2 = 65619;
pub const SCE_GUID_PART_USER_SHARED: _bindgen_ty_2 = 65603;
pub const SCE_GUID_PHYMEM_PART_KERNEL: _bindgen_ty_2 = 65551;
pub const SCE_GUID_PHYMEM_PART_TOOL: _bindgen_ty_2 = 65553;
pub const SCE_GUID_PROCESS_BUDGET_FULL_GAME: _bindgen_ty_2 = 65629;
pub const SCE_GUID_PROCESS_BUDGET_KERNEL: _bindgen_ty_2 = 65625;
pub const SCE_GUID_PROCESS_BUDGET_SHELL: _bindgen_ty_2 = 65627;
pub const SCE_GUID_RESERVED_29: _bindgen_ty_2 = 65577;
pub const SCE_GUID_RESERVED_2D: _bindgen_ty_2 = 65581;
pub const SCE_GUID_RESERVED_2F: _bindgen_ty_2 = 65583;
pub const SCE_GUID_RESERVED_31: _bindgen_ty_2 = 65585;
pub const SCE_GUID_RESERVED_49: _bindgen_ty_2 = 65609;
pub const SCE_GUID_RESERVED_5F: _bindgen_ty_2 = 65631;
pub const SCE_GUID_SYSROOT: _bindgen_ty_2 = 65537;
pub const SCE_GUID_THREAD_ID_PROCESS_ALL: _bindgen_ty_2 = 65575;
pub const SCE_GUID_THREAD_ID_SYSTEM_ALL: _bindgen_ty_2 = 65573;
pub const SCE_GXM_ATTRIBUTE_FORMAT_F16: SceGxmAttributeFormat = 8;
pub const SCE_GXM_ATTRIBUTE_FORMAT_F32: SceGxmAttributeFormat = 9;
pub const SCE_GXM_ATTRIBUTE_FORMAT_S16: SceGxmAttributeFormat = 3;
pub const SCE_GXM_ATTRIBUTE_FORMAT_S16N: SceGxmAttributeFormat = 7;
pub const SCE_GXM_ATTRIBUTE_FORMAT_S8: SceGxmAttributeFormat = 1;
pub const SCE_GXM_ATTRIBUTE_FORMAT_S8N: SceGxmAttributeFormat = 5;
pub const SCE_GXM_ATTRIBUTE_FORMAT_U16: SceGxmAttributeFormat = 2;
pub const SCE_GXM_ATTRIBUTE_FORMAT_U16N: SceGxmAttributeFormat = 6;
pub const SCE_GXM_ATTRIBUTE_FORMAT_U8: SceGxmAttributeFormat = 0;
pub const SCE_GXM_ATTRIBUTE_FORMAT_U8N: SceGxmAttributeFormat = 4;
pub const SCE_GXM_ATTRIBUTE_FORMAT_UNTYPED: SceGxmAttributeFormat = 10;
pub const SCE_GXM_BLEND_FACTOR_DST_ALPHA: SceGxmBlendFactor = 8;
pub const SCE_GXM_BLEND_FACTOR_DST_ALPHA_SATURATE: SceGxmBlendFactor = 11;
pub const SCE_GXM_BLEND_FACTOR_DST_COLOR: SceGxmBlendFactor = 6;
pub const SCE_GXM_BLEND_FACTOR_ONE: SceGxmBlendFactor = 1;
pub const SCE_GXM_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: SceGxmBlendFactor = 9;
pub const SCE_GXM_BLEND_FACTOR_ONE_MINUS_DST_COLOR: SceGxmBlendFactor = 7;
pub const SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: SceGxmBlendFactor = 5;
pub const SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: SceGxmBlendFactor = 3;
pub const SCE_GXM_BLEND_FACTOR_SRC_ALPHA: SceGxmBlendFactor = 4;
pub const SCE_GXM_BLEND_FACTOR_SRC_ALPHA_SATURATE: SceGxmBlendFactor = 10;
pub const SCE_GXM_BLEND_FACTOR_SRC_COLOR: SceGxmBlendFactor = 2;
pub const SCE_GXM_BLEND_FACTOR_ZERO: SceGxmBlendFactor = 0;
pub const SCE_GXM_BLEND_FUNC_ADD: SceGxmBlendFunc = 1;
pub const SCE_GXM_BLEND_FUNC_MAX: SceGxmBlendFunc = 5;
pub const SCE_GXM_BLEND_FUNC_MIN: SceGxmBlendFunc = 4;
pub const SCE_GXM_BLEND_FUNC_NONE: SceGxmBlendFunc = 0;
pub const SCE_GXM_BLEND_FUNC_REVERSE_SUBTRACT: SceGxmBlendFunc = 3;
pub const SCE_GXM_BLEND_FUNC_SUBTRACT: SceGxmBlendFunc = 2;
pub const SCE_GXM_COLOR_BASE_FORMAT_F11F11F10: SceGxmColorBaseFormat = 553648128;
pub const SCE_GXM_COLOR_BASE_FORMAT_F16: SceGxmColorBaseFormat = 4026531840;
pub const SCE_GXM_COLOR_BASE_FORMAT_F16F16: SceGxmColorBaseFormat = 8388608;
pub const SCE_GXM_COLOR_BASE_FORMAT_F16F16F16F16: SceGxmColorBaseFormat = 16777216;
pub const SCE_GXM_COLOR_BASE_FORMAT_F32: SceGxmColorBaseFormat = 276824064;
pub const SCE_GXM_COLOR_BASE_FORMAT_F32F32: SceGxmColorBaseFormat = 285212672;
pub const SCE_GXM_COLOR_BASE_FORMAT_S16: SceGxmColorBaseFormat = 545259520;
pub const SCE_GXM_COLOR_BASE_FORMAT_S16S16: SceGxmColorBaseFormat = 813694976;
pub const SCE_GXM_COLOR_BASE_FORMAT_S5S5U6: SceGxmColorBaseFormat = 2692743168;
pub const SCE_GXM_COLOR_BASE_FORMAT_S8: SceGxmColorBaseFormat = 2424307712;
pub const SCE_GXM_COLOR_BASE_FORMAT_S8S8: SceGxmColorBaseFormat = 3229614080;
pub const SCE_GXM_COLOR_BASE_FORMAT_S8S8S8S8: SceGxmColorBaseFormat = 3766484992;
pub const SCE_GXM_COLOR_BASE_FORMAT_SE5M9M9M9: SceGxmColorBaseFormat = 822083584;
pub const SCE_GXM_COLOR_BASE_FORMAT_U16: SceGxmColorBaseFormat = 1082130432;
pub const SCE_GXM_COLOR_BASE_FORMAT_U16U16: SceGxmColorBaseFormat = 1350565888;
pub const SCE_GXM_COLOR_BASE_FORMAT_U1U5U5U5: SceGxmColorBaseFormat = 1073741824;
pub const SCE_GXM_COLOR_BASE_FORMAT_U2F10F10F10: SceGxmColorBaseFormat = 1090519040;
pub const SCE_GXM_COLOR_BASE_FORMAT_U2U10U10U10: SceGxmColorBaseFormat = 1619001344;
pub const SCE_GXM_COLOR_BASE_FORMAT_U4U4U4U4: SceGxmColorBaseFormat = 1342177280;
pub const SCE_GXM_COLOR_BASE_FORMAT_U5U6U5: SceGxmColorBaseFormat = 805306368;
pub const SCE_GXM_COLOR_BASE_FORMAT_U8: SceGxmColorBaseFormat = 2155872256;
pub const SCE_GXM_COLOR_BASE_FORMAT_U8S8S8U8: SceGxmColorBaseFormat = 3498049536;
pub const SCE_GXM_COLOR_BASE_FORMAT_U8U3U3U2: SceGxmColorBaseFormat = 1610612736;
pub const SCE_GXM_COLOR_BASE_FORMAT_U8U8: SceGxmColorBaseFormat = 2961178624;
pub const SCE_GXM_COLOR_BASE_FORMAT_U8U8U8: SceGxmColorBaseFormat = 268435456;
pub const SCE_GXM_COLOR_BASE_FORMAT_U8U8U8U8: SceGxmColorBaseFormat = 0;
pub const SCE_GXM_COLOR_FORMAT_A1R5G5B5: SceGxmColorFormat = 1074790400;
pub const SCE_GXM_COLOR_FORMAT_A4R4G4B4: SceGxmColorFormat = 1343225856;
pub const SCE_GXM_COLOR_FORMAT_A8: SceGxmColorFormat = 2156920832;
pub const SCE_GXM_COLOR_FORMAT_A8B8G8R8: SceGxmColorFormat = 0;
pub const SCE_GXM_COLOR_FORMAT_A8R8G8B8: SceGxmColorFormat = 1048576;
pub const SCE_GXM_COLOR_FORMAT_F10F10F10U2_BGRA: SceGxmColorFormat = 1093664768;
pub const SCE_GXM_COLOR_FORMAT_F10F10F10U2_RGBA: SceGxmColorFormat = 1092616192;
pub const SCE_GXM_COLOR_FORMAT_F10F11F11_BGR: SceGxmColorFormat = 553648128;
pub const SCE_GXM_COLOR_FORMAT_F11F11F10_RGB: SceGxmColorFormat = 554696704;
pub const SCE_GXM_COLOR_FORMAT_F16F16F16F16_ABGR: SceGxmColorFormat = 16777216;
pub const SCE_GXM_COLOR_FORMAT_F16F16F16F16_ARGB: SceGxmColorFormat = 17825792;
pub const SCE_GXM_COLOR_FORMAT_F16F16F16F16_BGRA: SceGxmColorFormat = 19922944;
pub const SCE_GXM_COLOR_FORMAT_F16F16F16F16_RGBA: SceGxmColorFormat = 18874368;
pub const SCE_GXM_COLOR_FORMAT_F16F16_GR: SceGxmColorFormat = 8388608;
pub const SCE_GXM_COLOR_FORMAT_F16F16_RG: SceGxmColorFormat = 9437184;
pub const SCE_GXM_COLOR_FORMAT_F16_G: SceGxmColorFormat = 4027580416;
pub const SCE_GXM_COLOR_FORMAT_F16_R: SceGxmColorFormat = 4026531840;
pub const SCE_GXM_COLOR_FORMAT_F32F32_GR: SceGxmColorFormat = 285212672;
pub const SCE_GXM_COLOR_FORMAT_F32F32_RG: SceGxmColorFormat = 286261248;
pub const SCE_GXM_COLOR_FORMAT_F32_R: SceGxmColorFormat = 276824064;
pub const SCE_GXM_COLOR_FORMAT_R5G6B5: SceGxmColorFormat = 806354944;
pub const SCE_GXM_COLOR_FORMAT_S16_G: SceGxmColorFormat = 546308096;
pub const SCE_GXM_COLOR_FORMAT_S16_R: SceGxmColorFormat = 545259520;
pub const SCE_GXM_COLOR_FORMAT_S16S16_GR: SceGxmColorFormat = 813694976;
pub const SCE_GXM_COLOR_FORMAT_S16S16_RG: SceGxmColorFormat = 814743552;
pub const SCE_GXM_COLOR_FORMAT_S5S5U6_RGB: SceGxmColorFormat = 2693791744;
pub const SCE_GXM_COLOR_FORMAT_S8_A: SceGxmColorFormat = 2425356288;
pub const SCE_GXM_COLOR_FORMAT_S8_R: SceGxmColorFormat = 2424307712;
pub const SCE_GXM_COLOR_FORMAT_S8S8_AR: SceGxmColorFormat = 3232759808;
pub const SCE_GXM_COLOR_FORMAT_S8S8_GR: SceGxmColorFormat = 3229614080;
pub const SCE_GXM_COLOR_FORMAT_S8S8_RA: SceGxmColorFormat = 3231711232;
pub const SCE_GXM_COLOR_FORMAT_S8S8_RG: SceGxmColorFormat = 3230662656;
pub const SCE_GXM_COLOR_FORMAT_S8S8S8S8_ABGR: SceGxmColorFormat = 3766484992;
pub const SCE_GXM_COLOR_FORMAT_S8S8S8S8_ARGB: SceGxmColorFormat = 3767533568;
pub const SCE_GXM_COLOR_FORMAT_S8S8S8S8_BGRA: SceGxmColorFormat = 3769630720;
pub const SCE_GXM_COLOR_FORMAT_S8S8S8S8_RGBA: SceGxmColorFormat = 3768582144;
pub const SCE_GXM_COLOR_FORMAT_S8S8U8U8_BGRA: SceGxmColorFormat = 3501195264;
pub const SCE_GXM_COLOR_FORMAT_SE5M9M9M9_BGR: SceGxmColorFormat = 822083584;
pub const SCE_GXM_COLOR_FORMAT_SE5M9M9M9_RGB: SceGxmColorFormat = 823132160;
pub const SCE_GXM_COLOR_FORMAT_U10U10U10U2_BGRA: SceGxmColorFormat = 1622147072;
pub const SCE_GXM_COLOR_FORMAT_U10U10U10U2_RGBA: SceGxmColorFormat = 1621098496;
pub const SCE_GXM_COLOR_FORMAT_U16_G: SceGxmColorFormat = 1083179008;
pub const SCE_GXM_COLOR_FORMAT_U16_R: SceGxmColorFormat = 1082130432;
pub const SCE_GXM_COLOR_FORMAT_U16U16_GR: SceGxmColorFormat = 1350565888;
pub const SCE_GXM_COLOR_FORMAT_U16U16_RG: SceGxmColorFormat = 1351614464;
pub const SCE_GXM_COLOR_FORMAT_U1U5U5U5_ABGR: SceGxmColorFormat = 1073741824;
pub const SCE_GXM_COLOR_FORMAT_U1U5U5U5_ARGB: SceGxmColorFormat = 1074790400;
pub const SCE_GXM_COLOR_FORMAT_U2F10F10F10_ABGR: SceGxmColorFormat = 1090519040;
pub const SCE_GXM_COLOR_FORMAT_U2F10F10F10_ARGB: SceGxmColorFormat = 1091567616;
pub const SCE_GXM_COLOR_FORMAT_U2U10U10U10_ABGR: SceGxmColorFormat = 1619001344;
pub const SCE_GXM_COLOR_FORMAT_U2U10U10U10_ARGB: SceGxmColorFormat = 1620049920;
pub const SCE_GXM_COLOR_FORMAT_U4U4U4U4_ABGR: SceGxmColorFormat = 1342177280;
pub const SCE_GXM_COLOR_FORMAT_U4U4U4U4_ARGB: SceGxmColorFormat = 1343225856;
pub const SCE_GXM_COLOR_FORMAT_U4U4U4U4_BGRA: SceGxmColorFormat = 1345323008;
pub const SCE_GXM_COLOR_FORMAT_U4U4U4U4_RGBA: SceGxmColorFormat = 1344274432;
pub const SCE_GXM_COLOR_FORMAT_U5U5U5U1_BGRA: SceGxmColorFormat = 1076887552;
pub const SCE_GXM_COLOR_FORMAT_U5U5U5U1_RGBA: SceGxmColorFormat = 1075838976;
pub const SCE_GXM_COLOR_FORMAT_U5U6U5_BGR: SceGxmColorFormat = 805306368;
pub const SCE_GXM_COLOR_FORMAT_U5U6U5_RGB: SceGxmColorFormat = 806354944;
pub const SCE_GXM_COLOR_FORMAT_U6S5S5_BGR: SceGxmColorFormat = 2692743168;
pub const SCE_GXM_COLOR_FORMAT_U8_A: SceGxmColorFormat = 2156920832;
pub const SCE_GXM_COLOR_FORMAT_U8_R: SceGxmColorFormat = 2155872256;
pub const SCE_GXM_COLOR_FORMAT_U8S8S8U8_ABGR: SceGxmColorFormat = 3498049536;
pub const SCE_GXM_COLOR_FORMAT_U8S8S8U8_RGBA: SceGxmColorFormat = 3500146688;
pub const SCE_GXM_COLOR_FORMAT_U8U3U3U2_ARGB: SceGxmColorFormat = 1610612736;
pub const SCE_GXM_COLOR_FORMAT_U8U8_AR: SceGxmColorFormat = 2964324352;
pub const SCE_GXM_COLOR_FORMAT_U8U8_GR: SceGxmColorFormat = 2961178624;
pub const SCE_GXM_COLOR_FORMAT_U8U8_RA: SceGxmColorFormat = 2963275776;
pub const SCE_GXM_COLOR_FORMAT_U8U8_RG: SceGxmColorFormat = 2962227200;
pub const SCE_GXM_COLOR_FORMAT_U8U8S8S8_ARGB: SceGxmColorFormat = 3499098112;
pub const SCE_GXM_COLOR_FORMAT_U8U8U8_BGR: SceGxmColorFormat = 268435456;
pub const SCE_GXM_COLOR_FORMAT_U8U8U8_RGB: SceGxmColorFormat = 269484032;
pub const SCE_GXM_COLOR_FORMAT_U8U8U8U8_ABGR: SceGxmColorFormat = 0;
pub const SCE_GXM_COLOR_FORMAT_U8U8U8U8_ARGB: SceGxmColorFormat = 1048576;
pub const SCE_GXM_COLOR_FORMAT_U8U8U8U8_BGRA: SceGxmColorFormat = 3145728;
pub const SCE_GXM_COLOR_FORMAT_U8U8U8U8_RGBA: SceGxmColorFormat = 2097152;
pub const SCE_GXM_COLOR_MASK_A: SceGxmColorMask = 1;
pub const SCE_GXM_COLOR_MASK_ALL: SceGxmColorMask = 15;
pub const SCE_GXM_COLOR_MASK_B: SceGxmColorMask = 8;
pub const SCE_GXM_COLOR_MASK_G: SceGxmColorMask = 4;
pub const SCE_GXM_COLOR_MASK_NONE: SceGxmColorMask = 0;
pub const SCE_GXM_COLOR_MASK_R: SceGxmColorMask = 2;
pub const SCE_GXM_COLOR_SURFACE_ALIGNMENT: u32 = 4;
pub const SCE_GXM_COLOR_SURFACE_DITHER_DISABLED: SceGxmColorSurfaceDitherMode = 0;
pub const SCE_GXM_COLOR_SURFACE_DITHER_ENABLED: SceGxmColorSurfaceDitherMode = 8;
pub const SCE_GXM_COLOR_SURFACE_GAMMA_BGR: SceGxmColorSurfaceGammaMode = 4096;
pub const SCE_GXM_COLOR_SURFACE_GAMMA_GR: SceGxmColorSurfaceGammaMode = 12288;
pub const SCE_GXM_COLOR_SURFACE_GAMMA_NONE: SceGxmColorSurfaceGammaMode = 0;
pub const SCE_GXM_COLOR_SURFACE_GAMMA_R: SceGxmColorSurfaceGammaMode = 4096;
pub const SCE_GXM_COLOR_SURFACE_LINEAR: SceGxmColorSurfaceType = 0;
pub const SCE_GXM_COLOR_SURFACE_SCALE_MSAA_DOWNSCALE: SceGxmColorSurfaceScaleMode = 1;
pub const SCE_GXM_COLOR_SURFACE_SCALE_NONE: SceGxmColorSurfaceScaleMode = 0;
pub const SCE_GXM_COLOR_SURFACE_SWIZZLED: SceGxmColorSurfaceType = 134217728;
pub const SCE_GXM_COLOR_SURFACE_TILED: SceGxmColorSurfaceType = 67108864;
pub const SCE_GXM_COLOR_SWIZZLE1_A: SceGxmColorSwizzle1Mode = 1048576;
pub const SCE_GXM_COLOR_SWIZZLE1_G: SceGxmColorSwizzle1Mode = 1048576;
pub const SCE_GXM_COLOR_SWIZZLE1_R: SceGxmColorSwizzle1Mode = 0;
pub const SCE_GXM_COLOR_SWIZZLE2_AR: SceGxmColorSwizzle2Mode = 3145728;
pub const SCE_GXM_COLOR_SWIZZLE2_GR: SceGxmColorSwizzle2Mode = 0;
pub const SCE_GXM_COLOR_SWIZZLE2_RA: SceGxmColorSwizzle2Mode = 2097152;
pub const SCE_GXM_COLOR_SWIZZLE2_RG: SceGxmColorSwizzle2Mode = 1048576;
pub const SCE_GXM_COLOR_SWIZZLE3_BGR: SceGxmColorSwizzle3Mode = 0;
pub const SCE_GXM_COLOR_SWIZZLE3_RGB: SceGxmColorSwizzle3Mode = 1048576;
pub const SCE_GXM_COLOR_SWIZZLE4_ABGR: SceGxmColorSwizzle4Mode = 0;
pub const SCE_GXM_COLOR_SWIZZLE4_ARGB: SceGxmColorSwizzle4Mode = 1048576;
pub const SCE_GXM_COLOR_SWIZZLE4_BGRA: SceGxmColorSwizzle4Mode = 3145728;
pub const SCE_GXM_COLOR_SWIZZLE4_RGBA: SceGxmColorSwizzle4Mode = 2097152;
pub const SCE_GXM_CULL_CCW: SceGxmCullMode = 2;
pub const SCE_GXM_CULL_CW: SceGxmCullMode = 1;
pub const SCE_GXM_CULL_NONE: SceGxmCullMode = 0;
pub const SCE_GXM_DEFAULT_FRAGMENT_RING_BUFFER_SIZE: u32 = 524288;
pub const SCE_GXM_DEFAULT_FRAGMENT_USSE_RING_BUFFER_SIZE: u32 = 16384;
pub const SCE_GXM_DEFAULT_PARAMETER_BUFFER_SIZE: u32 = 16777216;
pub const SCE_GXM_DEFAULT_VDM_RING_BUFFER_SIZE: u32 = 131072;
pub const SCE_GXM_DEFAULT_VERTEX_RING_BUFFER_SIZE: u32 = 2097152;
pub const SCE_GXM_DEPTH_FUNC_ALWAYS: SceGxmDepthFunc = 29360128;
pub const SCE_GXM_DEPTH_FUNC_EQUAL: SceGxmDepthFunc = 8388608;
pub const SCE_GXM_DEPTH_FUNC_GREATER: SceGxmDepthFunc = 16777216;
pub const SCE_GXM_DEPTH_FUNC_GREATER_EQUAL: SceGxmDepthFunc = 25165824;
pub const SCE_GXM_DEPTH_FUNC_LESS: SceGxmDepthFunc = 4194304;
pub const SCE_GXM_DEPTH_FUNC_LESS_EQUAL: SceGxmDepthFunc = 12582912;
pub const SCE_GXM_DEPTH_FUNC_NEVER: SceGxmDepthFunc = 0;
pub const SCE_GXM_DEPTH_FUNC_NOT_EQUAL: SceGxmDepthFunc = 20971520;
pub const SCE_GXM_DEPTH_STENCIL_FORCE_LOAD_DISABLED: SceGxmDepthStencilForceLoadMode = 0;
pub const SCE_GXM_DEPTH_STENCIL_FORCE_LOAD_ENABLED: SceGxmDepthStencilForceLoadMode = 2;
pub const SCE_GXM_DEPTH_STENCIL_FORCE_STORE_DISABLED: SceGxmDepthStencilForceStoreMode = 0;
pub const SCE_GXM_DEPTH_STENCIL_FORCE_STORE_ENABLED: SceGxmDepthStencilForceStoreMode = 4;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_D16: SceGxmDepthStencilFormat = 38027264;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_DF32: SceGxmDepthStencilFormat = 278528;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_DF32M: SceGxmDepthStencilFormat = 835584;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_DF32M_S8: SceGxmDepthStencilFormat = 974848;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_DF32_S8: SceGxmDepthStencilFormat = 417792;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_S8: SceGxmDepthStencilFormat = 139264;
pub const SCE_GXM_DEPTH_STENCIL_FORMAT_S8D24: SceGxmDepthStencilFormat = 19292160;
pub const SCE_GXM_DEPTHSTENCIL_SURFACE_ALIGNMENT: u32 = 16;
pub const SCE_GXM_DEPTH_STENCIL_SURFACE_LINEAR: SceGxmDepthStencilSurfaceType = 0;
pub const SCE_GXM_DEPTH_STENCIL_SURFACE_TILED: SceGxmDepthStencilSurfaceType = 69632;
pub const SCE_GXM_DEPTH_WRITE_DISABLED: SceGxmDepthWriteMode = 1048576;
pub const SCE_GXM_DEPTH_WRITE_ENABLED: SceGxmDepthWriteMode = 0;
pub const SCE_GXM_EDGE_ENABLE_01: SceGxmEdgeEnableFlags = 256;
pub const SCE_GXM_EDGE_ENABLE_12: SceGxmEdgeEnableFlags = 512;
pub const SCE_GXM_EDGE_ENABLE_20: SceGxmEdgeEnableFlags = 1024;
pub const SCE_GXM_ERROR_ALREADY_INITIALIZED: SceGxmErrorCode = 2153447425;
pub const SCE_GXM_ERROR_DRIVER: SceGxmErrorCode = 2153447447;
pub const SCE_GXM_ERROR_INVALID_ALIGNMENT: SceGxmErrorCode = 2153447429;
pub const SCE_GXM_ERROR_INVALID_AUXILIARY_SURFACE: SceGxmErrorCode = 2153447443;
pub const SCE_GXM_ERROR_INVALID_INDEX_COUNT: SceGxmErrorCode = 2153447437;
pub const SCE_GXM_ERROR_INVALID_POINTER: SceGxmErrorCode = 2153447428;
pub const SCE_GXM_ERROR_INVALID_POLYGON_MODE: SceGxmErrorCode = 2153447438;
pub const SCE_GXM_ERROR_INVALID_PRECOMPUTED_DRAW: SceGxmErrorCode = 2153447444;
pub const SCE_GXM_ERROR_INVALID_PRECOMPUTED_FRAGMENT_STATE: SceGxmErrorCode = 2153447446;
pub const SCE_GXM_ERROR_INVALID_PRECOMPUTED_VERTEX_STATE: SceGxmErrorCode = 2153447445;
pub const SCE_GXM_ERROR_INVALID_SAMPLER_RESULT_TYPE_COMPONENT_COUNT: SceGxmErrorCode = 2153447440;
pub const SCE_GXM_ERROR_INVALID_SAMPLER_RESULT_TYPE_PRECISION: SceGxmErrorCode = 2153447439;
pub const SCE_GXM_ERROR_INVALID_TEXTURE: SceGxmErrorCode = 2153447448;
pub const SCE_GXM_ERROR_INVALID_TEXTURE_DATA_POINTER: SceGxmErrorCode = 2153447449;
pub const SCE_GXM_ERROR_INVALID_TEXTURE_PALETTE_POINTER: SceGxmErrorCode = 2153447450;
pub const SCE_GXM_ERROR_INVALID_VALUE: SceGxmErrorCode = 2153447427;
pub const SCE_GXM_ERROR_NOT_WITHIN_SCENE: SceGxmErrorCode = 2153447430;
pub const SCE_GXM_ERROR_NULL_PROGRAM: SceGxmErrorCode = 2153447432;
pub const SCE_GXM_ERROR_OUT_OF_MEMORY: SceGxmErrorCode = 2153447426;
pub const SCE_GXM_ERROR_OUT_OF_RENDER_TARGETS: SceGxmErrorCode = 2153447463;
pub const SCE_GXM_ERROR_PATCHER_INTERNAL: SceGxmErrorCode = 2153447434;
pub const SCE_GXM_ERROR_PROGRAM_IN_USE: SceGxmErrorCode = 2153447436;
pub const SCE_GXM_ERROR_RESERVE_FAILED: SceGxmErrorCode = 2153447435;
pub const SCE_GXM_ERROR_UNIFORM_BUFFER_NOT_RESERVED: SceGxmErrorCode = 2153447441;
pub const SCE_GXM_ERROR_UNINITIALIZED: SceGxmErrorCode = 2153447424;
pub const SCE_GXM_ERROR_UNSUPPORTED: SceGxmErrorCode = 2153447433;
pub const SCE_GXM_ERROR_WITHIN_SCENE: SceGxmErrorCode = 2153447431;
pub const SCE_GXM_FRAGMENT_PROGRAM: SceGxmProgramType = 1;
pub const SCE_GXM_FRAGMENT_PROGRAM_DISABLED: SceGxmFragmentProgramMode = 2097152;
pub const SCE_GXM_FRAGMENT_PROGRAM_ENABLED: SceGxmFragmentProgramMode = 0;
pub const SCE_GXM_INDEX_FORMAT_U16: SceGxmIndexFormat = 0;
pub const SCE_GXM_INDEX_FORMAT_U32: SceGxmIndexFormat = 16777216;
pub const SCE_GXM_INDEX_SOURCE_INDEX_16BIT: SceGxmIndexSource = 0;
pub const SCE_GXM_INDEX_SOURCE_INDEX_32BIT: SceGxmIndexSource = 1;
pub const SCE_GXM_INDEX_SOURCE_INSTANCE_16BIT: SceGxmIndexSource = 2;
pub const SCE_GXM_INDEX_SOURCE_INSTANCE_32BIT: SceGxmIndexSource = 3;
pub const SCE_GXM_LINE_FILL_LAST_PIXEL_DISABLED: SceGxmLineFillLastPixelMode = 0;
pub const SCE_GXM_LINE_FILL_LAST_PIXEL_ENABLED: SceGxmLineFillLastPixelMode = 524288;
pub const SCE_GXM_MAX_AUXILIARY_SURFACES: u32 = 3;
pub const SCE_GXM_MAX_TEXTURE_UNITS: u32 = 16;
pub const SCE_GXM_MAX_UNIFORM_BUFFERS: u32 = 14;
pub const SCE_GXM_MAX_VERTEX_ATTRIBUTES: u32 = 16;
pub const SCE_GXM_MAX_VERTEX_STREAMS: u32 = 16;
pub const SCE_GXM_MEMORY_ATTRIB_READ: SceGxmMemoryAttribFlags = 1;
pub const SCE_GXM_MEMORY_ATTRIB_RW: SceGxmMemoryAttribFlags = 3;
pub const SCE_GXM_MEMORY_ATTRIB_WRITE: SceGxmMemoryAttribFlags = 2;
pub const SCE_GXM_MIDSCENE_PRESERVE_DEFAULT_UNIFORM_BUFFERS: SceGxmMidSceneFlags = 1;
pub const SCE_GXM_MINIMUM_CONTEXT_HOST_MEM_SIZE: u32 = 2048;
pub const SCE_GXM_MULTISAMPLE_2X: SceGxmMultisampleMode = 1;
pub const SCE_GXM_MULTISAMPLE_4X: SceGxmMultisampleMode = 2;
pub const SCE_GXM_MULTISAMPLE_NONE: SceGxmMultisampleMode = 0;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_CHAR4: SceGxmOutputRegisterFormat = 2;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_DECLARED: SceGxmOutputRegisterFormat = 0;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_FLOAT: SceGxmOutputRegisterFormat = 8;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_FLOAT2: SceGxmOutputRegisterFormat = 7;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_HALF2: SceGxmOutputRegisterFormat = 6;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_HALF4: SceGxmOutputRegisterFormat = 5;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_SHORT2: SceGxmOutputRegisterFormat = 4;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4: SceGxmOutputRegisterFormat = 1;
pub const SCE_GXM_OUTPUT_REGISTER_FORMAT_USHORT2: SceGxmOutputRegisterFormat = 3;
pub const SCE_GXM_OUTPUT_REGISTER_SIZE_32BIT: SceGxmOutputRegisterSize = 0;
pub const SCE_GXM_OUTPUT_REGISTER_SIZE_64BIT: SceGxmOutputRegisterSize = 1;
pub const SCE_GXM_PALETTE_ALIGNMENT: u32 = 64;
pub const SCE_GXM_PARAMETER_CATEGORY_ATTRIBUTE: SceGxmParameterCategory = 0;
pub const SCE_GXM_PARAMETER_CATEGORY_AUXILIARY_SURFACE: SceGxmParameterCategory = 3;
pub const SCE_GXM_PARAMETER_CATEGORY_SAMPLER: SceGxmParameterCategory = 2;
pub const SCE_GXM_PARAMETER_CATEGORY_UNIFORM: SceGxmParameterCategory = 1;
pub const SCE_GXM_PARAMETER_CATEGORY_UNIFORM_BUFFER: SceGxmParameterCategory = 4;
pub const SCE_GXM_PARAMETER_SEMANTIC_ATTR: SceGxmParameterSemantic = 1;
pub const SCE_GXM_PARAMETER_SEMANTIC_BCOL: SceGxmParameterSemantic = 2;
pub const SCE_GXM_PARAMETER_SEMANTIC_BINORMAL: SceGxmParameterSemantic = 3;
pub const SCE_GXM_PARAMETER_SEMANTIC_BLENDINDICES: SceGxmParameterSemantic = 4;
pub const SCE_GXM_PARAMETER_SEMANTIC_BLENDWEIGHT: SceGxmParameterSemantic = 5;
pub const SCE_GXM_PARAMETER_SEMANTIC_COLOR: SceGxmParameterSemantic = 6;
pub const SCE_GXM_PARAMETER_SEMANTIC_DIFFUSE: SceGxmParameterSemantic = 7;
pub const SCE_GXM_PARAMETER_SEMANTIC_FOGCOORD: SceGxmParameterSemantic = 8;
pub const SCE_GXM_PARAMETER_SEMANTIC_NONE: SceGxmParameterSemantic = 0;
pub const SCE_GXM_PARAMETER_SEMANTIC_NORMAL: SceGxmParameterSemantic = 9;
pub const SCE_GXM_PARAMETER_SEMANTIC_POINTSIZE: SceGxmParameterSemantic = 10;
pub const SCE_GXM_PARAMETER_SEMANTIC_POSITION: SceGxmParameterSemantic = 11;
pub const SCE_GXM_PARAMETER_SEMANTIC_SPECULAR: SceGxmParameterSemantic = 12;
pub const SCE_GXM_PARAMETER_SEMANTIC_TANGENT: SceGxmParameterSemantic = 13;
pub const SCE_GXM_PARAMETER_SEMANTIC_TEXCOORD: SceGxmParameterSemantic = 14;
pub const SCE_GXM_PARAMETER_TYPE_AGGREGATE: SceGxmParameterType = 9;
pub const SCE_GXM_PARAMETER_TYPE_C10: SceGxmParameterType = 2;
pub const SCE_GXM_PARAMETER_TYPE_F16: SceGxmParameterType = 1;
pub const SCE_GXM_PARAMETER_TYPE_F32: SceGxmParameterType = 0;
pub const SCE_GXM_PARAMETER_TYPE_S16: SceGxmParameterType = 6;
pub const SCE_GXM_PARAMETER_TYPE_S32: SceGxmParameterType = 4;
pub const SCE_GXM_PARAMETER_TYPE_S8: SceGxmParameterType = 8;
pub const SCE_GXM_PARAMETER_TYPE_U16: SceGxmParameterType = 5;
pub const SCE_GXM_PARAMETER_TYPE_U32: SceGxmParameterType = 3;
pub const SCE_GXM_PARAMETER_TYPE_U8: SceGxmParameterType = 7;
pub const SCE_GXM_PASS_TYPE_DEPTH_REPLACE: SceGxmPassType = 167772160;
pub const SCE_GXM_PASS_TYPE_DISCARD: SceGxmPassType = 67108864;
pub const SCE_GXM_PASS_TYPE_MASK_UPDATE: SceGxmPassType = 100663296;
pub const SCE_GXM_PASS_TYPE_OPAQUE: SceGxmPassType = 0;
pub const SCE_GXM_PASS_TYPE_TRANSLUCENT: SceGxmPassType = 33554432;
pub const SCE_GXM_POLYGON_MODE_LINE: SceGxmPolygonMode = 32768;
pub const SCE_GXM_POLYGON_MODE_POINT: SceGxmPolygonMode = 98304;
pub const SCE_GXM_POLYGON_MODE_POINT_01UV: SceGxmPolygonMode = 131072;
pub const SCE_GXM_POLYGON_MODE_POINT_10UV: SceGxmPolygonMode = 65536;
pub const SCE_GXM_POLYGON_MODE_TRIANGLE_FILL: SceGxmPolygonMode = 0;
pub const SCE_GXM_POLYGON_MODE_TRIANGLE_LINE: SceGxmPolygonMode = 163840;
pub const SCE_GXM_POLYGON_MODE_TRIANGLE_POINT: SceGxmPolygonMode = 196608;
pub const SCE_GXM_PRECOMPUTED_DRAW_WORD_COUNT: SceGxmPrecomputedWordCount = 11;
pub const SCE_GXM_PRECOMPUTED_FRAGMENT_STATE_WORD_COUNT: SceGxmPrecomputedWordCount = 9;
pub const SCE_GXM_PRECOMPUTED_VERTEX_STATE_WORD_COUNT: SceGxmPrecomputedWordCount = 7;
pub const SCE_GXM_PRIMITIVE_LINES: SceGxmPrimitiveType = 67108864;
pub const SCE_GXM_PRIMITIVE_POINTS: SceGxmPrimitiveType = 134217728;
pub const SCE_GXM_PRIMITIVE_TRIANGLE_EDGES: SceGxmPrimitiveType = 335544320;
pub const SCE_GXM_PRIMITIVE_TRIANGLE_FAN: SceGxmPrimitiveType = 268435456;
pub const SCE_GXM_PRIMITIVE_TRIANGLES: SceGxmPrimitiveType = 0;
pub const SCE_GXM_PRIMITIVE_TRIANGLE_STRIP: SceGxmPrimitiveType = 201326592;
pub const SCE_GXM_REGION_CLIP_ALL: SceGxmRegionClipMode = 1073741824;
pub const SCE_GXM_REGION_CLIP_INSIDE: SceGxmRegionClipMode = 3221225472;
pub const SCE_GXM_REGION_CLIP_NONE: SceGxmRegionClipMode = 0;
pub const SCE_GXM_REGION_CLIP_OUTSIDE: SceGxmRegionClipMode = 2147483648;
pub const SCE_GXM_RENDER_TARGET_CUSTOM_MULTISAMPLE_LOCATIONS: SceGxmRenderTargetFlags = 1;
pub const SCE_GXM_SCENE_FRAGMENT_SET_DEPENDENCY: SceGxmSceneFlags = 1;
pub const SCE_GXM_SCENE_FRAGMENT_TRANSFER_SYNC: SceGxmSceneFlags = 4;
pub const SCE_GXM_SCENE_VERTEX_TRANSFER_SYNC: SceGxmSceneFlags = 8;
pub const SCE_GXM_SCENE_VERTEX_WAIT_FOR_DEPENDENCY: SceGxmSceneFlags = 2;
pub const SCE_GXM_STENCIL_FUNC_ALWAYS: SceGxmStencilFunc = 234881024;
pub const SCE_GXM_STENCIL_FUNC_EQUAL: SceGxmStencilFunc = 67108864;
pub const SCE_GXM_STENCIL_FUNC_GREATER: SceGxmStencilFunc = 134217728;
pub const SCE_GXM_STENCIL_FUNC_GREATER_EQUAL: SceGxmStencilFunc = 201326592;
pub const SCE_GXM_STENCIL_FUNC_LESS: SceGxmStencilFunc = 33554432;
pub const SCE_GXM_STENCIL_FUNC_LESS_EQUAL: SceGxmStencilFunc = 100663296;
pub const SCE_GXM_STENCIL_FUNC_NEVER: SceGxmStencilFunc = 0;
pub const SCE_GXM_STENCIL_FUNC_NOT_EQUAL: SceGxmStencilFunc = 167772160;
pub const SCE_GXM_STENCIL_OP_DECR: SceGxmStencilOp = 4;
pub const SCE_GXM_STENCIL_OP_DECR_WRAP: SceGxmStencilOp = 7;
pub const SCE_GXM_STENCIL_OP_INCR: SceGxmStencilOp = 3;
pub const SCE_GXM_STENCIL_OP_INCR_WRAP: SceGxmStencilOp = 6;
pub const SCE_GXM_STENCIL_OP_INVERT: SceGxmStencilOp = 5;
pub const SCE_GXM_STENCIL_OP_KEEP: SceGxmStencilOp = 0;
pub const SCE_GXM_STENCIL_OP_REPLACE: SceGxmStencilOp = 2;
pub const SCE_GXM_STENCIL_OP_ZERO: SceGxmStencilOp = 1;
pub const SCE_GXM_TEXTURE_ADDR_CLAMP: SceGxmTextureAddrMode = 2;
pub const SCE_GXM_TEXTURE_ADDR_CLAMP_FULL_BORDER: SceGxmTextureAddrMode = 5;
pub const SCE_GXM_TEXTURE_ADDR_CLAMP_HALF_BORDER: SceGxmTextureAddrMode = 7;
pub const SCE_GXM_TEXTURE_ADDR_CLAMP_IGNORE_BORDER: SceGxmTextureAddrMode = 6;
pub const SCE_GXM_TEXTURE_ADDR_MIRROR: SceGxmTextureAddrMode = 1;
pub const SCE_GXM_TEXTURE_ADDR_MIRROR_CLAMP: SceGxmTextureAddrMode = 3;
pub const SCE_GXM_TEXTURE_ADDR_REPEAT: SceGxmTextureAddrMode = 0;
pub const SCE_GXM_TEXTURE_ADDR_REPEAT_IGNORE_BORDER: SceGxmTextureAddrMode = 4;
pub const SCE_GXM_TEXTURE_ALIGNMENT: u32 = 16;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F11F11F10: SceGxmTextureBaseFormat = 436207616;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F16: SceGxmTextureBaseFormat = 184549376;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F16F16: SceGxmTextureBaseFormat = 285212672;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16: SceGxmTextureBaseFormat = 452984832;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F32: SceGxmTextureBaseFormat = 301989888;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F32F32: SceGxmTextureBaseFormat = 503316480;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_F32M: SceGxmTextureBaseFormat = 318767104;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_P4: SceGxmTextureBaseFormat = 2483027968;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_P8: SceGxmTextureBaseFormat = 2499805184;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_PVRT2BPP: SceGxmTextureBaseFormat = 2147483648;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_PVRT4BPP: SceGxmTextureBaseFormat = 2164260864;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII2BPP: SceGxmTextureBaseFormat = 2181038080;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII4BPP: SceGxmTextureBaseFormat = 2197815296;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S16: SceGxmTextureBaseFormat = 167772160;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S16S16: SceGxmTextureBaseFormat = 268435456;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16: SceGxmTextureBaseFormat = 486539264;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S32: SceGxmTextureBaseFormat = 402653184;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S5S5U6: SceGxmTextureBaseFormat = 100663296;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S8: SceGxmTextureBaseFormat = 16777216;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S8S8: SceGxmTextureBaseFormat = 134217728;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8: SceGxmTextureBaseFormat = 2566914048;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8: SceGxmTextureBaseFormat = 218103808;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_SBC4: SceGxmTextureBaseFormat = 2298478592;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_SBC5: SceGxmTextureBaseFormat = 2332033024;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_SE5M9M9M9: SceGxmTextureBaseFormat = 419430400;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U16: SceGxmTextureBaseFormat = 150994944;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U16U16: SceGxmTextureBaseFormat = 251658240;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16: SceGxmTextureBaseFormat = 469762048;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5: SceGxmTextureBaseFormat = 67108864;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10: SceGxmTextureBaseFormat = 2583691264;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10: SceGxmTextureBaseFormat = 234881024;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U32: SceGxmTextureBaseFormat = 385875968;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U32U32: SceGxmTextureBaseFormat = 520093696;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4: SceGxmTextureBaseFormat = 33554432;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U5U6U5: SceGxmTextureBaseFormat = 83886080;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U8: SceGxmTextureBaseFormat = 0;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U8U3U3U2: SceGxmTextureBaseFormat = 50331648;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U8U8: SceGxmTextureBaseFormat = 117440512;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8: SceGxmTextureBaseFormat = 2550136832;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8: SceGxmTextureBaseFormat = 201326592;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_UBC1: SceGxmTextureBaseFormat = 2231369728;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_UBC2: SceGxmTextureBaseFormat = 2248146944;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_UBC3: SceGxmTextureBaseFormat = 2264924160;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_UBC4: SceGxmTextureBaseFormat = 2281701376;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_UBC5: SceGxmTextureBaseFormat = 2315255808;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_X8S8S8U8: SceGxmTextureBaseFormat = 335544320;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_X8U24: SceGxmTextureBaseFormat = 352321536;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P2: SceGxmTextureBaseFormat = 2415919104;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P3: SceGxmTextureBaseFormat = 2432696320;
pub const SCE_GXM_TEXTURE_BASE_FORMAT_YUV422: SceGxmTextureBaseFormat = 2449473536;
pub const SCE_GXM_TEXTURE_CUBE: SceGxmTextureType = 1073741824;
pub const SCE_GXM_TEXTURE_CUBE_ARBITRARY: SceGxmTextureType = 3758096384;
pub const SCE_GXM_TEXTURE_FILTER_LINEAR: SceGxmTextureFilter = 1;
pub const SCE_GXM_TEXTURE_FILTER_MIPMAP_LINEAR: SceGxmTextureFilter = 2;
pub const SCE_GXM_TEXTURE_FILTER_MIPMAP_POINT: SceGxmTextureFilter = 3;
pub const SCE_GXM_TEXTURE_FILTER_POINT: SceGxmTextureFilter = 0;
pub const SCE_GXM_TEXTURE_FORMAT_A16: SceGxmTextureFormat = 151019520;
pub const SCE_GXM_TEXTURE_FORMAT_A1R5G5B5: SceGxmTextureFormat = 67112960;
pub const SCE_GXM_TEXTURE_FORMAT_A4R4G4B4: SceGxmTextureFormat = 33558528;
pub const SCE_GXM_TEXTURE_FORMAT_A8: SceGxmTextureFormat = 24576;
pub const SCE_GXM_TEXTURE_FORMAT_A8B8G8R8: SceGxmTextureFormat = 201326592;
pub const SCE_GXM_TEXTURE_FORMAT_A8L8: SceGxmTextureFormat = 117448704;
pub const SCE_GXM_TEXTURE_FORMAT_A8R8G8B8: SceGxmTextureFormat = 201330688;
pub const SCE_GXM_TEXTURE_FORMAT_AF16: SceGxmTextureFormat = 184573952;
pub const SCE_GXM_TEXTURE_FORMAT_AF16LF16: SceGxmTextureFormat = 285220864;
pub const SCE_GXM_TEXTURE_FORMAT_AF32M: SceGxmTextureFormat = 318791680;
pub const SCE_GXM_TEXTURE_FORMAT_D16: SceGxmTextureFormat = 150994944;
pub const SCE_GXM_TEXTURE_FORMAT_DF32M: SceGxmTextureFormat = 318767104;
pub const SCE_GXM_TEXTURE_FORMAT_F10F10F10U2_BGRA: SceGxmTextureFormat = 2583703552;
pub const SCE_GXM_TEXTURE_FORMAT_F10F10F10U2_RGBA: SceGxmTextureFormat = 2583699456;
pub const SCE_GXM_TEXTURE_FORMAT_F10F10F10X2_BGR1: SceGxmTextureFormat = 2583719936;
pub const SCE_GXM_TEXTURE_FORMAT_F10F10F10X2_RGB1: SceGxmTextureFormat = 2583715840;
pub const SCE_GXM_TEXTURE_FORMAT_F10F11F11_BGR: SceGxmTextureFormat = 436207616;
pub const SCE_GXM_TEXTURE_FORMAT_F11F11F10_RGB: SceGxmTextureFormat = 436211712;
pub const SCE_GXM_TEXTURE_FORMAT_F16_000R: SceGxmTextureFormat = 184553472;
pub const SCE_GXM_TEXTURE_FORMAT_F16_0RRR: SceGxmTextureFormat = 184565760;
pub const SCE_GXM_TEXTURE_FORMAT_F16_111R: SceGxmTextureFormat = 184557568;
pub const SCE_GXM_TEXTURE_FORMAT_F16_1RRR: SceGxmTextureFormat = 184569856;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16_00GR: SceGxmTextureFormat = 285216768;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16_00RG: SceGxmTextureFormat = 285233152;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_ABGR: SceGxmTextureFormat = 452984832;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_ARGB: SceGxmTextureFormat = 452988928;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_BGRA: SceGxmTextureFormat = 452997120;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_RGBA: SceGxmTextureFormat = 452993024;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16F16X16_BGR1: SceGxmTextureFormat = 453013504;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16F16X16_RGB1: SceGxmTextureFormat = 453009408;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16_GR: SceGxmTextureFormat = 285212672;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16_GRGR: SceGxmTextureFormat = 285229056;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16_GRRR: SceGxmTextureFormat = 285220864;
pub const SCE_GXM_TEXTURE_FORMAT_F16F16_RGGG: SceGxmTextureFormat = 285224960;
pub const SCE_GXM_TEXTURE_FORMAT_F16_R: SceGxmTextureFormat = 184549376;
pub const SCE_GXM_TEXTURE_FORMAT_F16_R000: SceGxmTextureFormat = 184573952;
pub const SCE_GXM_TEXTURE_FORMAT_F16_R111: SceGxmTextureFormat = 184578048;
pub const SCE_GXM_TEXTURE_FORMAT_F16_RRRR: SceGxmTextureFormat = 184561664;
pub const SCE_GXM_TEXTURE_FORMAT_F32_000R: SceGxmTextureFormat = 301993984;
pub const SCE_GXM_TEXTURE_FORMAT_F32_0RRR: SceGxmTextureFormat = 302006272;
pub const SCE_GXM_TEXTURE_FORMAT_F32_111R: SceGxmTextureFormat = 301998080;
pub const SCE_GXM_TEXTURE_FORMAT_F32_1RRR: SceGxmTextureFormat = 302010368;
pub const SCE_GXM_TEXTURE_FORMAT_F32F32_00GR: SceGxmTextureFormat = 503320576;
pub const SCE_GXM_TEXTURE_FORMAT_F32F32_00RG: SceGxmTextureFormat = 503336960;
pub const SCE_GXM_TEXTURE_FORMAT_F32F32_GR: SceGxmTextureFormat = 503316480;
pub const SCE_GXM_TEXTURE_FORMAT_F32F32_GRGR: SceGxmTextureFormat = 503332864;
pub const SCE_GXM_TEXTURE_FORMAT_F32F32_GRRR: SceGxmTextureFormat = 503324672;
pub const SCE_GXM_TEXTURE_FORMAT_F32F32_RGGG: SceGxmTextureFormat = 503328768;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_000R: SceGxmTextureFormat = 318771200;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_0RRR: SceGxmTextureFormat = 318783488;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_111R: SceGxmTextureFormat = 318775296;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_1RRR: SceGxmTextureFormat = 318787584;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_R: SceGxmTextureFormat = 318767104;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_R000: SceGxmTextureFormat = 318791680;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_R111: SceGxmTextureFormat = 318795776;
pub const SCE_GXM_TEXTURE_FORMAT_F32M_RRRR: SceGxmTextureFormat = 318779392;
pub const SCE_GXM_TEXTURE_FORMAT_F32_R: SceGxmTextureFormat = 301989888;
pub const SCE_GXM_TEXTURE_FORMAT_F32_R000: SceGxmTextureFormat = 302014464;
pub const SCE_GXM_TEXTURE_FORMAT_F32_R111: SceGxmTextureFormat = 302018560;
pub const SCE_GXM_TEXTURE_FORMAT_F32_RRRR: SceGxmTextureFormat = 302002176;
pub const SCE_GXM_TEXTURE_FORMAT_G8R8: SceGxmTextureFormat = 117444608;
pub const SCE_GXM_TEXTURE_FORMAT_GF16RF16: SceGxmTextureFormat = 285216768;
pub const SCE_GXM_TEXTURE_FORMAT_L16: SceGxmTextureFormat = 151015424;
pub const SCE_GXM_TEXTURE_FORMAT_L8: SceGxmTextureFormat = 20480;
pub const SCE_GXM_TEXTURE_FORMAT_L8A8: SceGxmTextureFormat = 117452800;
pub const SCE_GXM_TEXTURE_FORMAT_LF16: SceGxmTextureFormat = 184569856;
pub const SCE_GXM_TEXTURE_FORMAT_LF16AF16: SceGxmTextureFormat = 285224960;
pub const SCE_GXM_TEXTURE_FORMAT_LF32M: SceGxmTextureFormat = 318787584;
pub const SCE_GXM_TEXTURE_FORMAT_P4_1BGR: SceGxmTextureFormat = 2483044352;
pub const SCE_GXM_TEXTURE_FORMAT_P4_1RGB: SceGxmTextureFormat = 2483048448;
pub const SCE_GXM_TEXTURE_FORMAT_P4_ABGR: SceGxmTextureFormat = 2483027968;
pub const SCE_GXM_TEXTURE_FORMAT_P4_ARGB: SceGxmTextureFormat = 2483032064;
pub const SCE_GXM_TEXTURE_FORMAT_P4_BGR1: SceGxmTextureFormat = 2483056640;
pub const SCE_GXM_TEXTURE_FORMAT_P4_BGRA: SceGxmTextureFormat = 2483040256;
pub const SCE_GXM_TEXTURE_FORMAT_P4_RGB1: SceGxmTextureFormat = 2483052544;
pub const SCE_GXM_TEXTURE_FORMAT_P4_RGBA: SceGxmTextureFormat = 2483036160;
pub const SCE_GXM_TEXTURE_FORMAT_P8_1BGR: SceGxmTextureFormat = 2499821568;
pub const SCE_GXM_TEXTURE_FORMAT_P8_1RGB: SceGxmTextureFormat = 2499825664;
pub const SCE_GXM_TEXTURE_FORMAT_P8_ABGR: SceGxmTextureFormat = 2499805184;
pub const SCE_GXM_TEXTURE_FORMAT_P8_ARGB: SceGxmTextureFormat = 2499809280;
pub const SCE_GXM_TEXTURE_FORMAT_P8_BGR1: SceGxmTextureFormat = 2499833856;
pub const SCE_GXM_TEXTURE_FORMAT_P8_BGRA: SceGxmTextureFormat = 2499817472;
pub const SCE_GXM_TEXTURE_FORMAT_P8_RGB1: SceGxmTextureFormat = 2499829760;
pub const SCE_GXM_TEXTURE_FORMAT_P8_RGBA: SceGxmTextureFormat = 2499813376;
pub const SCE_GXM_TEXTURE_FORMAT_PVRT2BPP: SceGxmTextureFormat = 2147483648;
pub const SCE_GXM_TEXTURE_FORMAT_PVRT2BPP_1BGR: SceGxmTextureFormat = 2147500032;
pub const SCE_GXM_TEXTURE_FORMAT_PVRT2BPP_ABGR: SceGxmTextureFormat = 2147483648;
pub const SCE_GXM_TEXTURE_FORMAT_PVRT4BPP: SceGxmTextureFormat = 2164260864;
pub const SCE_GXM_TEXTURE_FORMAT_PVRT4BPP_1BGR: SceGxmTextureFormat = 2164277248;
pub const SCE_GXM_TEXTURE_FORMAT_PVRT4BPP_ABGR: SceGxmTextureFormat = 2164260864;
pub const SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP: SceGxmTextureFormat = 2181038080;
pub const SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_1BGR: SceGxmTextureFormat = 2181054464;
pub const SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_ABGR: SceGxmTextureFormat = 2181038080;
pub const SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP: SceGxmTextureFormat = 2197815296;
pub const SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_1BGR: SceGxmTextureFormat = 2197831680;
pub const SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_ABGR: SceGxmTextureFormat = 2197815296;
pub const SCE_GXM_TEXTURE_FORMAT_R16: SceGxmTextureFormat = 150999040;
pub const SCE_GXM_TEXTURE_FORMAT_R5G6B5: SceGxmTextureFormat = 83890176;
pub const SCE_GXM_TEXTURE_FORMAT_R8: SceGxmTextureFormat = 4096;
pub const SCE_GXM_TEXTURE_FORMAT_RF16: SceGxmTextureFormat = 184553472;
pub const SCE_GXM_TEXTURE_FORMAT_RF32M: SceGxmTextureFormat = 318771200;
pub const SCE_GXM_TEXTURE_FORMAT_S16_000R: SceGxmTextureFormat = 167776256;
pub const SCE_GXM_TEXTURE_FORMAT_S16_0RRR: SceGxmTextureFormat = 167788544;
pub const SCE_GXM_TEXTURE_FORMAT_S16_111R: SceGxmTextureFormat = 167780352;
pub const SCE_GXM_TEXTURE_FORMAT_S16_1RRR: SceGxmTextureFormat = 167792640;
pub const SCE_GXM_TEXTURE_FORMAT_S16_R: SceGxmTextureFormat = 167772160;
pub const SCE_GXM_TEXTURE_FORMAT_S16_R000: SceGxmTextureFormat = 167796736;
pub const SCE_GXM_TEXTURE_FORMAT_S16_R111: SceGxmTextureFormat = 167800832;
pub const SCE_GXM_TEXTURE_FORMAT_S16_RRRR: SceGxmTextureFormat = 167784448;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16_00GR: SceGxmTextureFormat = 268439552;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16_00RG: SceGxmTextureFormat = 268455936;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16_GR: SceGxmTextureFormat = 268435456;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16_GRGR: SceGxmTextureFormat = 268451840;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16_GRRR: SceGxmTextureFormat = 268443648;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16_RGGG: SceGxmTextureFormat = 268447744;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_ABGR: SceGxmTextureFormat = 486539264;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_ARGB: SceGxmTextureFormat = 486543360;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_BGRA: SceGxmTextureFormat = 486551552;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_RGBA: SceGxmTextureFormat = 486547456;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16S16X16_BGR1: SceGxmTextureFormat = 486567936;
pub const SCE_GXM_TEXTURE_FORMAT_S16S16S16X16_RGB1: SceGxmTextureFormat = 486563840;
pub const SCE_GXM_TEXTURE_FORMAT_S32_000R: SceGxmTextureFormat = 402657280;
pub const SCE_GXM_TEXTURE_FORMAT_S32_0RRR: SceGxmTextureFormat = 402669568;
pub const SCE_GXM_TEXTURE_FORMAT_S32_111R: SceGxmTextureFormat = 402661376;
pub const SCE_GXM_TEXTURE_FORMAT_S32_1RRR: SceGxmTextureFormat = 402673664;
pub const SCE_GXM_TEXTURE_FORMAT_S32_R: SceGxmTextureFormat = 402653184;
pub const SCE_GXM_TEXTURE_FORMAT_S32_R000: SceGxmTextureFormat = 402677760;
pub const SCE_GXM_TEXTURE_FORMAT_S32_R111: SceGxmTextureFormat = 402681856;
pub const SCE_GXM_TEXTURE_FORMAT_S32_RRRR: SceGxmTextureFormat = 402665472;
pub const SCE_GXM_TEXTURE_FORMAT_S5S5U6_RGB: SceGxmTextureFormat = 100667392;
pub const SCE_GXM_TEXTURE_FORMAT_S8_000R: SceGxmTextureFormat = 16781312;
pub const SCE_GXM_TEXTURE_FORMAT_S8_0RRR: SceGxmTextureFormat = 16793600;
pub const SCE_GXM_TEXTURE_FORMAT_S8_111R: SceGxmTextureFormat = 16785408;
pub const SCE_GXM_TEXTURE_FORMAT_S8_1RRR: SceGxmTextureFormat = 16797696;
pub const SCE_GXM_TEXTURE_FORMAT_S8_R: SceGxmTextureFormat = 16777216;
pub const SCE_GXM_TEXTURE_FORMAT_S8_R000: SceGxmTextureFormat = 16801792;
pub const SCE_GXM_TEXTURE_FORMAT_S8_R111: SceGxmTextureFormat = 16805888;
pub const SCE_GXM_TEXTURE_FORMAT_S8_RRRR: SceGxmTextureFormat = 16789504;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8_00GR: SceGxmTextureFormat = 134221824;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8_00RG: SceGxmTextureFormat = 134238208;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8_GR: SceGxmTextureFormat = 134217728;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8_GRGR: SceGxmTextureFormat = 134234112;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8_GRRR: SceGxmTextureFormat = 134225920;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8_RGGG: SceGxmTextureFormat = 134230016;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8_BGR: SceGxmTextureFormat = 2566914048;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8_RGB: SceGxmTextureFormat = 2566918144;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_ABGR: SceGxmTextureFormat = 218103808;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_ARGB: SceGxmTextureFormat = 218107904;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_BGRA: SceGxmTextureFormat = 218116096;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_RGBA: SceGxmTextureFormat = 218112000;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8X8_BGR1: SceGxmTextureFormat = 218132480;
pub const SCE_GXM_TEXTURE_FORMAT_S8S8S8X8_RGB1: SceGxmTextureFormat = 218128384;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_000R: SceGxmTextureFormat = 2298482688;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_0RRR: SceGxmTextureFormat = 2298494976;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_111R: SceGxmTextureFormat = 2298486784;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_1RRR: SceGxmTextureFormat = 2298499072;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_R: SceGxmTextureFormat = 2298478592;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_R000: SceGxmTextureFormat = 2298503168;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_R111: SceGxmTextureFormat = 2298507264;
pub const SCE_GXM_TEXTURE_FORMAT_SBC4_RRRR: SceGxmTextureFormat = 2298490880;
pub const SCE_GXM_TEXTURE_FORMAT_SBC5_00GR: SceGxmTextureFormat = 2332037120;
pub const SCE_GXM_TEXTURE_FORMAT_SBC5_00RG: SceGxmTextureFormat = 2332053504;
pub const SCE_GXM_TEXTURE_FORMAT_SBC5_GR: SceGxmTextureFormat = 2332033024;
pub const SCE_GXM_TEXTURE_FORMAT_SBC5_GRGR: SceGxmTextureFormat = 2332049408;
pub const SCE_GXM_TEXTURE_FORMAT_SBC5_GRRR: SceGxmTextureFormat = 2332041216;
pub const SCE_GXM_TEXTURE_FORMAT_SBC5_RGGG: SceGxmTextureFormat = 2332045312;
pub const SCE_GXM_TEXTURE_FORMAT_SE5M9M9M9_BGR: SceGxmTextureFormat = 419430400;
pub const SCE_GXM_TEXTURE_FORMAT_SE5M9M9M9_RGB: SceGxmTextureFormat = 419434496;
pub const SCE_GXM_TEXTURE_FORMAT_U10U10U10U2_BGRA: SceGxmTextureFormat = 234893312;
pub const SCE_GXM_TEXTURE_FORMAT_U10U10U10U2_RGBA: SceGxmTextureFormat = 234889216;
pub const SCE_GXM_TEXTURE_FORMAT_U10U10U10X2_BGR1: SceGxmTextureFormat = 234909696;
pub const SCE_GXM_TEXTURE_FORMAT_U10U10U10X2_RGB1: SceGxmTextureFormat = 234905600;
pub const SCE_GXM_TEXTURE_FORMAT_U16_000R: SceGxmTextureFormat = 150999040;
pub const SCE_GXM_TEXTURE_FORMAT_U16_0RRR: SceGxmTextureFormat = 151011328;
pub const SCE_GXM_TEXTURE_FORMAT_U16_111R: SceGxmTextureFormat = 151003136;
pub const SCE_GXM_TEXTURE_FORMAT_U16_1RRR: SceGxmTextureFormat = 151015424;
pub const SCE_GXM_TEXTURE_FORMAT_U16_R: SceGxmTextureFormat = 150994944;
pub const SCE_GXM_TEXTURE_FORMAT_U16_R000: SceGxmTextureFormat = 151019520;
pub const SCE_GXM_TEXTURE_FORMAT_U16_R111: SceGxmTextureFormat = 151023616;
pub const SCE_GXM_TEXTURE_FORMAT_U16_RRRR: SceGxmTextureFormat = 151007232;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16_00GR: SceGxmTextureFormat = 251662336;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16_00RG: SceGxmTextureFormat = 251678720;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16_GR: SceGxmTextureFormat = 251658240;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16_GRGR: SceGxmTextureFormat = 251674624;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16_GRRR: SceGxmTextureFormat = 251666432;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16_RGGG: SceGxmTextureFormat = 251670528;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_ABGR: SceGxmTextureFormat = 469762048;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_ARGB: SceGxmTextureFormat = 469766144;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_BGRA: SceGxmTextureFormat = 469774336;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_RGBA: SceGxmTextureFormat = 469770240;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16U16X16_BGR1: SceGxmTextureFormat = 469790720;
pub const SCE_GXM_TEXTURE_FORMAT_U16U16U16X16_RGB1: SceGxmTextureFormat = 469786624;
pub const SCE_GXM_TEXTURE_FORMAT_U1U5U5U5_ABGR: SceGxmTextureFormat = 67108864;
pub const SCE_GXM_TEXTURE_FORMAT_U1U5U5U5_ARGB: SceGxmTextureFormat = 67112960;
pub const SCE_GXM_TEXTURE_FORMAT_U24X8_DS: SceGxmTextureFormat = 352325632;
pub const SCE_GXM_TEXTURE_FORMAT_U2F10F10F10_ABGR: SceGxmTextureFormat = 2583691264;
pub const SCE_GXM_TEXTURE_FORMAT_U2F10F10F10_ARGB: SceGxmTextureFormat = 2583695360;
pub const SCE_GXM_TEXTURE_FORMAT_U2U10U10U10_ABGR: SceGxmTextureFormat = 234881024;
pub const SCE_GXM_TEXTURE_FORMAT_U2U10U10U10_ARGB: SceGxmTextureFormat = 234885120;
pub const SCE_GXM_TEXTURE_FORMAT_U32_000R: SceGxmTextureFormat = 385880064;
pub const SCE_GXM_TEXTURE_FORMAT_U32_0RRR: SceGxmTextureFormat = 385892352;
pub const SCE_GXM_TEXTURE_FORMAT_U32_111R: SceGxmTextureFormat = 385884160;
pub const SCE_GXM_TEXTURE_FORMAT_U32_1RRR: SceGxmTextureFormat = 385896448;
pub const SCE_GXM_TEXTURE_FORMAT_U32_R: SceGxmTextureFormat = 385875968;
pub const SCE_GXM_TEXTURE_FORMAT_U32_R000: SceGxmTextureFormat = 385900544;
pub const SCE_GXM_TEXTURE_FORMAT_U32_R111: SceGxmTextureFormat = 385904640;
pub const SCE_GXM_TEXTURE_FORMAT_U32_RRRR: SceGxmTextureFormat = 385888256;
pub const SCE_GXM_TEXTURE_FORMAT_U32U32_00GR: SceGxmTextureFormat = 520097792;
pub const SCE_GXM_TEXTURE_FORMAT_U32U32_00RG: SceGxmTextureFormat = 520114176;
pub const SCE_GXM_TEXTURE_FORMAT_U32U32_GR: SceGxmTextureFormat = 520093696;
pub const SCE_GXM_TEXTURE_FORMAT_U32U32_GRGR: SceGxmTextureFormat = 520110080;
pub const SCE_GXM_TEXTURE_FORMAT_U32U32_GRRR: SceGxmTextureFormat = 520101888;
pub const SCE_GXM_TEXTURE_FORMAT_U32U32_RGGG: SceGxmTextureFormat = 520105984;
pub const SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_ABGR: SceGxmTextureFormat = 33554432;
pub const SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_ARGB: SceGxmTextureFormat = 33558528;
pub const SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_BGRA: SceGxmTextureFormat = 33566720;
pub const SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_RGBA: SceGxmTextureFormat = 33562624;
pub const SCE_GXM_TEXTURE_FORMAT_U4U4U4X4_BGR1: SceGxmTextureFormat = 33583104;
pub const SCE_GXM_TEXTURE_FORMAT_U4U4U4X4_RGB1: SceGxmTextureFormat = 33579008;
pub const SCE_GXM_TEXTURE_FORMAT_U5U5U5U1_BGRA: SceGxmTextureFormat = 67121152;
pub const SCE_GXM_TEXTURE_FORMAT_U5U5U5U1_RGBA: SceGxmTextureFormat = 67117056;
pub const SCE_GXM_TEXTURE_FORMAT_U5U5U5X1_BGR1: SceGxmTextureFormat = 67137536;
pub const SCE_GXM_TEXTURE_FORMAT_U5U5U5X1_RGB1: SceGxmTextureFormat = 67133440;
pub const SCE_GXM_TEXTURE_FORMAT_U5U6U5_BGR: SceGxmTextureFormat = 83886080;
pub const SCE_GXM_TEXTURE_FORMAT_U5U6U5_RGB: SceGxmTextureFormat = 83890176;
pub const SCE_GXM_TEXTURE_FORMAT_U6S5S5_BGR: SceGxmTextureFormat = 100663296;
pub const SCE_GXM_TEXTURE_FORMAT_U8_000R: SceGxmTextureFormat = 4096;
pub const SCE_GXM_TEXTURE_FORMAT_U8_0RRR: SceGxmTextureFormat = 16384;
pub const SCE_GXM_TEXTURE_FORMAT_U8_111R: SceGxmTextureFormat = 8192;
pub const SCE_GXM_TEXTURE_FORMAT_U8_1RRR: SceGxmTextureFormat = 20480;
pub const SCE_GXM_TEXTURE_FORMAT_U8_R: SceGxmTextureFormat = 0;
pub const SCE_GXM_TEXTURE_FORMAT_U8_R000: SceGxmTextureFormat = 24576;
pub const SCE_GXM_TEXTURE_FORMAT_U8_R111: SceGxmTextureFormat = 28672;
pub const SCE_GXM_TEXTURE_FORMAT_U8_RRRR: SceGxmTextureFormat = 12288;
pub const SCE_GXM_TEXTURE_FORMAT_U8U3U3U2_ARGB: SceGxmTextureFormat = 50331648;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8_00GR: SceGxmTextureFormat = 117444608;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8_00RG: SceGxmTextureFormat = 117460992;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8_GR: SceGxmTextureFormat = 117440512;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8_GRGR: SceGxmTextureFormat = 117456896;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8_GRRR: SceGxmTextureFormat = 117448704;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8_RGGG: SceGxmTextureFormat = 117452800;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8_BGR: SceGxmTextureFormat = 2550136832;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8_RGB: SceGxmTextureFormat = 2550140928;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ABGR: SceGxmTextureFormat = 201326592;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ARGB: SceGxmTextureFormat = 201330688;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_BGRA: SceGxmTextureFormat = 201338880;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_RGBA: SceGxmTextureFormat = 201334784;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8X8_BGR1: SceGxmTextureFormat = 201355264;
pub const SCE_GXM_TEXTURE_FORMAT_U8U8U8X8_RGB1: SceGxmTextureFormat = 201351168;
pub const SCE_GXM_TEXTURE_FORMAT_UBC1: SceGxmTextureFormat = 2231369728;
pub const SCE_GXM_TEXTURE_FORMAT_UBC1_1BGR: SceGxmTextureFormat = 2231386112;
pub const SCE_GXM_TEXTURE_FORMAT_UBC1_ABGR: SceGxmTextureFormat = 2231369728;
pub const SCE_GXM_TEXTURE_FORMAT_UBC2: SceGxmTextureFormat = 2248146944;
pub const SCE_GXM_TEXTURE_FORMAT_UBC2_1BGR: SceGxmTextureFormat = 2248163328;
pub const SCE_GXM_TEXTURE_FORMAT_UBC2_ABGR: SceGxmTextureFormat = 2248146944;
pub const SCE_GXM_TEXTURE_FORMAT_UBC3: SceGxmTextureFormat = 2264924160;
pub const SCE_GXM_TEXTURE_FORMAT_UBC3_1BGR: SceGxmTextureFormat = 2264940544;
pub const SCE_GXM_TEXTURE_FORMAT_UBC3_ABGR: SceGxmTextureFormat = 2264924160;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_000R: SceGxmTextureFormat = 2281705472;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_0RRR: SceGxmTextureFormat = 2281717760;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_111R: SceGxmTextureFormat = 2281709568;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_1RRR: SceGxmTextureFormat = 2281721856;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_R: SceGxmTextureFormat = 2281701376;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_R000: SceGxmTextureFormat = 2281725952;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_R111: SceGxmTextureFormat = 2281730048;
pub const SCE_GXM_TEXTURE_FORMAT_UBC4_RRRR: SceGxmTextureFormat = 2281713664;
pub const SCE_GXM_TEXTURE_FORMAT_UBC5_00GR: SceGxmTextureFormat = 2315259904;
pub const SCE_GXM_TEXTURE_FORMAT_UBC5_00RG: SceGxmTextureFormat = 2315276288;
pub const SCE_GXM_TEXTURE_FORMAT_UBC5_GR: SceGxmTextureFormat = 2315255808;
pub const SCE_GXM_TEXTURE_FORMAT_UBC5_GRGR: SceGxmTextureFormat = 2315272192;
pub const SCE_GXM_TEXTURE_FORMAT_UBC5_GRRR: SceGxmTextureFormat = 2315264000;
pub const SCE_GXM_TEXTURE_FORMAT_UBC5_RGGG: SceGxmTextureFormat = 2315268096;
pub const SCE_GXM_TEXTURE_FORMAT_UYVY422_CSC0: SceGxmTextureFormat = 2449481728;
pub const SCE_GXM_TEXTURE_FORMAT_UYVY422_CSC1: SceGxmTextureFormat = 2449498112;
pub const SCE_GXM_TEXTURE_FORMAT_VYUY: SceGxmTextureFormat = 2449485824;
pub const SCE_GXM_TEXTURE_FORMAT_VYUY422_CSC0: SceGxmTextureFormat = 2449485824;
pub const SCE_GXM_TEXTURE_FORMAT_VYUY422_CSC1: SceGxmTextureFormat = 2449502208;
pub const SCE_GXM_TEXTURE_FORMAT_X16F16F16F16_1BGR: SceGxmTextureFormat = 453001216;
pub const SCE_GXM_TEXTURE_FORMAT_X16F16F16F16_1RGB: SceGxmTextureFormat = 453005312;
pub const SCE_GXM_TEXTURE_FORMAT_X16S16S16S16_1BGR: SceGxmTextureFormat = 486555648;
pub const SCE_GXM_TEXTURE_FORMAT_X16S16S16S16_1RGB: SceGxmTextureFormat = 486559744;
pub const SCE_GXM_TEXTURE_FORMAT_X16U16U16U16_1BGR: SceGxmTextureFormat = 469778432;
pub const SCE_GXM_TEXTURE_FORMAT_X16U16U16U16_1RGB: SceGxmTextureFormat = 469782528;
pub const SCE_GXM_TEXTURE_FORMAT_X1U5U5U5_1BGR: SceGxmTextureFormat = 67125248;
pub const SCE_GXM_TEXTURE_FORMAT_X1U5U5U5_1RGB: SceGxmTextureFormat = 67129344;
pub const SCE_GXM_TEXTURE_FORMAT_X2F10F10F10_1BGR: SceGxmTextureFormat = 2583707648;
pub const SCE_GXM_TEXTURE_FORMAT_X2F10F10F10_1RGB: SceGxmTextureFormat = 2583711744;
pub const SCE_GXM_TEXTURE_FORMAT_X2U10U10U10_1BGR: SceGxmTextureFormat = 234897408;
pub const SCE_GXM_TEXTURE_FORMAT_X2U10U10U10_1RGB: SceGxmTextureFormat = 234901504;
pub const SCE_GXM_TEXTURE_FORMAT_X4U4U4U4_1BGR: SceGxmTextureFormat = 33570816;
pub const SCE_GXM_TEXTURE_FORMAT_X4U4U4U4_1RGB: SceGxmTextureFormat = 33574912;
pub const SCE_GXM_TEXTURE_FORMAT_X8S8S8S8_1BGR: SceGxmTextureFormat = 218120192;
pub const SCE_GXM_TEXTURE_FORMAT_X8S8S8S8_1RGB: SceGxmTextureFormat = 218124288;
pub const SCE_GXM_TEXTURE_FORMAT_X8S8S8U8_1BGR: SceGxmTextureFormat = 335544320;
pub const SCE_GXM_TEXTURE_FORMAT_X8U24_SD: SceGxmTextureFormat = 352321536;
pub const SCE_GXM_TEXTURE_FORMAT_X8U8S8S8_1RGB: SceGxmTextureFormat = 335548416;
pub const SCE_GXM_TEXTURE_FORMAT_X8U8U8U8_1BGR: SceGxmTextureFormat = 201342976;
pub const SCE_GXM_TEXTURE_FORMAT_X8U8U8U8_1RGB: SceGxmTextureFormat = 201347072;
pub const SCE_GXM_TEXTURE_FORMAT_YUV420P2_CSC0: SceGxmTextureFormat = 2415919104;
pub const SCE_GXM_TEXTURE_FORMAT_YUV420P2_CSC1: SceGxmTextureFormat = 2415927296;
pub const SCE_GXM_TEXTURE_FORMAT_YUV420P3_CSC0: SceGxmTextureFormat = 2432696320;
pub const SCE_GXM_TEXTURE_FORMAT_YUV420P3_CSC1: SceGxmTextureFormat = 2432704512;
pub const SCE_GXM_TEXTURE_FORMAT_YUYV422_CSC0: SceGxmTextureFormat = 2449473536;
pub const SCE_GXM_TEXTURE_FORMAT_YUYV422_CSC1: SceGxmTextureFormat = 2449489920;
pub const SCE_GXM_TEXTURE_FORMAT_YVU420P2_CSC0: SceGxmTextureFormat = 2415923200;
pub const SCE_GXM_TEXTURE_FORMAT_YVU420P2_CSC1: SceGxmTextureFormat = 2415931392;
pub const SCE_GXM_TEXTURE_FORMAT_YVU420P3_CSC0: SceGxmTextureFormat = 2432700416;
pub const SCE_GXM_TEXTURE_FORMAT_YVU420P3_CSC1: SceGxmTextureFormat = 2432708608;
pub const SCE_GXM_TEXTURE_FORMAT_YVYU: SceGxmTextureFormat = 2449477632;
pub const SCE_GXM_TEXTURE_FORMAT_YVYU422_CSC0: SceGxmTextureFormat = 2449477632;
pub const SCE_GXM_TEXTURE_FORMAT_YVYU422_CSC1: SceGxmTextureFormat = 2449494016;
pub const SCE_GXM_TEXTURE_GAMMA_BGR: SceGxmTextureGammaMode = 134217728;
pub const SCE_GXM_TEXTURE_GAMMA_GR: SceGxmTextureGammaMode = 402653184;
pub const SCE_GXM_TEXTURE_GAMMA_NONE: SceGxmTextureGammaMode = 0;
pub const SCE_GXM_TEXTURE_GAMMA_R: SceGxmTextureGammaMode = 134217728;
pub const SCE_GXM_TEXTURE_LINEAR: SceGxmTextureType = 1610612736;
pub const SCE_GXM_TEXTURE_LINEAR_STRIDED: SceGxmTextureType = 3221225472;
pub const SCE_GXM_TEXTURE_MIP_FILTER_DISABLED: SceGxmTextureMipFilter = 0;
pub const SCE_GXM_TEXTURE_MIP_FILTER_ENABLED: SceGxmTextureMipFilter = 512;
pub const SCE_GXM_TEXTURE_NORMALIZE_DISABLED: SceGxmTextureNormalizeMode = 0;
pub const SCE_GXM_TEXTURE_NORMALIZE_ENABLED: SceGxmTextureNormalizeMode = 2147483648;
pub const SCE_GXM_TEXTURE_SWIZZLE1_000R: SceGxmTextureSwizzle1Mode = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE1_0RRR: SceGxmTextureSwizzle1Mode = 16384;
pub const SCE_GXM_TEXTURE_SWIZZLE1_111R: SceGxmTextureSwizzle1Mode = 8192;
pub const SCE_GXM_TEXTURE_SWIZZLE1_1RRR: SceGxmTextureSwizzle1Mode = 20480;
pub const SCE_GXM_TEXTURE_SWIZZLE1_R: SceGxmTextureSwizzle1Mode = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE1_R000: SceGxmTextureSwizzle1Mode = 24576;
pub const SCE_GXM_TEXTURE_SWIZZLE1_R111: SceGxmTextureSwizzle1Mode = 28672;
pub const SCE_GXM_TEXTURE_SWIZZLE1_RRRR: SceGxmTextureSwizzle1Mode = 12288;
pub const SCE_GXM_TEXTURE_SWIZZLE2_00GR: SceGxmTextureSwizzle2Mode = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE2_00RG: SceGxmTextureSwizzle2Mode = 20480;
pub const SCE_GXM_TEXTURE_SWIZZLE2_DS: SceGxmTextureSwizzle2ModeAlt = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE2_GR: SceGxmTextureSwizzle2Mode = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE2_GRGR: SceGxmTextureSwizzle2Mode = 16384;
pub const SCE_GXM_TEXTURE_SWIZZLE2_GRRR: SceGxmTextureSwizzle2Mode = 8192;
pub const SCE_GXM_TEXTURE_SWIZZLE2_RGGG: SceGxmTextureSwizzle2Mode = 12288;
pub const SCE_GXM_TEXTURE_SWIZZLE2_SD: SceGxmTextureSwizzle2ModeAlt = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE3_BGR: SceGxmTextureSwizzle3Mode = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE3_RGB: SceGxmTextureSwizzle3Mode = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE4_1BGR: SceGxmTextureSwizzle4Mode = 16384;
pub const SCE_GXM_TEXTURE_SWIZZLE4_1RGB: SceGxmTextureSwizzle4Mode = 20480;
pub const SCE_GXM_TEXTURE_SWIZZLE4_ABGR: SceGxmTextureSwizzle4Mode = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE4_ARGB: SceGxmTextureSwizzle4Mode = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE4_BGR1: SceGxmTextureSwizzle4Mode = 28672;
pub const SCE_GXM_TEXTURE_SWIZZLE4_BGRA: SceGxmTextureSwizzle4Mode = 12288;
pub const SCE_GXM_TEXTURE_SWIZZLE4_RGB1: SceGxmTextureSwizzle4Mode = 24576;
pub const SCE_GXM_TEXTURE_SWIZZLE4_RGBA: SceGxmTextureSwizzle4Mode = 8192;
pub const SCE_GXM_TEXTURE_SWIZZLED: SceGxmTextureType = 0;
pub const SCE_GXM_TEXTURE_SWIZZLED_ARBITRARY: SceGxmTextureType = 2684354560;
pub const SCE_GXM_TEXTURE_SWIZZLE_UYVY_CSC0: SceGxmTextureSwizzleYUV422Mode = 8192;
pub const SCE_GXM_TEXTURE_SWIZZLE_UYVY_CSC1: SceGxmTextureSwizzleYUV422Mode = 24576;
pub const SCE_GXM_TEXTURE_SWIZZLE_VYUY_CSC0: SceGxmTextureSwizzleYUV422Mode = 12288;
pub const SCE_GXM_TEXTURE_SWIZZLE_VYUY_CSC1: SceGxmTextureSwizzleYUV422Mode = 28672;
pub const SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC0: SceGxmTextureSwizzleYUV420Mode = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC1: SceGxmTextureSwizzleYUV420Mode = 8192;
pub const SCE_GXM_TEXTURE_SWIZZLE_YUYV_CSC0: SceGxmTextureSwizzleYUV422Mode = 0;
pub const SCE_GXM_TEXTURE_SWIZZLE_YUYV_CSC1: SceGxmTextureSwizzleYUV422Mode = 16384;
pub const SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC0: SceGxmTextureSwizzleYUV420Mode = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC1: SceGxmTextureSwizzleYUV420Mode = 12288;
pub const SCE_GXM_TEXTURE_SWIZZLE_YVYU_CSC0: SceGxmTextureSwizzleYUV422Mode = 4096;
pub const SCE_GXM_TEXTURE_SWIZZLE_YVYU_CSC1: SceGxmTextureSwizzleYUV422Mode = 20480;
pub const SCE_GXM_TEXTURE_TILED: SceGxmTextureType = 2147483648;
pub const SCE_GXM_TILE_SHIFTX: u32 = 5;
pub const SCE_GXM_TILE_SHIFTY: u32 = 5;
pub const SCE_GXM_TILE_SIZEX: u32 = 32;
pub const SCE_GXM_TILE_SIZEY: u32 = 32;
pub const SCE_GXM_TRANSFER_COLORKEY_NONE: SceGxmTransferColorKeyMode = 0;
pub const SCE_GXM_TRANSFER_COLORKEY_PASS: SceGxmTransferColorKeyMode = 1;
pub const SCE_GXM_TRANSFER_COLORKEY_REJECT: SceGxmTransferColorKeyMode = 2;
pub const SCE_GXM_TRANSFER_FORMAT_RAW128: SceGxmTransferFormat = 1245184;
pub const SCE_GXM_TRANSFER_FORMAT_RAW16: SceGxmTransferFormat = 983040;
pub const SCE_GXM_TRANSFER_FORMAT_RAW32: SceGxmTransferFormat = 1114112;
pub const SCE_GXM_TRANSFER_FORMAT_RAW64: SceGxmTransferFormat = 1179648;
pub const SCE_GXM_TRANSFER_FORMAT_U1U5U5U5_ABGR: SceGxmTransferFormat = 131072;
pub const SCE_GXM_TRANSFER_FORMAT_U2U10U10U10_ABGR: SceGxmTransferFormat = 851968;
pub const SCE_GXM_TRANSFER_FORMAT_U4U4U4U4_ABGR: SceGxmTransferFormat = 65536;
pub const SCE_GXM_TRANSFER_FORMAT_U5U6U5_BGR: SceGxmTransferFormat = 196608;
pub const SCE_GXM_TRANSFER_FORMAT_U8_R: SceGxmTransferFormat = 0;
pub const SCE_GXM_TRANSFER_FORMAT_U8U8_GR: SceGxmTransferFormat = 262144;
pub const SCE_GXM_TRANSFER_FORMAT_U8U8U8_BGR: SceGxmTransferFormat = 327680;
pub const SCE_GXM_TRANSFER_FORMAT_U8U8U8U8_ABGR: SceGxmTransferFormat = 393216;
pub const SCE_GXM_TRANSFER_FORMAT_UYVY422: SceGxmTransferFormat = 589824;
pub const SCE_GXM_TRANSFER_FORMAT_VYUY422: SceGxmTransferFormat = 458752;
pub const SCE_GXM_TRANSFER_FORMAT_YUYV422: SceGxmTransferFormat = 655360;
pub const SCE_GXM_TRANSFER_FORMAT_YVYU422: SceGxmTransferFormat = 524288;
pub const SCE_GXM_TRANSFER_FRAGMENT_SYNC: SceGxmTransferFlags = 1;
pub const SCE_GXM_TRANSFER_LINEAR: SceGxmTransferType = 0;
pub const SCE_GXM_TRANSFER_SWIZZLED: SceGxmTransferType = 8388608;
pub const SCE_GXM_TRANSFER_TILED: SceGxmTransferType = 4194304;
pub const SCE_GXM_TRANSFER_VERTEX_SYNC: SceGxmTransferFlags = 2;
pub const SCE_GXM_TWO_SIDED_DISABLED: SceGxmTwoSidedMode = 0;
pub const SCE_GXM_TWO_SIDED_ENABLED: SceGxmTwoSidedMode = 2048;
pub const SCE_GXM_VERTEX_PROGRAM: SceGxmProgramType = 0;
pub const SCE_GXM_VIEWPORT_DISABLED: SceGxmViewportMode = 65536;
pub const SCE_GXM_VIEWPORT_ENABLED: SceGxmViewportMode = 0;
pub const SCE_GXM_VISIBILITY_TEST_DISABLED: SceGxmVisibilityTestMode = 0;
pub const SCE_GXM_VISIBILITY_TEST_ENABLED: SceGxmVisibilityTestMode = 16384;
pub const SCE_GXM_VISIBILITY_TEST_OP_INCREMENT: SceGxmVisibilityTestOp = 0;
pub const SCE_GXM_VISIBILITY_TEST_OP_SET: SceGxmVisibilityTestOp = 262144;
pub const SCE_GXM_WBUFFER_DISABLED: SceGxmWBufferMode = 0;
pub const SCE_GXM_WBUFFER_ENABLED: SceGxmWBufferMode = 16384;
pub const SCE_GXM_WCLAMP_MODE_DISABLED: SceGxmWClampMode = 0;
pub const SCE_GXM_WCLAMP_MODE_ENABLED: SceGxmWClampMode = 32768;
pub const SCE_GXM_YUV_PROFILE_BT601_FULL_RANGE: SceGxmYuvProfile = 2;
pub const SCE_GXM_YUV_PROFILE_BT601_STANDARD: SceGxmYuvProfile = 0;
pub const SCE_GXM_YUV_PROFILE_BT709_FULL_RANGE: SceGxmYuvProfile = 3;
pub const SCE_GXM_YUV_PROFILE_BT709_STANDARD: SceGxmYuvProfile = 1;
pub const SCE_GXT_ERROR_INVALID_ALIGNMENT: SceGxtErrorCode = 2153578498;
pub const SCE_GXT_ERROR_INVALID_POINTER: SceGxtErrorCode = 2153578497;
pub const SCE_GXT_ERROR_INVALID_VALUE: SceGxtErrorCode = 2153578496;
pub const SCE_HID_MAX_DEVICE_COUNT: u32 = 8;
pub const SCE_HID_MAX_REPORT: u32 = 16;
pub const SCE_HTTP_AUTH_BASIC: SceHttpAuthType = 0;
pub const SCE_HTTP_AUTH_DIGEST: SceHttpAuthType = 1;
pub const SCE_HTTP_AUTH_RESERVED0: SceHttpAuthType = 2;
pub const SCE_HTTP_AUTH_RESERVED1: SceHttpAuthType = 3;
pub const SCE_HTTP_AUTH_RESERVED2: SceHttpAuthType = 4;
pub const SCE_HTTP_DEFAULT_CONNECT_TIMEOUT: u32 = 30000000;
pub const SCE_HTTP_DEFAULT_RECV_BLOCK_SIZE: u32 = 1500;
pub const SCE_HTTP_DEFAULT_RECV_TIMEOUT: u32 = 120000000;
pub const SCE_HTTP_DEFAULT_REDIRECT_MAX: u32 = 6;
pub const SCE_HTTP_DEFAULT_RESOLVER_RETRY: u32 = 5;
pub const SCE_HTTP_DEFAULT_RESOLVER_TIMEOUT: u32 = 1000000;
pub const SCE_HTTP_DEFAULT_RESPONSE_HEADER_MAX: u32 = 5000;
pub const SCE_HTTP_DEFAULT_SEND_TIMEOUT: u32 = 120000000;
pub const SCE_HTTP_DEFAULT_TRY_AUTH_MAX: u32 = 6;
pub const SCE_HTTP_DISABLE: u32 = 0;
pub const SCE_HTTP_ENABLE: u32 = 1;
pub const SCE_HTTP_ERROR_ABORTED: SceHttpErrorCode = 2151878784;
pub const SCE_HTTP_ERROR_AFTER_SEND: SceHttpErrorCode = 2151878758;
pub const SCE_HTTP_ERROR_ALREADY_INITED: SceHttpErrorCode = 2151878688;
pub const SCE_HTTP_ERROR_BAD_RESPONSE: SceHttpErrorCode = 2151878756;
pub const SCE_HTTP_ERROR_BEFORE_INIT: SceHttpErrorCode = 2151878657;
pub const SCE_HTTP_ERROR_BEFORE_SEND: SceHttpErrorCode = 2151878757;
pub const SCE_HTTP_ERROR_BUSY: SceHttpErrorCode = 2151878689;
pub const SCE_HTTP_ERROR_CHUNK_ENC: SceHttpErrorCode = 2151878770;
pub const SCE_HTTP_ERROR_INVALID_ID: SceHttpErrorCode = 2151878912;
pub const SCE_HTTP_ERROR_INVALID_URL: SceHttpErrorCode = 2151886944;
pub const SCE_HTTP_ERROR_INVALID_VALUE: SceHttpErrorCode = 2151879166;
pub const SCE_HTTP_ERROR_INVALID_VERSION: SceHttpErrorCode = 2151878762;
pub const SCE_HTTP_ERROR_NETWORK: SceHttpErrorCode = 2151878755;
pub const SCE_HTTP_ERROR_NO_CONTENT_LENGTH: SceHttpErrorCode = 2151878769;
pub const SCE_HTTP_ERROR_NOT_FOUND: SceHttpErrorCode = 2151878693;
pub const SCE_HTTP_ERROR_NOT_IN_COM: SceHttpErrorCode = 2151878768;
pub const SCE_HTTP_ERROR_OUT_OF_MEMORY: SceHttpErrorCode = 2151878690;
pub const SCE_HTTP_ERROR_OUT_OF_SIZE: SceHttpErrorCode = 2151878916;
pub const SCE_HTTP_ERROR_PARSE_HTTP_INVALID_RESPONSE: SceHttpErrorCode = 2151882848;
pub const SCE_HTTP_ERROR_PARSE_HTTP_INVALID_VALUE: SceHttpErrorCode = 2151883262;
pub const SCE_HTTP_ERROR_PARSE_HTTP_NOT_FOUND: SceHttpErrorCode = 2151882789;
pub const SCE_HTTP_ERROR_READ_BY_HEAD_METHOD: SceHttpErrorCode = 2151878767;
pub const SCE_HTTP_ERROR_RESOLVER_EFORMAT: SceHttpErrorCode = 2151899141;
pub const SCE_HTTP_ERROR_RESOLVER_ENODNS: SceHttpErrorCode = 2151899138;
pub const SCE_HTTP_ERROR_RESOLVER_ENOHOST: SceHttpErrorCode = 2151899143;
pub const SCE_HTTP_ERROR_RESOLVER_ENORECORD: SceHttpErrorCode = 2151899146;
pub const SCE_HTTP_ERROR_RESOLVER_ENOSUPPORT: SceHttpErrorCode = 2151899140;
pub const SCE_HTTP_ERROR_RESOLVER_ENOTIMPLEMENTED: SceHttpErrorCode = 2151899144;
pub const SCE_HTTP_ERROR_RESOLVER_EPACKET: SceHttpErrorCode = 2151899137;
pub const SCE_HTTP_ERROR_RESOLVER_ESERVERFAILURE: SceHttpErrorCode = 2151899142;
pub const SCE_HTTP_ERROR_RESOLVER_ESERVERREFUSED: SceHttpErrorCode = 2151899145;
pub const SCE_HTTP_ERROR_RESOLVER_ETIMEDOUT: SceHttpErrorCode = 2151899139;
pub const SCE_HTTP_ERROR_SSL: SceHttpErrorCode = 2151878773;
pub const SCE_HTTP_ERROR_TIMEOUT: SceHttpErrorCode = 2151878760;
pub const SCE_HTTP_ERROR_TOO_LARGE_RESPONSE_HEADER: SceHttpErrorCode = 2151878771;
pub const SCE_HTTP_ERROR_UNKNOWN: SceHttpErrorCode = 2151878785;
pub const SCE_HTTP_ERROR_UNKNOWN_METHOD: SceHttpErrorCode = 2151878763;
pub const SCE_HTTP_ERROR_UNKNOWN_SCHEME: SceHttpErrorCode = 2151878753;
pub const SCE_HTTP_ERROR_UNKOWN_AUTH_TYPE: SceHttpErrorCode = 2151878761;
pub const SCE_HTTP_HEADER_ADD: SceHttpAddHeaderMode = 1;
pub const SCE_HTTP_HEADER_OVERWRITE: SceHttpAddHeaderMode = 0;
pub const SCE_HTTP_INVALID_ID: u32 = 0;
pub const SCE_HTTP_METHOD_CONNECT: SceHttpMethods = 7;
pub const SCE_HTTP_METHOD_DELETE: SceHttpMethods = 5;
pub const SCE_HTTP_METHOD_GET: SceHttpMethods = 0;
pub const SCE_HTTP_METHOD_HEAD: SceHttpMethods = 2;
pub const SCE_HTTP_METHOD_OPTIONS: SceHttpMethods = 3;
pub const SCE_HTTP_METHOD_POST: SceHttpMethods = 1;
pub const SCE_HTTP_METHOD_PUT: SceHttpMethods = 4;
pub const SCE_HTTP_METHOD_TRACE: SceHttpMethods = 6;
pub const SCE_HTTP_PASSWORD_MAX_SIZE: u32 = 256;
pub const SCE_HTTP_PROXY_AUTO: SceHttpProxyMode = 0;
pub const SCE_HTTP_PROXY_MANUAL: SceHttpProxyMode = 1;
pub const SCE_HTTPS_ERROR_CERT: SceHttpsErrorCode = 2151895136;
pub const SCE_HTTPS_ERROR_HANDSHAKE: SceHttpsErrorCode = 2151895137;
pub const SCE_HTTPS_ERROR_INTERNAL: SceHttpsErrorCode = 2151895139;
pub const SCE_HTTPS_ERROR_IO: SceHttpsErrorCode = 2151895138;
pub const SCE_HTTPS_ERROR_PROXY: SceHttpsErrorCode = 2151895140;
pub const SCE_HTTPS_ERROR_SSL_CN_CHECK: SceHttpsSslErrorCode = 4;
pub const SCE_HTTPS_ERROR_SSL_INTERNAL: SceHttpsSslErrorCode = 1;
pub const SCE_HTTPS_ERROR_SSL_INVALID_CERT: SceHttpsSslErrorCode = 2;
pub const SCE_HTTPS_ERROR_SSL_NOT_AFTER_CHECK: SceHttpsSslErrorCode = 8;
pub const SCE_HTTPS_ERROR_SSL_NOT_BEFORE_CHECK: SceHttpsSslErrorCode = 16;
pub const SCE_HTTPS_ERROR_SSL_UNKNOWN_CA: SceHttpsSslErrorCode = 32;
pub const SCE_HTTPS_FLAG_CLIENT_VERIFY: SceHttpsFlag = 2;
pub const SCE_HTTPS_FLAG_CN_CHECK: SceHttpsFlag = 4;
pub const SCE_HTTPS_FLAG_KNOWN_CA_CHECK: SceHttpsFlag = 32;
pub const SCE_HTTPS_FLAG_NOT_AFTER_CHECK: SceHttpsFlag = 8;
pub const SCE_HTTPS_FLAG_NOT_BEFORE_CHECK: SceHttpsFlag = 16;
pub const SCE_HTTPS_FLAG_SERVER_VERIFY: SceHttpsFlag = 1;
pub const SCE_HTTPS_SSLV2: SceHttpSslVersion = 1;
pub const SCE_HTTPS_SSLV23: SceHttpSslVersion = 0;
pub const SCE_HTTPS_SSLV3: SceHttpSslVersion = 2;
pub const SCE_HTTP_STATUS_CODE_ACCEPTED: SceHttpStatusCode = 202;
pub const SCE_HTTP_STATUS_CODE_BAD_GATEWAY: SceHttpStatusCode = 502;
pub const SCE_HTTP_STATUS_CODE_BAD_REQUEST: SceHttpStatusCode = 400;
pub const SCE_HTTP_STATUS_CODE_CONFLICT: SceHttpStatusCode = 409;
pub const SCE_HTTP_STATUS_CODE_CONTINUE: SceHttpStatusCode = 100;
pub const SCE_HTTP_STATUS_CODE_CREATED: SceHttpStatusCode = 201;
pub const SCE_HTTP_STATUS_CODE_EXPECTATION_FAILED: SceHttpStatusCode = 417;
pub const SCE_HTTP_STATUS_CODE_FAILED_DEPENDENCY: SceHttpStatusCode = 424;
pub const SCE_HTTP_STATUS_CODE_FORBIDDDEN: SceHttpStatusCode = 403;
pub const SCE_HTTP_STATUS_CODE_FOUND: SceHttpStatusCode = 302;
pub const SCE_HTTP_STATUS_CODE_GATEWAY_TIME_OUT: SceHttpStatusCode = 504;
pub const SCE_HTTP_STATUS_CODE_GONE: SceHttpStatusCode = 410;
pub const SCE_HTTP_STATUS_CODE_HTTP_VERSION_NOT_SUPPORTED: SceHttpStatusCode = 505;
pub const SCE_HTTP_STATUS_CODE_INSUFFICIENT_STORAGE: SceHttpStatusCode = 507;
pub const SCE_HTTP_STATUS_CODE_INTERNAL_SERVER_ERROR: SceHttpStatusCode = 500;
pub const SCE_HTTP_STATUS_CODE_LENGTH_REQUIRED: SceHttpStatusCode = 411;
pub const SCE_HTTP_STATUS_CODE_LOCKED: SceHttpStatusCode = 423;
pub const SCE_HTTP_STATUS_CODE_METHOD_NOT_ALLOWED: SceHttpStatusCode = 405;
pub const SCE_HTTP_STATUS_CODE_MOVED_PERMANENTLY: SceHttpStatusCode = 301;
pub const SCE_HTTP_STATUS_CODE_MULTIPLE_CHOICES: SceHttpStatusCode = 300;
pub const SCE_HTTP_STATUS_CODE_MULTI_STATUS: SceHttpStatusCode = 207;
pub const SCE_HTTP_STATUS_CODE_NO_CONTENT: SceHttpStatusCode = 204;
pub const SCE_HTTP_STATUS_CODE_NON_AUTHORITATIVE_INFORMATION: SceHttpStatusCode = 203;
pub const SCE_HTTP_STATUS_CODE_NOT_ACCEPTABLE: SceHttpStatusCode = 406;
pub const SCE_HTTP_STATUS_CODE_NOT_FOUND: SceHttpStatusCode = 404;
pub const SCE_HTTP_STATUS_CODE_NOT_IMPLEMENTED: SceHttpStatusCode = 501;
pub const SCE_HTTP_STATUS_CODE_NOT_MODIFIED: SceHttpStatusCode = 304;
pub const SCE_HTTP_STATUS_CODE_OK: SceHttpStatusCode = 200;
pub const SCE_HTTP_STATUS_CODE_PARTIAL_CONTENT: SceHttpStatusCode = 206;
pub const SCE_HTTP_STATUS_CODE_PAYMENT_REQUIRED: SceHttpStatusCode = 402;
pub const SCE_HTTP_STATUS_CODE_PRECONDITION_FAILED: SceHttpStatusCode = 412;
pub const SCE_HTTP_STATUS_CODE_PROCESSING: SceHttpStatusCode = 102;
pub const SCE_HTTP_STATUS_CODE_PROXY_AUTHENTICATION_REQUIRED: SceHttpStatusCode = 407;
pub const SCE_HTTP_STATUS_CODE_REQUEST_ENTITY_TOO_LARGE: SceHttpStatusCode = 413;
pub const SCE_HTTP_STATUS_CODE_REQUEST_RANGE_NOT_SATISFIBLE: SceHttpStatusCode = 416;
pub const SCE_HTTP_STATUS_CODE_REQUEST_TIME_OUT: SceHttpStatusCode = 408;
pub const SCE_HTTP_STATUS_CODE_REQUEST_URI_TOO_LARGE: SceHttpStatusCode = 414;
pub const SCE_HTTP_STATUS_CODE_RESET_CONTENT: SceHttpStatusCode = 205;
pub const SCE_HTTP_STATUS_CODE_SEE_OTHER: SceHttpStatusCode = 303;
pub const SCE_HTTP_STATUS_CODE_SERVICE_UNAVAILABLE: SceHttpStatusCode = 503;
pub const SCE_HTTP_STATUS_CODE_SWITCHING_PROTOCOLS: SceHttpStatusCode = 101;
pub const SCE_HTTP_STATUS_CODE_TEMPORARY_REDIRECT: SceHttpStatusCode = 307;
pub const SCE_HTTP_STATUS_CODE_UNAUTHORIZED: SceHttpStatusCode = 401;
pub const SCE_HTTP_STATUS_CODE_UNPROCESSABLE_ENTITY: SceHttpStatusCode = 422;
pub const SCE_HTTP_STATUS_CODE_UNSUPPORTED_MEDIA_TYPE: SceHttpStatusCode = 415;
pub const SCE_HTTP_STATUS_CODE_UPGRADE_REQUIRED: SceHttpStatusCode = 426;
pub const SCE_HTTP_STATUS_CODE_USE_PROXY: SceHttpStatusCode = 305;
pub const SCE_HTTPS_TLSV1: SceHttpSslVersion = 3;
pub const SCE_HTTP_URI_BUILD_WITH_ALL: SceHttpUriBuildType = 65535;
pub const SCE_HTTP_URI_BUILD_WITH_FRAGMENT: SceHttpUriBuildType = 128;
pub const SCE_HTTP_URI_BUILD_WITH_HOSTNAME: SceHttpUriBuildType = 2;
pub const SCE_HTTP_URI_BUILD_WITH_PASSWORD: SceHttpUriBuildType = 32;
pub const SCE_HTTP_URI_BUILD_WITH_PATH: SceHttpUriBuildType = 8;
pub const SCE_HTTP_URI_BUILD_WITH_PORT: SceHttpUriBuildType = 4;
pub const SCE_HTTP_URI_BUILD_WITH_QUERY: SceHttpUriBuildType = 64;
pub const SCE_HTTP_URI_BUILD_WITH_SCHEME: SceHttpUriBuildType = 1;
pub const SCE_HTTP_URI_BUILD_WITH_USERNAME: SceHttpUriBuildType = 16;
pub const SCE_HTTP_USERNAME_MAX_SIZE: u32 = 256;
pub const SCE_HTTP_VERSION_1_0: SceHttpVersion = 1;
pub const SCE_HTTP_VERSION_1_1: SceHttpVersion = 2;
pub const SCE_I2C_ERROR_INVALID_ADDR: SceI2cErrorCode = 2151613187;
pub const SCE_I2C_ERROR_INVALID_BUS: SceI2cErrorCode = 2151613184;
pub const SCE_I2C_ERROR_INVALID_SIZE: SceI2cErrorCode = 2151613186;
pub const SCE_IFTU_ERROR_INVALID_PARAM: SceIftuErrorCode = 2151614209;
pub const SCE_IFTU_ERROR_INVALID_PIXELFORMAT: SceIftuErrorCode = 2151614211;
pub const SCE_IFTU_ERROR_INVALID_PLANE: SceIftuErrorCode = 2151614208;
pub const SCE_IFTU_ERROR_PLANE_BUSY: SceIftuErrorCode = 2151614212;
pub const SCE_IFTU_PIXELFORMAT_BGR565: SceIftuPixelformat = 1;
pub const SCE_IFTU_PIXELFORMAT_BGRA1010102: SceIftuPixelformat = 64;
pub const SCE_IFTU_PIXELFORMAT_BGRA1010102_MULT: SceIftuPixelformat = 32768;
pub const SCE_IFTU_PIXELFORMAT_BGRA5551: SceIftuPixelformat = 4;
pub const SCE_IFTU_PIXELFORMAT_BGRP: SceIftuPixelformat = 256;
pub const SCE_IFTU_PIXELFORMAT_BGRX8888: SceIftuPixelformat = 16;
pub const SCE_IFTU_PIXELFORMAT_BGRX8888_MULT: SceIftuPixelformat = 8192;
pub const SCE_IFTU_PIXELFORMAT_NV12: SceIftuPixelformat = 65536;
pub const SCE_IFTU_PIXELFORMAT_RGB565: SceIftuPixelformat = 2;
pub const SCE_IFTU_PIXELFORMAT_RGBA1010102: SceIftuPixelformat = 128;
pub const SCE_IFTU_PIXELFORMAT_RGBA1010102_MULT: SceIftuPixelformat = 16384;
pub const SCE_IFTU_PIXELFORMAT_RGBA5551: SceIftuPixelformat = 8;
pub const SCE_IFTU_PIXELFORMAT_RGBX8888: SceIftuPixelformat = 32;
pub const SCE_IFTU_PIXELFORMAT_RGBX8888_MULT: SceIftuPixelformat = 4096;
pub const SCE_IFTU_PIXELFORMAT_YUV420: SceIftuPixelformat = 131072;
pub const SCE_IFTU_PIXELFORMAT_YUV422: SceIftuPixelformat = 2097152;
pub const SCE_IME_DIALOG_BUTTON_CLOSE: SceImeDialogButton = 1;
pub const SCE_IME_DIALOG_BUTTON_ENTER: SceImeDialogButton = 2;
pub const SCE_IME_DIALOG_BUTTON_NONE: SceImeDialogButton = 0;
pub const SCE_IME_DIALOG_DIALOG_MODE_DEFAULT: SceImeDialogDialogMode = 0;
pub const SCE_IME_DIALOG_DIALOG_MODE_WITH_CANCEL: SceImeDialogDialogMode = 1;
pub const SCE_IME_DIALOG_ERROR_INTERNAL: SceImeDialogErrorCode = 2148540418;
pub const SCE_IME_DIALOG_ERROR_INVALID_DIALOG_MODE: SceImeDialogErrorCode = 2148540419;
pub const SCE_IME_DIALOG_ERROR_INVALID_TEXT_BOX_MODE: SceImeDialogErrorCode = 2148540420;
pub const SCE_IME_DIALOG_ERROR_INVALID_TITLE: SceImeDialogErrorCode = 2148540421;
pub const SCE_IME_DIALOG_ERROR_PARAM: SceImeDialogErrorCode = 2148540417;
pub const SCE_IME_DIALOG_MAX_TEXT_LENGTH: u32 = 2048;
pub const SCE_IME_DIALOG_MAX_TITLE_LENGTH: u32 = 128;
pub const SCE_IME_DIALOG_TEXTBOX_MODE_DEFAULT: SceImeDialogTextboxMode = 0;
pub const SCE_IME_DIALOG_TEXTBOX_MODE_PASSWORD: SceImeDialogTextboxMode = 1;
pub const SCE_IME_DIALOG_TEXTBOX_MODE_WITH_CLEAR: SceImeDialogTextboxMode = 2;
pub const SCE_IME_ENTER_LABEL_DEFAULT: SceImeEnterLabel = 0;
pub const SCE_IME_ENTER_LABEL_GO: SceImeEnterLabel = 3;
pub const SCE_IME_ENTER_LABEL_SEARCH: SceImeEnterLabel = 2;
pub const SCE_IME_ENTER_LABEL_SEND: SceImeEnterLabel = 1;
pub const SCE_IME_ERROR_ALREADY_OPENED: SceImeErrorCode = 2148534016;
pub const SCE_IME_ERROR_CONNECTION_FAILED: SceImeErrorCode = 2148534021;
pub const SCE_IME_ERROR_INTERNAL: SceImeErrorCode = 2148534096;
pub const SCE_IME_ERROR_INVALID_ARG: SceImeErrorCode = 2148534039;
pub const SCE_IME_ERROR_INVALID_ENTER_LABEL: SceImeErrorCode = 2148534044;
pub const SCE_IME_ERROR_INVALID_HANDLER: SceImeErrorCode = 2148534040;
pub const SCE_IME_ERROR_INVALID_INPUT_METHOD: SceImeErrorCode = 2148534034;
pub const SCE_IME_ERROR_INVALID_INPUT_TEXT_BUFFER: SceImeErrorCode = 2148534042;
pub const SCE_IME_ERROR_INVALID_MAX_TEXT_LENGTH: SceImeErrorCode = 2148534041;
pub const SCE_IME_ERROR_INVALID_OPTION: SceImeErrorCode = 2148534037;
pub const SCE_IME_ERROR_INVALID_PARAM: SceImeErrorCode = 2148534019;
pub const SCE_IME_ERROR_INVALID_POINTER: SceImeErrorCode = 2148534018;
pub const SCE_IME_ERROR_INVALID_RESERVED: SceImeErrorCode = 2148534043;
pub const SCE_IME_ERROR_INVALID_SIZE: SceImeErrorCode = 2148534032;
pub const SCE_IME_ERROR_INVALID_SUPPORTED_LANGUAGES: SceImeErrorCode = 2148534035;
pub const SCE_IME_ERROR_INVALID_TEXT: SceImeErrorCode = 2148534022;
pub const SCE_IME_ERROR_INVALID_TYPE: SceImeErrorCode = 2148534036;
pub const SCE_IME_ERROR_INVALID_WORK: SceImeErrorCode = 2148534038;
pub const SCE_IME_ERROR_NO_MEMORY: SceImeErrorCode = 2148534020;
pub const SCE_IME_ERROR_NOT_OPENED: SceImeErrorCode = 2148534017;
pub const SCE_IME_ERROR_TOO_MANY_REQUESTS: SceImeErrorCode = 2148534023;
pub const SCE_IME_EVENT_CHANGE_SIZE: SceImeEvent = 3;
pub const SCE_IME_EVENT_OPEN: SceImeEvent = 0;
pub const SCE_IME_EVENT_PRESS_CLOSE: SceImeEvent = 4;
pub const SCE_IME_EVENT_PRESS_ENTER: SceImeEvent = 5;
pub const SCE_IME_EVENT_UPDATE_CARET: SceImeEvent = 2;
pub const SCE_IME_EVENT_UPDATE_TEXT: SceImeEvent = 1;
pub const SCE_IME_LANGUAGE_DANISH: SceImeLanguage = 1;
pub const SCE_IME_LANGUAGE_DUTCH: SceImeLanguage = 64;
pub const SCE_IME_LANGUAGE_ENGLISH: SceImeLanguage = 4;
pub const SCE_IME_LANGUAGE_ENGLISH_GB: SceImeLanguage = 262144;
pub const SCE_IME_LANGUAGE_FINNISH: SceImeLanguage = 2048;
pub const SCE_IME_LANGUAGE_FRENCH: SceImeLanguage = 16;
pub const SCE_IME_LANGUAGE_GERMAN: SceImeLanguage = 2;
pub const SCE_IME_LANGUAGE_ITALIAN: SceImeLanguage = 32;
pub const SCE_IME_LANGUAGE_JAPANESE: SceImeLanguage = 8192;
pub const SCE_IME_LANGUAGE_KOREAN: SceImeLanguage = 16384;
pub const SCE_IME_LANGUAGE_NORWEGIAN: SceImeLanguage = 128;
pub const SCE_IME_LANGUAGE_POLISH: SceImeLanguage = 256;
pub const SCE_IME_LANGUAGE_PORTUGUESE: SceImeLanguage = 512;
pub const SCE_IME_LANGUAGE_PORTUGUESE_BR: SceImeLanguage = 131072;
pub const SCE_IME_LANGUAGE_RUSSIAN: SceImeLanguage = 1024;
pub const SCE_IME_LANGUAGE_SIMPLIFIED_CHINESE: SceImeLanguage = 32768;
pub const SCE_IME_LANGUAGE_SPANISH: SceImeLanguage = 8;
pub const SCE_IME_LANGUAGE_SWEDISH: SceImeLanguage = 4096;
pub const SCE_IME_LANGUAGE_TRADITIONAL_CHINESE: SceImeLanguage = 65536;
pub const SCE_IME_LANGUAGE_TURKISH: SceImeLanguage = 524288;
pub const SCE_IME_MAX_PREEDIT_LENGTH: u32 = 30;
pub const SCE_IME_MAX_TEXT_LENGTH: u32 = 2048;
pub const SCE_IME_OPTION_MULTILINE: SceImeOption = 1;
pub const SCE_IME_OPTION_NO_ASSISTANCE: SceImeOption = 4;
pub const SCE_IME_OPTION_NO_AUTO_CAPITALIZATION: SceImeOption = 2;
pub const SCE_IME_TYPE_BASIC_LATIN: SceImeType = 1;
pub const SCE_IME_TYPE_DEFAULT: SceImeType = 0;
pub const SCE_IME_TYPE_EXTENDED_NUMBER: SceImeType = 3;
pub const SCE_IME_TYPE_MAIL: SceImeType = 5;
pub const SCE_IME_TYPE_NUMBER: SceImeType = 2;
pub const SCE_IME_TYPE_URL: SceImeType = 4;
pub const SCE_IME_WORK_BUFFER_SIZE: u32 = 20480;
pub const SCE_INCOMING_DIALOG_ACCEPTED: SceIncomingDialogStatus = 1;
pub const SCE_INCOMING_DIALOG_BUSY: SceIncomingDialogStatus = 5;
pub const SCE_INCOMING_DIALOG_CLOSED: SceIncomingDialogStatus = 4;
pub const SCE_INCOMINGDIALOG_ERROR_INVALID_ARG: SceIncomingDialogErrorCode = 2148557313;
pub const SCE_INCOMING_DIALOG_NOT_RUNNING: SceIncomingDialogStatus = 0;
pub const SCE_INCOMING_DIALOG_REJECTED: SceIncomingDialogStatus = 3;
pub const SCE_INCOMING_DIALOG_RUNNING: SceIncomingDialogStatus = 2;
pub const SCE_INCOMING_DIALOG_TIMEOUT: SceIncomingDialogStatus = 6;
pub const SCE_JPEG_ARM_OK: SceJpegArmErrorCode = 0;
pub const SCE_JPEGENCARM_DEFAULT_COMP_RATIO: u32 = 64;
#[doc = "The image dimensions given are not supported, or are larger\n than those set at initialization."]
pub const SCE_JPEGENCARM_ERROR_IMAGE_SIZE: SceJpegEncArmErrorCode = 2154103552;
#[doc = "The output buffer provided is not of sufficient size."]
pub const SCE_JPEGENCARM_ERROR_INSUFFICIENT_BUFFER: SceJpegEncArmErrorCode = 2154103553;
#[doc = "The compression ratio given is not within the valid range."]
pub const SCE_JPEGENCARM_ERROR_INVALID_COMP_RATIO: SceJpegEncArmErrorCode = 2154103554;
#[doc = "The headerMode given is not one of ::SceJpegArmEncoderHeaderMode."]
pub const SCE_JPEGENCARM_ERROR_INVALID_HEADER_MODE: SceJpegEncArmErrorCode = 2154103556;
#[doc = "The pixelformat given is not one of ::SceJpegArmEncoderPixelFormat."]
pub const SCE_JPEGENCARM_ERROR_INVALID_PIXELFORMAT: SceJpegEncArmErrorCode = 2154103555;
#[doc = "A null or badly aligned pointer was given."]
pub const SCE_JPEGENCARM_ERROR_INVALID_POINTER: SceJpegEncArmErrorCode = 2154103557;
#[doc = "JPEG header mode"]
pub const SCE_JPEGENCARM_HEADER_MODE_JPEG: SceJpegArmEncoderHeaderMode = 0;
#[doc = "MJPEG header mode"]
pub const SCE_JPEGENCARM_HEADER_MODE_MJPEG: SceJpegArmEncoderHeaderMode = 1;
pub const SCE_JPEGENCARM_MAX_COMP_RATIO: u32 = 255;
pub const SCE_JPEGENCARM_MIN_COMP_RATIO: u32 = 1;
#[doc = "YCbCr420 format"]
pub const SCE_JPEGENCARM_PIXELFORMAT_YCBCR420: SceJpegArmEncoderPixelFormat = 8;
#[doc = "YCbCr422 format"]
pub const SCE_JPEGENCARM_PIXELFORMAT_YCBCR422: SceJpegArmEncoderPixelFormat = 9;
pub const SCE_JPEGENC_ERROR_IMAGE_SIZE: SceJpegEncErrorCode = 2154103296;
pub const SCE_JPEGENC_ERROR_INSUFFICIENT_BUFFER: SceJpegEncErrorCode = 2154103297;
pub const SCE_JPEGENC_ERROR_INVALID_COMPRATIO: SceJpegEncErrorCode = 2154103298;
pub const SCE_JPEGENC_ERROR_INVALID_HEADER_MODE: SceJpegEncErrorCode = 2154103300;
pub const SCE_JPEGENC_ERROR_INVALID_PIXELFORMAT: SceJpegEncErrorCode = 2154103299;
pub const SCE_JPEGENC_ERROR_INVALID_POINTER: SceJpegEncErrorCode = 2154103301;
pub const SCE_JPEGENC_ERROR_NOT_PHY_CONTINUOUS_MEMORY: SceJpegEncErrorCode = 2154103302;
#[doc = "JPEG header mode"]
pub const SCE_JPEGENC_HEADER_MODE_JPEG: SceJpegEncoderHeaderMode = 0;
#[doc = "MJPEG header mode"]
pub const SCE_JPEGENC_HEADER_MODE_MJPEG: SceJpegEncoderHeaderMode = 1;
#[doc = "LPDDR2 memory will be used instead of CDRAM"]
pub const SCE_JPEGENC_INIT_PARAM_OPTION_LPDDR2_MEMORY: SceJpegEncoderInitParamOption = 1;
#[doc = "Default option"]
pub const SCE_JPEGENC_INIT_PARAM_OPTION_NONE: SceJpegEncoderInitParamOption = 0;
#[doc = "ARGB8888 format"]
pub const SCE_JPEGENC_PIXELFORMAT_ARGB8888: SceJpegEncoderPixelFormat = 0;
#[doc = "ARGB to YCbCr color conversion flag"]
pub const SCE_JPEGENC_PIXELFORMAT_CSC_ARGB_YCBCR: SceJpegEncoderPixelFormat = 16;
#[doc = "YCbCr420 format"]
pub const SCE_JPEGENC_PIXELFORMAT_YCBCR420: SceJpegEncoderPixelFormat = 8;
#[doc = "YCbCr422 format"]
pub const SCE_JPEGENC_PIXELFORMAT_YCBCR422: SceJpegEncoderPixelFormat = 9;
pub const SCE_KERNEL_128KiB: u32 = 131072;
pub const SCE_KERNEL_128MiB: u32 = 134217728;
pub const SCE_KERNEL_16GiB: u64 = 17179869184;
pub const SCE_KERNEL_16KiB: u32 = 16384;
pub const SCE_KERNEL_16MiB: u32 = 16777216;
pub const SCE_KERNEL_1GiB: u32 = 1073741824;
pub const SCE_KERNEL_1KiB: u32 = 1024;
pub const SCE_KERNEL_1MiB: u32 = 1048576;
pub const SCE_KERNEL_256KiB: u32 = 262144;
pub const SCE_KERNEL_256MiB: u32 = 268435456;
pub const SCE_KERNEL_2GiB: u32 = 2147483648;
pub const SCE_KERNEL_2KiB: u32 = 2048;
pub const SCE_KERNEL_2MiB: u32 = 2097152;
pub const SCE_KERNEL_32GiB: u64 = 34359738368;
pub const SCE_KERNEL_32KiB: u32 = 32768;
pub const SCE_KERNEL_32MiB: u32 = 33554432;
pub const SCE_KERNEL_4GiB: u64 = 4294967296;
pub const SCE_KERNEL_4KiB: u32 = 4096;
pub const SCE_KERNEL_4MiB: u32 = 4194304;
pub const SCE_KERNEL_512KiB: u32 = 524288;
pub const SCE_KERNEL_512MiB: u32 = 536870912;
pub const SCE_KERNEL_64KiB: u32 = 65536;
pub const SCE_KERNEL_64MiB: u32 = 67108864;
pub const SCE_KERNEL_8GiB: u64 = 8589934592;
pub const SCE_KERNEL_8KiB: u32 = 8192;
pub const SCE_KERNEL_8MiB: u32 = 8388608;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_ALLOW_PARTIAL_OP: SceKernelAllocMemBlockAttr = 67108864;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_HAS_ALIGNMENT: SceKernelAllocMemBlockAttr = 4;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_HAS_MIRROR_BLOCKID: SceKernelAllocMemBlockAttr = 64;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_HAS_PADDR: SceKernelAllocMemBlockAttr = 2;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_HAS_PADDR_LIST: SceKernelAllocMemBlockAttr = 4096;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_HAS_PID: SceKernelAllocMemBlockAttr = 128;
pub const SCE_KERNEL_ALLOC_MEMBLOCK_ATTR_PHYCONT: SceKernelAllocMemBlockAttr = 2097152;
pub const SCE_KERNEL_ASSERT_LEVEL_0: SceKernelAssertLevel = 0;
pub const SCE_KERNEL_ASSERT_LEVEL_1: SceKernelAssertLevel = 1;
pub const SCE_KERNEL_ASSERT_LEVEL_2: SceKernelAssertLevel = 2;
#[doc = "Sync object can be accessed by sceKernelOpenXxx"]
pub const SCE_KERNEL_ATTR_OPENABLE: SceKernelWaitableAttribute = 128;
#[doc = "Waiting threads First input First output"]
pub const SCE_KERNEL_ATTR_THREAD_FIFO: SceKernelWaitableAttribute = 0;
#[doc = "Waiting threads queued on priority basis"]
pub const SCE_KERNEL_ATTR_THREAD_PRIO: SceKernelWaitableAttribute = 8192;
pub const SCE_KERNEL_CPU_MASK_SYSTEM: u32 = 524288;
pub const SCE_KERNEL_CPU_MASK_USER_0: u32 = 65536;
pub const SCE_KERNEL_CPU_MASK_USER_1: u32 = 131072;
pub const SCE_KERNEL_CPU_MASK_USER_2: u32 = 262144;
pub const SCE_KERNEL_CPU_MASK_USER_ALL: u32 = 458752;
pub const SCE_KERNEL_DEBUG_INFO_FLAG_CORE: SceKernelDebugInfoFlags = 1;
pub const SCE_KERNEL_DEBUG_INFO_FLAG_FILE: SceKernelDebugInfoFlags = 8;
pub const SCE_KERNEL_DEBUG_INFO_FLAG_FUNC: SceKernelDebugInfoFlags = 2;
pub const SCE_KERNEL_DEBUG_INFO_FLAG_LINE: SceKernelDebugInfoFlags = 4;
pub const SCE_KERNEL_DEBUG_INFO_FLAG_NONE: SceKernelDebugInfoFlags = 0;
pub const SCE_KERNEL_DEBUG_LEVEL_ALWAYS: SceKernelDebugLevel = 0;
pub const SCE_KERNEL_DEBUG_LEVEL_DEBUG: SceKernelDebugLevel = 1;
pub const SCE_KERNEL_DEBUG_LEVEL_TRACE: SceKernelDebugLevel = 2;
pub const SCE_KERNEL_DMAC_BLOCKSIZE_DST_MASK: u32 = 4294901760;
pub const SCE_KERNEL_DMAC_BLOCKSIZE_DST_SHIFT: u32 = 16;
pub const SCE_KERNEL_DMAC_BLOCKSIZE_SRC_MASK: u32 = 65535;
pub const SCE_KERNEL_DMAC_BLOCKSIZE_SRC_SHIFT: u32 = 0;
pub const SCE_KERNEL_DMAC_CMD_COHERENT_DST: u32 = 33554432;
pub const SCE_KERNEL_DMAC_CMD_COHERENT_IV_READ: u32 = 67108864;
pub const SCE_KERNEL_DMAC_CMD_COHERENT_IV_WRITE: u32 = 134217728;
pub const SCE_KERNEL_DMAC_CMD_COHERENT_SRC: u32 = 16777216;
pub const SCE_KERNEL_DMAC_CMD_HASH_FINALIZE: u32 = 2048;
pub const SCE_KERNEL_DMAC_CMD_HASH_UPDATE: u32 = 1024;
pub const SCE_KERNEL_DMAC_CMD_KEYSIZE_128BIT: u32 = 256;
pub const SCE_KERNEL_DMAC_CMD_KEYSIZE_192BIT: u32 = 512;
pub const SCE_KERNEL_DMAC_CMD_KEYSIZE_256BIT: u32 = 768;
pub const SCE_KERNEL_DMAC_CMD_KEYSIZE_64BIT: u32 = 0;
pub const SCE_KERNEL_DMAC_CMD_OP_COPY: u32 = 0;
pub const SCE_KERNEL_DMAC_CMD_OP_DECRYPT_AES_CBC: u32 = 10;
pub const SCE_KERNEL_DMAC_CMD_OP_DECRYPT_AES_CTR: u32 = 18;
pub const SCE_KERNEL_DMAC_CMD_OP_DECRYPT_AES_ECB: u32 = 2;
pub const SCE_KERNEL_DMAC_CMD_OP_DECRYPT_DES_CBC: u32 = 74;
pub const SCE_KERNEL_DMAC_CMD_OP_DECRYPT_DES_ECB: u32 = 66;
pub const SCE_KERNEL_DMAC_CMD_OP_ENCRYPT_AES_CBC: u32 = 9;
pub const SCE_KERNEL_DMAC_CMD_OP_ENCRYPT_AES_CTR: u32 = 17;
pub const SCE_KERNEL_DMAC_CMD_OP_ENCRYPT_AES_ECB: u32 = 1;
pub const SCE_KERNEL_DMAC_CMD_OP_ENCRYPT_DES_CBC: u32 = 73;
pub const SCE_KERNEL_DMAC_CMD_OP_ENCRYPT_DES_ECB: u32 = 65;
pub const SCE_KERNEL_DMAC_CMD_OP_HASH_SHA1: u32 = 3;
pub const SCE_KERNEL_DMAC_CMD_OP_HASH_SHA224: u32 = 11;
pub const SCE_KERNEL_DMAC_CMD_OP_HASH_SHA256: u32 = 19;
pub const SCE_KERNEL_DMAC_CMD_OP_HMAC_SHA1: u32 = 35;
pub const SCE_KERNEL_DMAC_CMD_OP_HMAC_SHA224: u32 = 43;
pub const SCE_KERNEL_DMAC_CMD_OP_HMAC_SHA256: u32 = 51;
pub const SCE_KERNEL_DMAC_CMD_OP_RNG: u32 = 4;
pub const SCE_KERNEL_DMAC_CMD_OP_SET: u32 = 12;
pub const SCE_KERNEL_DMAC_CMD_USE_EXTERNAL_KEY: u32 = 128;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_DST_MASK: u32 = 261632;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_DST_SHIFT: u32 = 9;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_SRC_DST_MASK: u32 = 262143;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_SRC_MASK: u32 = 511;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_SRC_SHIFT: u32 = 0;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_UNK_MASK: u32 = 133955584;
pub const SCE_KERNEL_DMAC_COHERENCY_MSK_UNK_SHIFT: u32 = 18;
#[doc = "DMAC0/1"]
pub const SCE_KERNEL_DMAC_ID_DMAC01: SceKernelDmacId = 16;
#[doc = "DMAC2/3"]
pub const SCE_KERNEL_DMAC_ID_DMAC23: SceKernelDmacId = 17;
#[doc = "DMAC4"]
pub const SCE_KERNEL_DMAC_ID_DMAC4: SceKernelDmacId = 18;
#[doc = "DMAC5"]
pub const SCE_KERNEL_DMAC_ID_DMAC5: SceKernelDmacId = 19;
#[doc = "DMAC6 (Devkit only)"]
pub const SCE_KERNEL_DMAC_ID_DMAC6: SceKernelDmacId = 20;
pub const SCE_KERNEL_DMAC_IV_COHERENCY_MSK_READ_MASK: u32 = 511;
pub const SCE_KERNEL_DMAC_IV_COHERENCY_MSK_READ_SHIFT: u32 = 0;
pub const SCE_KERNEL_DMAC_IV_COHERENCY_MSK_RW_MASK: u32 = 33489407;
pub const SCE_KERNEL_DMAC_IV_COHERENCY_MSK_WRITE_MASK: u32 = 33488896;
pub const SCE_KERNEL_DMAC_IV_COHERENCY_MSK_WRITE_SHIFT: u32 = 16;
pub const SCE_KERNEL_DMAC_STAT_ABORTED: u32 = 2;
pub const SCE_KERNEL_DMAC_STAT_BUSY: u32 = 1;
pub const SCE_KERNEL_DMAC_STAT_ERROR_ILLEGAL_CONFIG: u32 = 262144;
pub const SCE_KERNEL_DMAC_STAT_ERROR_READ: u32 = 65536;
pub const SCE_KERNEL_DMAC_STAT_ERROR_TAG: u32 = 524288;
pub const SCE_KERNEL_DMAC_STAT_ERROR_WRITE: u32 = 131072;
pub const SCE_KERNEL_DMAC_STAT_ERROR_ZERO_BYTE: u32 = 1048576;
#[doc = "Full DMA chain is provided, starting from pTag and ending with pTag + 1"]
pub const SCE_KERNEL_DMA_OP_COMPLETE_CHAIN: SceKernelDmaOpFlag = 256;
#[doc = "src and dst addresses are physical addresses"]
pub const SCE_KERNEL_DMA_OP_PHYSICAL_ADDR: SceKernelDmaOpFlag = 0;
#[doc = "Poll for completion without waiting"]
pub const SCE_KERNEL_DMA_OP_SYNC_POLL: SceKernelDmaOpSyncMode = 1;
#[doc = "Wait for completion with timeout"]
pub const SCE_KERNEL_DMA_OP_SYNC_TIMED_WAIT: SceKernelDmaOpSyncMode = 3;
#[doc = "Wait for completion"]
pub const SCE_KERNEL_DMA_OP_SYNC_WAIT: SceKernelDmaOpSyncMode = 2;
#[doc = "Both src and dst addresses are virtual addresses"]
pub const SCE_KERNEL_DMA_OP_VIRTUAL_ADDR: SceKernelDmaOpFlag = 17;
#[doc = "dst addresses is virtual addresses"]
pub const SCE_KERNEL_DMA_OP_VIRTUAL_DST_ADDR: SceKernelDmaOpFlag = 16;
#[doc = "src addresses are virtual addresses"]
pub const SCE_KERNEL_DMA_OP_VIRTUAL_SRC_ADDR: SceKernelDmaOpFlag = 1;
pub const SCE_KERNEL_ERROR_ADDRESS_SPACE_CANNOT_FIND_PARTITION_BY_ADDR: SceKernelErrorCode =
    2147633667;
pub const SCE_KERNEL_ERROR_ALARM_CAN_NOT_CANCEL: SceKernelErrorCode = 2147647682;
pub const SCE_KERNEL_ERROR_ALARM_ERROR: SceKernelErrorCode = 2147647680;
pub const SCE_KERNEL_ERROR_ALREADY_DEBUG_SUSPENDED: SceKernelErrorCode = 2147647535;
pub const SCE_KERNEL_ERROR_ALREADY_QUEUED: SceKernelErrorCode = 2147643905;
pub const SCE_KERNEL_ERROR_ALREADY_REGISTERED: SceKernelErrorCode = 2147647491;
pub const SCE_KERNEL_ERROR_ALREADY_SENT: SceKernelErrorCode = 2147647777;
pub const SCE_KERNEL_ERROR_AUTHFAIL: SceKernelErrorCode = 2147676160;
pub const SCE_KERNEL_ERROR_BLOCK_ERROR: SceKernelErrorCode = 2147632896;
pub const SCE_KERNEL_ERROR_BLOCK_IN_USE: SceKernelErrorCode = 2147632899;
pub const SCE_KERNEL_ERROR_CALLBACK_ERROR: SceKernelErrorCode = 2147647648;
pub const SCE_KERNEL_ERROR_CALLBACK_NOT_REGISTERED: SceKernelErrorCode = 2147647651;
pub const SCE_KERNEL_ERROR_CANCELING: SceKernelErrorCode = 2147643912;
pub const SCE_KERNEL_ERROR_CANNOT_ALLOC_BITHEAP: SceKernelErrorCode = 2147634433;
pub const SCE_KERNEL_ERROR_CANNOT_ALLOC_PHYMEMLOW: SceKernelErrorCode = 2147634177;
pub const SCE_KERNEL_ERROR_CANNOT_GROW_PHYMEMPART: SceKernelErrorCode = 2147631880;
pub const SCE_KERNEL_ERROR_CANNOT_RELEASE_EXCPHANDLER: SceKernelErrorCode = 2147643396;
pub const SCE_KERNEL_ERROR_CAN_NOT_SUSPEND: SceKernelErrorCode = 2147647531;
pub const SCE_KERNEL_ERROR_CAN_NOT_USE_VFP: SceKernelErrorCode = 2147647537;
pub const SCE_KERNEL_ERROR_CAN_NOT_WAIT: SceKernelErrorCode = 2147647492;
pub const SCE_KERNEL_ERROR_COND_ERROR: SceKernelErrorCode = 2147647904;
pub const SCE_KERNEL_ERROR_CP14_DISABLED: SceKernelErrorCode = 2147651592;
pub const SCE_KERNEL_ERROR_CPU_ERROR: SceKernelErrorCode = 2147622912;
pub const SCE_KERNEL_ERROR_DEBUG_ERROR: SceKernelErrorCode = 2147618816;
pub const SCE_KERNEL_ERROR_DELETED: SceKernelErrorCode = 2147647530;
pub const SCE_KERNEL_ERROR_DIFFERENT_UID_CLASS: SceKernelErrorCode = 2147647490;
pub const SCE_KERNEL_ERROR_DMACMGR_ERROR: SceKernelErrorCode = 2147643904;
pub const SCE_KERNEL_ERROR_DORMANT: SceKernelErrorCode = 2147647527;
pub const SCE_KERNEL_ERROR_DUPLICATE_NAME: SceKernelErrorCode = 2147634690;
pub const SCE_KERNEL_ERROR_ERROR: SceKernelErrorCode = 2147614721;
pub const SCE_KERNEL_ERROR_EVENT_COND: SceKernelErrorCode = 2147648002;
pub const SCE_KERNEL_ERROR_EVENT_ERROR: SceKernelErrorCode = 2147648000;
pub const SCE_KERNEL_ERROR_EVENT_NOT_SET: SceKernelErrorCode = 2147648066;
pub const SCE_KERNEL_ERROR_EVF_COND: SceKernelErrorCode = 2147647715;
pub const SCE_KERNEL_ERROR_EVF_ERROR: SceKernelErrorCode = 2147647712;
pub const SCE_KERNEL_ERROR_EVF_MULTI: SceKernelErrorCode = 2147647714;
pub const SCE_KERNEL_ERROR_EXCEEDED_MAX_PROCESSES: SceKernelErrorCode = 2147651593;
pub const SCE_KERNEL_ERROR_EXCPMGR_ERROR: SceKernelErrorCode = 2147643392;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_ALREADY_INITIALIZED: SceKernelErrorCode = 2147647847;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_ERROR: SceKernelErrorCode = 2147647840;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_FAILED_TO_OWN: SceKernelErrorCode = 2147647844;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_LOCK_OVF: SceKernelErrorCode = 2147647843;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_NOT_INITIALIZED: SceKernelErrorCode = 2147647848;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_NOT_OWNED: SceKernelErrorCode = 2147647845;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_OWNED: SceKernelErrorCode = 2147647846;
pub const SCE_KERNEL_ERROR_FAST_MUTEX_RECURSIVE: SceKernelErrorCode = 2147647842;
pub const SCE_KERNEL_ERROR_FIXEDHEAP_ERROR: SceKernelErrorCode = 2147632128;
pub const SCE_KERNEL_ERROR_FIXEDHEAP_ILLEGAL_INDEX: SceKernelErrorCode = 2147632130;
pub const SCE_KERNEL_ERROR_FIXEDHEAP_ILLEGAL_SIZE: SceKernelErrorCode = 2147632129;
pub const SCE_KERNEL_ERROR_FIXEDHEAP_INDEX_OVERFLOW: SceKernelErrorCode = 2147632131;
pub const SCE_KERNEL_ERROR_FIXEDHEAP_NO_CHUNK: SceKernelErrorCode = 2147632132;
pub const SCE_KERNEL_ERROR_FOUND_HANDLER: SceKernelErrorCode = 2147643657;
pub const SCE_KERNEL_ERROR_HEAPLIB_ERROR: SceKernelErrorCode = 2147633408;
pub const SCE_KERNEL_ERROR_HEAPLIB_NOMEM: SceKernelErrorCode = 2147633411;
pub const SCE_KERNEL_ERROR_HEAPLIB_VERIFY_ERROR: SceKernelErrorCode = 2147633412;
pub const SCE_KERNEL_ERROR_ILLEGAL_ADDR: SceKernelErrorCode = 2147614726;
pub const SCE_KERNEL_ERROR_ILLEGAL_ALIGNMENT: SceKernelErrorCode = 2147614727;
pub const SCE_KERNEL_ERROR_ILLEGAL_ATTR: SceKernelErrorCode = 2147614734;
pub const SCE_KERNEL_ERROR_ILLEGAL_BLOCK_ID: SceKernelErrorCode = 2147632897;
pub const SCE_KERNEL_ERROR_ILLEGAL_BLOCK_TYPE: SceKernelErrorCode = 2147632898;
pub const SCE_KERNEL_ERROR_ILLEGAL_CONTEXT: SceKernelErrorCode = 2147643649;
pub const SCE_KERNEL_ERROR_ILLEGAL_COUNT: SceKernelErrorCode = 2147614735;
pub const SCE_KERNEL_ERROR_ILLEGAL_CPU_AFFINITY_MASK: SceKernelErrorCode = 2147647525;
pub const SCE_KERNEL_ERROR_ILLEGAL_DIPSW_NUMBER: SceKernelErrorCode = 2147618817;
pub const SCE_KERNEL_ERROR_ILLEGAL_ELF_HEADER: SceKernelErrorCode = 2147635201;
pub const SCE_KERNEL_ERROR_ILLEGAL_EXCPCODE: SceKernelErrorCode = 2147643393;
pub const SCE_KERNEL_ERROR_ILLEGAL_EXCPHANDLER: SceKernelErrorCode = 2147643394;
pub const SCE_KERNEL_ERROR_ILLEGAL_HANDLER: SceKernelErrorCode = 2147643656;
pub const SCE_KERNEL_ERROR_ILLEGAL_HEAP_ID: SceKernelErrorCode = 2147633409;
pub const SCE_KERNEL_ERROR_ILLEGAL_INTRCODE: SceKernelErrorCode = 2147643650;
pub const SCE_KERNEL_ERROR_ILLEGAL_INTRFILTER: SceKernelErrorCode = 2147643654;
pub const SCE_KERNEL_ERROR_ILLEGAL_INTRPARAM: SceKernelErrorCode = 2147643651;
pub const SCE_KERNEL_ERROR_ILLEGAL_INTRPRIORITY: SceKernelErrorCode = 2147643652;
pub const SCE_KERNEL_ERROR_ILLEGAL_INTRTYPE: SceKernelErrorCode = 2147643655;
pub const SCE_KERNEL_ERROR_ILLEGAL_KERNEL_TLS_INDEX: SceKernelErrorCode = 2147647618;
pub const SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_CODE: SceKernelErrorCode = 2147633924;
pub const SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_REMAP_TYPE: SceKernelErrorCode = 2147633922;
pub const SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_SIZE: SceKernelErrorCode = 2147633925;
pub const SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_TYPE: SceKernelErrorCode = 2147633921;
pub const SCE_KERNEL_ERROR_ILLEGAL_MODE: SceKernelErrorCode = 2147614736;
pub const SCE_KERNEL_ERROR_ILLEGAL_OPEN_LIMIT: SceKernelErrorCode = 2147614737;
pub const SCE_KERNEL_ERROR_ILLEGAL_PARTITION_ID: SceKernelErrorCode = 2147633153;
pub const SCE_KERNEL_ERROR_ILLEGAL_PARTITION_INDEX: SceKernelErrorCode = 2147633154;
pub const SCE_KERNEL_ERROR_ILLEGAL_PATTERN: SceKernelErrorCode = 2147614733;
pub const SCE_KERNEL_ERROR_ILLEGAL_PERMISSION: SceKernelErrorCode = 2147614728;
pub const SCE_KERNEL_ERROR_ILLEGAL_PHYPAGE_STATUS: SceKernelErrorCode = 2147631873;
pub const SCE_KERNEL_ERROR_ILLEGAL_PRIORITY: SceKernelErrorCode = 2147647523;
pub const SCE_KERNEL_ERROR_ILLEGAL_SELF_HEADER: SceKernelErrorCode = 2147635202;
pub const SCE_KERNEL_ERROR_ILLEGAL_SIZE: SceKernelErrorCode = 2147614731;
pub const SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE: SceKernelErrorCode = 2147647524;
pub const SCE_KERNEL_ERROR_ILLEGAL_TARGET_CPU: SceKernelErrorCode = 2147643653;
pub const SCE_KERNEL_ERROR_ILLEGAL_THREAD_ID: SceKernelErrorCode = 2147647522;
pub const SCE_KERNEL_ERROR_ILLEGAL_THREAD_PARAM_COMBINATION: SceKernelErrorCode = 2147647526;
pub const SCE_KERNEL_ERROR_ILLEGAL_TYPE: SceKernelErrorCode = 2147614732;
pub const SCE_KERNEL_ERROR_ILLEGAL_USERMAP_SIZE: SceKernelErrorCode = 2147633926;
pub const SCE_KERNEL_ERROR_ILLEGAL_VIRPAGE_TYPE: SceKernelErrorCode = 2147632641;
pub const SCE_KERNEL_ERROR_INTRMGR_ERROR: SceKernelErrorCode = 2147643648;
pub const SCE_KERNEL_ERROR_INVALID_ADDRESS_SPACE_ID: SceKernelErrorCode = 2147633665;
pub const SCE_KERNEL_ERROR_INVALID_ARGUMENT: SceKernelErrorCode = 2147614725;
pub const SCE_KERNEL_ERROR_INVALID_ARGUMENT_SIZE: SceKernelErrorCode = 2147614729;
pub const SCE_KERNEL_ERROR_INVALID_BUDGET_ID: SceKernelErrorCode = 2147651590;
pub const SCE_KERNEL_ERROR_INVALID_BUDGET_SIZE: SceKernelErrorCode = 2147651591;
pub const SCE_KERNEL_ERROR_INVALID_CPU_AFFINITY: SceKernelErrorCode = 2147622916;
pub const SCE_KERNEL_ERROR_INVALID_FLAGS: SceKernelErrorCode = 2147614730;
pub const SCE_KERNEL_ERROR_INVALID_MEMORY_ACCESS: SceKernelErrorCode = 2147622917;
pub const SCE_KERNEL_ERROR_INVALID_MEMORY_ACCESS_PERMISSION: SceKernelErrorCode = 2147622918;
pub const SCE_KERNEL_ERROR_INVALID_PARTITION_INDEX: SceKernelErrorCode = 2147633666;
pub const SCE_KERNEL_ERROR_INVALID_PID: SceKernelErrorCode = 2147651585;
pub const SCE_KERNEL_ERROR_INVALID_PROCESS_CONTEXT: SceKernelErrorCode = 2147631105;
pub const SCE_KERNEL_ERROR_INVALID_PROCESS_STATUS: SceKernelErrorCode = 2147651588;
pub const SCE_KERNEL_ERROR_INVALID_PROCESS_TYPE: SceKernelErrorCode = 2147651586;
pub const SCE_KERNEL_ERROR_INVALID_SUBBUDGET_ID: SceKernelErrorCode = 2147631882;
pub const SCE_KERNEL_ERROR_INVALID_UID: SceKernelErrorCode = 2147632385;
pub const SCE_KERNEL_ERROR_INVALID_UID_CLASS: SceKernelErrorCode = 2147632392;
pub const SCE_KERNEL_ERROR_INVALID_UID_SUBCLASS: SceKernelErrorCode = 2147632393;
pub const SCE_KERNEL_ERROR_IO_ALIAS_USED: SceKernelErrorCode = 2147655683;
pub const SCE_KERNEL_ERROR_IO_DEL_DEV: SceKernelErrorCode = 2147655684;
pub const SCE_KERNEL_ERROR_IOFILEMGR_ERROR: SceKernelErrorCode = 2147655680;
pub const SCE_KERNEL_ERROR_IO_NAME_TOO_LONG: SceKernelErrorCode = 2147655681;
pub const SCE_KERNEL_ERROR_IO_REG_DEV: SceKernelErrorCode = 2147655682;
pub const SCE_KERNEL_ERROR_IO_WOULD_BLOCK: SceKernelErrorCode = 2147655685;
pub const SCE_KERNEL_ERROR_KERNEL_TLS_BUSY: SceKernelErrorCode = 2147647619;
pub const SCE_KERNEL_ERROR_KERNEL_TLS_ERROR: SceKernelErrorCode = 2147647616;
pub const SCE_KERNEL_ERROR_KERNEL_TLS_FULL: SceKernelErrorCode = 2147647617;
pub const SCE_KERNEL_ERROR_LIBRARYDB_NOENT: SceKernelErrorCode = 2147668096;
pub const SCE_KERNEL_ERROR_LIBRARYDB_NO_LIB: SceKernelErrorCode = 2147668097;
pub const SCE_KERNEL_ERROR_LIBRARYDB_NO_MOD: SceKernelErrorCode = 2147668098;
pub const SCE_KERNEL_ERROR_LOADCORE_ERROR: SceKernelErrorCode = 2147635200;
pub const SCE_KERNEL_ERROR_LW_COND_ERROR: SceKernelErrorCode = 2147647936;
pub const SCE_KERNEL_ERROR_LW_MUTEX_ERROR: SceKernelErrorCode = 2147647872;
pub const SCE_KERNEL_ERROR_LW_MUTEX_FAILED_TO_OWN: SceKernelErrorCode = 2147647877;
pub const SCE_KERNEL_ERROR_LW_MUTEX_LOCK_OVF: SceKernelErrorCode = 2147647875;
pub const SCE_KERNEL_ERROR_LW_MUTEX_NOT_OWNED: SceKernelErrorCode = 2147647878;
pub const SCE_KERNEL_ERROR_LW_MUTEX_RECURSIVE: SceKernelErrorCode = 2147647874;
pub const SCE_KERNEL_ERROR_LW_MUTEX_UNLOCK_UDF: SceKernelErrorCode = 2147647876;
pub const SCE_KERNEL_ERROR_MEMBLOCK_OVERFLOW: SceKernelErrorCode = 2147633931;
pub const SCE_KERNEL_ERROR_MEMBLOCK_RANGE_ERROR: SceKernelErrorCode = 2147633929;
pub const SCE_KERNEL_ERROR_MEMBLOCK_TYPE_FOR_KERNEL_PROCESS: SceKernelErrorCode = 2147633927;
pub const SCE_KERNEL_ERROR_MEMBLOCK_TYPE_FOR_UPDATER_OR_SAFEMODE: SceKernelErrorCode = 2147633930;
pub const SCE_KERNEL_ERROR_MMU_ILLEGAL_L1_TYPE: SceKernelErrorCode = 2147622913;
pub const SCE_KERNEL_ERROR_MMU_L2_INDEX_OVERFLOW: SceKernelErrorCode = 2147622914;
pub const SCE_KERNEL_ERROR_MMU_L2_SIZE_OVERFLOW: SceKernelErrorCode = 2147622915;
pub const SCE_KERNEL_ERROR_MODULEMGR_BUSY: SceKernelErrorCode = 2147667997;
pub const SCE_KERNEL_ERROR_MODULEMGR_CANNOT_EXPORT_LIB_TO_SHARED: SceKernelErrorCode = 2147667992;
pub const SCE_KERNEL_ERROR_MODULEMGR_ELINK: SceKernelErrorCode = 2147667995;
pub const SCE_KERNEL_ERROR_MODULEMGR_IN_USE: SceKernelErrorCode = 2147667970;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_LIB: SceKernelErrorCode = 2147667977;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_PROCESS_UID: SceKernelErrorCode = 2147667991;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_PROC_PARAM: SceKernelErrorCode = 2147667983;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_REF_INFO: SceKernelErrorCode = 2147667994;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_REL_INFO: SceKernelErrorCode = 2147667993;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_STUB: SceKernelErrorCode = 2147667978;
pub const SCE_KERNEL_ERROR_MODULEMGR_INVALID_TYPE: SceKernelErrorCode = 2147667981;
pub const SCE_KERNEL_ERROR_MODULEMGR_NAMETOOLONG: SceKernelErrorCode = 2147667999;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOENT: SceKernelErrorCode = 2147667996;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOEXEC: SceKernelErrorCode = 2147667998;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_FUNC_NID: SceKernelErrorCode = 2147667979;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_LIB: SceKernelErrorCode = 2147667971;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOMEM: SceKernelErrorCode = 2147667976;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOMEM_LIB: SceKernelErrorCode = 2147667973;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOMEM_SELF: SceKernelErrorCode = 2147667975;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOMEM_STUB: SceKernelErrorCode = 2147667974;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_MOD: SceKernelErrorCode = 2147667985;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_MOD_ENTRY: SceKernelErrorCode = 2147667982;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_MODOBJ: SceKernelErrorCode = 2147667984;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_PROCESS: SceKernelErrorCode = 2147667986;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOT_STARTED: SceKernelErrorCode = 2147667989;
pub const SCE_KERNEL_ERROR_MODULEMGR_NOT_STOPPED: SceKernelErrorCode = 2147667990;
pub const SCE_KERNEL_ERROR_MODULEMGR_NO_VAR_NID: SceKernelErrorCode = 2147667980;
pub const SCE_KERNEL_ERROR_MODULEMGR_OLD_LIB: SceKernelErrorCode = 2147667987;
pub const SCE_KERNEL_ERROR_MODULEMGR_STARTED: SceKernelErrorCode = 2147667988;
pub const SCE_KERNEL_ERROR_MODULEMGR_START_FAILED: SceKernelErrorCode = 2147667968;
pub const SCE_KERNEL_ERROR_MODULEMGR_STOP_FAIL: SceKernelErrorCode = 2147667969;
pub const SCE_KERNEL_ERROR_MODULEMGR_SYSCALL_REG: SceKernelErrorCode = 2147667972;
pub const SCE_KERNEL_ERROR_MSG_PIPE_DELETED: SceKernelErrorCode = 2147648036;
pub const SCE_KERNEL_ERROR_MSG_PIPE_EMPTY: SceKernelErrorCode = 2147648035;
pub const SCE_KERNEL_ERROR_MSG_PIPE_ERROR: SceKernelErrorCode = 2147648032;
pub const SCE_KERNEL_ERROR_MSG_PIPE_FULL: SceKernelErrorCode = 2147648034;
pub const SCE_KERNEL_ERROR_MUTEX_ERROR: SceKernelErrorCode = 2147647808;
pub const SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN: SceKernelErrorCode = 2147647813;
pub const SCE_KERNEL_ERROR_MUTEX_LOCK_OVF: SceKernelErrorCode = 2147647811;
pub const SCE_KERNEL_ERROR_MUTEX_NOT_OWNED: SceKernelErrorCode = 2147647814;
pub const SCE_KERNEL_ERROR_MUTEX_RECURSIVE: SceKernelErrorCode = 2147647810;
pub const SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF: SceKernelErrorCode = 2147647812;
pub const SCE_KERNEL_ERROR_NO_AUTH: SceKernelErrorCode = 2147676161;
pub const SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE: SceKernelErrorCode = 2147631874;
pub const SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE_CDRAM: SceKernelErrorCode = 2147631881;
pub const SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE_UNIT: SceKernelErrorCode = 2147631875;
pub const SCE_KERNEL_ERROR_NO_FREE_TIMER: SceKernelErrorCode = 2147644161;
pub const SCE_KERNEL_ERROR_NO_IOADDR: SceKernelErrorCode = 2147631364;
pub const SCE_KERNEL_ERROR_NO_L2PAGETABLE: SceKernelErrorCode = 2147633155;
pub const SCE_KERNEL_ERROR_NO_MEMORY: SceKernelErrorCode = 2147643659;
pub const SCE_KERNEL_ERROR_NO_PHYADDR: SceKernelErrorCode = 2147631361;
pub const SCE_KERNEL_ERROR_NO_PHYMEMPART_CDRAM: SceKernelErrorCode = 2147631878;
pub const SCE_KERNEL_ERROR_NO_PHYMEMPART_LPDDR2: SceKernelErrorCode = 2147631877;
pub const SCE_KERNEL_ERROR_NO_PROCESS_DATA: SceKernelErrorCode = 2147651595;
pub const SCE_KERNEL_ERROR_NO_SUCH_NAME: SceKernelErrorCode = 2147634689;
pub const SCE_KERNEL_ERROR_NOSYS: SceKernelErrorCode = 2147614723;
pub const SCE_KERNEL_ERROR_NOT_DEBUG_SUSPENDED: SceKernelErrorCode = 2147647536;
pub const SCE_KERNEL_ERROR_NOT_DORMANT: SceKernelErrorCode = 2147647528;
pub const SCE_KERNEL_ERROR_NOTFOUND_EXCPHANDLER: SceKernelErrorCode = 2147643395;
pub const SCE_KERNEL_ERROR_NOTFOUND_HANDLER: SceKernelErrorCode = 2147643658;
pub const SCE_KERNEL_ERROR_NOTIFY_CALLBACK: SceKernelErrorCode = 2147647650;
pub const SCE_KERNEL_ERROR_NOT_IMPLEMENTED: SceKernelErrorCode = 2147614722;
pub const SCE_KERNEL_ERROR_NOT_INITIALIZED: SceKernelErrorCode = 2147643909;
pub const SCE_KERNEL_ERROR_NOT_KERNEL_UID: SceKernelErrorCode = 2147632391;
pub const SCE_KERNEL_ERROR_NOT_PHY_CONT_MEMBLOCK: SceKernelErrorCode = 2147633923;
pub const SCE_KERNEL_ERROR_NOT_PROCESS_UID: SceKernelErrorCode = 2147632390;
pub const SCE_KERNEL_ERROR_NOT_QUEUED: SceKernelErrorCode = 2147643906;
pub const SCE_KERNEL_ERROR_NOT_SETUP: SceKernelErrorCode = 2147643907;
pub const SCE_KERNEL_ERROR_NOT_SUSPENDED: SceKernelErrorCode = 2147647534;
pub const SCE_KERNEL_ERROR_NOT_UNDER_CONTROL: SceKernelErrorCode = 2147643911;
pub const SCE_KERNEL_ERROR_ONLY_DEVELOPMENT_MODE: SceKernelErrorCode = 2147614738;
pub const SCE_KERNEL_ERROR_ON_TRANSFERRING: SceKernelErrorCode = 2147643908;
pub const SCE_KERNEL_ERROR_OUT_OF_RANG: SceKernelErrorCode = 2147633410;
pub const SCE_KERNEL_ERROR_PA_ERROR: SceKernelErrorCode = 2147619072;
pub const SCE_KERNEL_ERROR_PA_INVALID_KEY: SceKernelErrorCode = 2147619074;
pub const SCE_KERNEL_ERROR_PA_INVALID_SIGNATURE: SceKernelErrorCode = 2147619076;
pub const SCE_KERNEL_ERROR_PA_KEY_IS_NOT_SHARED: SceKernelErrorCode = 2147619075;
pub const SCE_KERNEL_ERROR_PA_NOT_AVAILABLE: SceKernelErrorCode = 2147619073;
pub const SCE_KERNEL_ERROR_PARTITION_ERROR: SceKernelErrorCode = 2147633152;
pub const SCE_KERNEL_ERROR_PHYADDR_ERROR: SceKernelErrorCode = 2147631360;
pub const SCE_KERNEL_ERROR_PHYADDR_NOT_USED: SceKernelErrorCode = 2147631363;
pub const SCE_KERNEL_ERROR_PHYADDR_USED: SceKernelErrorCode = 2147631362;
pub const SCE_KERNEL_ERROR_PHYMEM_ERROR: SceKernelErrorCode = 2147631872;
pub const SCE_KERNEL_ERROR_PHYMEMPART_NOT_EMPTY: SceKernelErrorCode = 2147631876;
pub const SCE_KERNEL_ERROR_PHYMEMPART_OUT_OF_INDEX: SceKernelErrorCode = 2147631879;
pub const SCE_KERNEL_ERROR_PLS_FULL: SceKernelErrorCode = 2147651587;
pub const SCE_KERNEL_ERROR_PMON_ERROR: SceKernelErrorCode = 2147648128;
pub const SCE_KERNEL_ERROR_PMON_NOT_CPU_MODE: SceKernelErrorCode = 2147648130;
pub const SCE_KERNEL_ERROR_PMON_NOT_THREAD_MODE: SceKernelErrorCode = 2147648129;
pub const SCE_KERNEL_ERROR_PRELOAD_FAILED: SceKernelErrorCode = 2147668208;
pub const SCE_KERNEL_ERROR_PRELOAD_FIOS2_FAILED: SceKernelErrorCode = 2147668210;
pub const SCE_KERNEL_ERROR_PRELOAD_LIBC_FAILED: SceKernelErrorCode = 2147668209;
pub const SCE_KERNEL_ERROR_PROCESS_CALLBACK_NOTFOUND: SceKernelErrorCode = 2147651589;
pub const SCE_KERNEL_ERROR_PROCESS_CANNOT_REMAP_MEMBLOCK: SceKernelErrorCode = 2147633928;
pub const SCE_KERNEL_ERROR_PROCESS_EVENT_INHIBITED: SceKernelErrorCode = 2147651596;
pub const SCE_KERNEL_ERROR_PROCESSMGR_ERROR: SceKernelErrorCode = 2147651584;
pub const SCE_KERNEL_ERROR_PROCESS_REMAINING: SceKernelErrorCode = 2147651594;
pub const SCE_KERNEL_ERROR_RUNNING: SceKernelErrorCode = 2147647529;
pub const SCE_KERNEL_ERROR_RW_LOCK_ERROR: SceKernelErrorCode = 2147647968;
pub const SCE_KERNEL_ERROR_RW_LOCK_FAILED_TO_LOCK: SceKernelErrorCode = 2147647974;
pub const SCE_KERNEL_ERROR_RW_LOCK_FAILED_TO_UNLOCK: SceKernelErrorCode = 2147647975;
pub const SCE_KERNEL_ERROR_RW_LOCK_LOCK_OVF: SceKernelErrorCode = 2147647971;
pub const SCE_KERNEL_ERROR_RW_LOCK_NOT_OWNED: SceKernelErrorCode = 2147647972;
pub const SCE_KERNEL_ERROR_RW_LOCK_RECURSIVE: SceKernelErrorCode = 2147647970;
pub const SCE_KERNEL_ERROR_RW_LOCK_UNLOCK_UDF: SceKernelErrorCode = 2147647973;
pub const SCE_KERNEL_ERROR_SEMA_ERROR: SceKernelErrorCode = 2147647744;
pub const SCE_KERNEL_ERROR_SEMA_OVF: SceKernelErrorCode = 2147647747;
pub const SCE_KERNEL_ERROR_SEMA_ZERO: SceKernelErrorCode = 2147647746;
pub const SCE_KERNEL_ERROR_SIGNAL_ERROR: SceKernelErrorCode = 2147647776;
pub const SCE_KERNEL_ERROR_SIMPLE_EVENT_ERROR: SceKernelErrorCode = 2147648096;
pub const SCE_KERNEL_ERROR_SYSMEM_ADDRESS_SPACE_ERROR: SceKernelErrorCode = 2147633664;
pub const SCE_KERNEL_ERROR_SYSMEM_BITHEAP_ERROR: SceKernelErrorCode = 2147634432;
pub const SCE_KERNEL_ERROR_SYSMEM_CANNOT_ALLOCATE_UIDENTRY: SceKernelErrorCode = 2147632389;
pub const SCE_KERNEL_ERROR_SYSMEM_ERROR: SceKernelErrorCode = 2147631104;
pub const SCE_KERNEL_ERROR_SYSMEM_INVALID_UID_RANGE: SceKernelErrorCode = 2147632387;
pub const SCE_KERNEL_ERROR_SYSMEM_MEMBLOCK_ERROR: SceKernelErrorCode = 2147633920;
pub const SCE_KERNEL_ERROR_SYSMEM_NAMEHEAP_ERROR: SceKernelErrorCode = 2147634688;
pub const SCE_KERNEL_ERROR_SYSMEM_NO_VALID_UID: SceKernelErrorCode = 2147632388;
pub const SCE_KERNEL_ERROR_SYSMEM_PHYMEMLOW_ERROR: SceKernelErrorCode = 2147634176;
pub const SCE_KERNEL_ERROR_SYSMEM_UID_INVALID_ARGUMENT: SceKernelErrorCode = 2147632386;
pub const SCE_KERNEL_ERROR_SYSTIMER_ERROR: SceKernelErrorCode = 2147644160;
pub const SCE_KERNEL_ERROR_THREAD_ERROR: SceKernelErrorCode = 2147647520;
pub const SCE_KERNEL_ERROR_THREAD_EVENT_ERROR: SceKernelErrorCode = 2147647584;
pub const SCE_KERNEL_ERROR_THREADMGR_ERROR: SceKernelErrorCode = 2147647488;
pub const SCE_KERNEL_ERROR_THREAD_STOPPED: SceKernelErrorCode = 2147647532;
pub const SCE_KERNEL_ERROR_THREAD_SUSPENDED: SceKernelErrorCode = 2147647533;
pub const SCE_KERNEL_ERROR_TIMER_COUNTING: SceKernelErrorCode = 2147644163;
pub const SCE_KERNEL_ERROR_TIMER_ERROR: SceKernelErrorCode = 2147648064;
pub const SCE_KERNEL_ERROR_TIMER_NOT_ALLOCATED: SceKernelErrorCode = 2147644162;
pub const SCE_KERNEL_ERROR_TIMER_STOPPED: SceKernelErrorCode = 2147644164;
pub const SCE_KERNEL_ERROR_TRANSFERRED: SceKernelErrorCode = 2147643910;
pub const SCE_KERNEL_ERROR_UID_CANNOT_FIND_BY_NAME: SceKernelErrorCode = 2147632394;
pub const SCE_KERNEL_ERROR_UID_ERROR: SceKernelErrorCode = 2147632384;
pub const SCE_KERNEL_ERROR_UID_MAX_OPEN: SceKernelErrorCode = 2147632396;
pub const SCE_KERNEL_ERROR_UID_NAME_TOO_LONG: SceKernelErrorCode = 2147631106;
pub const SCE_KERNEL_ERROR_UID_NOT_VISIBLE: SceKernelErrorCode = 2147632395;
pub const SCE_KERNEL_ERROR_UID_RL_OVERFLOW: SceKernelErrorCode = 2147632397;
pub const SCE_KERNEL_ERROR_UNKNOWN_ALARM_ID: SceKernelErrorCode = 2147647681;
pub const SCE_KERNEL_ERROR_UNKNOWN_CALLBACK_ID: SceKernelErrorCode = 2147647649;
pub const SCE_KERNEL_ERROR_UNKNOWN_COND_ID: SceKernelErrorCode = 2147647905;
pub const SCE_KERNEL_ERROR_UNKNOWN_EVENT_ID: SceKernelErrorCode = 2147648001;
pub const SCE_KERNEL_ERROR_UNKNOWN_EVF_ID: SceKernelErrorCode = 2147647713;
pub const SCE_KERNEL_ERROR_UNKNOWN_FAST_MUTEX_ID: SceKernelErrorCode = 2147647841;
pub const SCE_KERNEL_ERROR_UNKNOWN_LW_COND_ID: SceKernelErrorCode = 2147647937;
pub const SCE_KERNEL_ERROR_UNKNOWN_LW_MUTEX_ID: SceKernelErrorCode = 2147647873;
pub const SCE_KERNEL_ERROR_UNKNOWN_MSG_PIPE_ID: SceKernelErrorCode = 2147648033;
pub const SCE_KERNEL_ERROR_UNKNOWN_MUTEX_ID: SceKernelErrorCode = 2147647809;
pub const SCE_KERNEL_ERROR_UNKNOWN_PHYMEMLOW_TYPE: SceKernelErrorCode = 2147634178;
pub const SCE_KERNEL_ERROR_UNKNOWN_RW_LOCK_ID: SceKernelErrorCode = 2147647969;
pub const SCE_KERNEL_ERROR_UNKNOWN_SEMA_ID: SceKernelErrorCode = 2147647745;
pub const SCE_KERNEL_ERROR_UNKNOWN_SIMPLE_EVENT_ID: SceKernelErrorCode = 2147648097;
pub const SCE_KERNEL_ERROR_UNKNOWN_THREAD_EVENT_ID: SceKernelErrorCode = 2147647585;
pub const SCE_KERNEL_ERROR_UNKNOWN_THREAD_ID: SceKernelErrorCode = 2147647521;
pub const SCE_KERNEL_ERROR_UNKNOWN_TIMER_ID: SceKernelErrorCode = 2147648065;
pub const SCE_KERNEL_ERROR_UNKNOWN_UID: SceKernelErrorCode = 2147647489;
pub const SCE_KERNEL_ERROR_UNKNOWN_WORK_QUEUE_ID: SceKernelErrorCode = 2147648257;
pub const SCE_KERNEL_ERROR_UNKNOWN_WORK_TASK_ID: SceKernelErrorCode = 2147648258;
pub const SCE_KERNEL_ERROR_UNSUP: SceKernelErrorCode = 2147614724;
pub const SCE_KERNEL_ERROR_VA2PA_FAULT: SceKernelErrorCode = 2147622919;
pub const SCE_KERNEL_ERROR_VA2PA_MAPPED: SceKernelErrorCode = 2147622920;
pub const SCE_KERNEL_ERROR_VALIDATION_CHECK_FAILED: SceKernelErrorCode = 2147622921;
pub const SCE_KERNEL_ERROR_VARANGE_IS_NOT_PHYSICAL_CONTINUOUS: SceKernelErrorCode = 2147631107;
pub const SCE_KERNEL_ERROR_VIRPAGE_ERROR: SceKernelErrorCode = 2147632640;
pub const SCE_KERNEL_ERROR_WAIT_CANCEL: SceKernelErrorCode = 2147647495;
pub const SCE_KERNEL_ERROR_WAIT_CANCEL_COND: SceKernelErrorCode = 2147647909;
pub const SCE_KERNEL_ERROR_WAIT_CANCEL_MUTEX: SceKernelErrorCode = 2147647907;
pub const SCE_KERNEL_ERROR_WAIT_DELETE: SceKernelErrorCode = 2147647494;
pub const SCE_KERNEL_ERROR_WAIT_DELETE_COND: SceKernelErrorCode = 2147647908;
pub const SCE_KERNEL_ERROR_WAIT_DELETE_LW_COND: SceKernelErrorCode = 2147647939;
pub const SCE_KERNEL_ERROR_WAIT_DELETE_LW_MUTEX: SceKernelErrorCode = 2147647938;
pub const SCE_KERNEL_ERROR_WAIT_DELETE_MUTEX: SceKernelErrorCode = 2147647906;
pub const SCE_KERNEL_ERROR_WAIT_TIMEOUT: SceKernelErrorCode = 2147647493;
pub const SCE_KERNEL_ERROR_WORK_QUEUE: SceKernelErrorCode = 2147648256;
pub const SCE_KERNEL_HEAP_ATTR_HAS_AUTO_EXTEND: SceKernelHeapAttr = 1;
pub const SCE_KERNEL_HEAP_ATTR_HAS_MEMORY_TYPE: SceKernelHeapAttr = 1024;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_CDRAM_L1WBWA_RW: u32 = 1077952518;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_CDRAM_RW: u32 = 1077968902;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_IO_NC_R: u32 = 537952260;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_IO_NC_RW: u32 = 537952262;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_IO_R: u32 = 537921540;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_IO_RW: u32 = 537921542;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_IO_SO_R: u32 = 537920004;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_IO_SO_RW: u32 = 537920006;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_KMP_GAME_RW: u32 = 3226521606;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_KMP_TOOL_RW: u32 = 3237007366;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_CDIALOG_R: u32 = 278974468;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_CDIALOG_RW: u32 = 278974470;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_DEVICE_RW: u32 = 270534662;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_GAME_RW: u32 = 273731590;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_L1WBWA_RW: u32 = 270548998;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_NC_R: u32 = 270565380;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_NC_RW: u32 = 270565382;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_PHYCONT_NC_R: u32 = 813727748;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_PHYCONT_NC_RW: u32 = 813727750;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_PHYCONT_R: u32 = 276877316;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_PHYCONT_RW: u32 = 276877318;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_R: u32 = 270585860;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_RW: u32 = 270585862;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_RX: u32 = 270585861;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_SO_RW: u32 = 270533126;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_UMAIN_NC_RW: u32 = 281051142;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_ROOT_UMAIN_RW: u32 = 281071622;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_RW: u32 = 270585862;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_RX: u32 = 270585861;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_FS_GAME_NC_R: u32 = 320897028;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_FS_GAME_NC_RW: u32 = 320897030;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_FS_GAME_R: u32 = 304140292;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_FS_GAME_RW: u32 = 304140294;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_GAME_RW: u32 = 1615908870;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_NC_R: u32 = 1612742660;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_NC_RW: u32 = 1612742662;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_R: u32 = 1612763140;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TMP_RW: u32 = 1612763142;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TOOL_NC_R: u32 = 284196868;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TOOL_NC_RW: u32 = 284196870;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TOOL_R: u32 = 284217348;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TOOL_RW: u32 = 284217350;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_TOOL_RX: u32 = 284217349;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_UNK_11208006_NC_RW: u32 = 287342598;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_UNK_60208014_NC_R: u32 = 1612742676;
pub const SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_UNK_60208016_NC_RW: u32 = 1612742678;
pub const SCE_KERNEL_MEMBLOCK_TYPE_RW_UNK0: u32 = 1612763142;
pub const SCE_KERNEL_MEMBLOCK_TYPE_SHARED_RX: u32 = 59822160;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDIALOG_NC_R: u32 = 237011008;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDIALOG_NC_RW: u32 = 237011040;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDIALOG_R: u32 = 237031488;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDIALOG_RW: u32 = 237031520;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDIALOG_RX: u32 = 237031504;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_L1WBWA_RW: u32 = 155205728;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_R: u32 = 155222080;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW: u32 = 155222112;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_IO_DEVICE_R: u32 = 185600064;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_IO_DEVICE_RW: u32 = 185600096;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_IO_SO_R: u32 = 185598528;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_IO_SO_RW: u32 = 185598560;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_CDIALOG_NC_RW: u32 = 211845216;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_CDIALOG_RW: u32 = 211865696;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_DEVICE_RW: u32 = 203425888;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_GAME_RW: u32 = 206622816;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_NC_RW: u32 = 203456608;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_PHYCONT_NC_R: u32 = 226525248;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_PHYCONT_NC_RW: u32 = 226525280;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_PHYCONT_R: u32 = 209768512;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_PHYCONT_RW: u32 = 209768544;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_R: u32 = 203477056;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_RW: u32 = 203477088;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_RX: u32 = 203477072;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_TOOL_NC_RW: u32 = 217088096;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_TOOL_RW: u32 = 217108576;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_TOOL_RX: u32 = 217108560;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_RW: u32 = 203477088;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE: u32 = 203456608;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_RX: u32 = 203477072;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_CDIALOG_R: u32 = 60870720;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_CDIALOG_RW: u32 = 60870752;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_CDIALOG_RX: u32 = 60870736;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_MAIN_R: u32 = 52482112;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_MAIN_RW: u32 = 52482144;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_MAIN_RX: u32 = 52482128;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_SHARED_R: u32 = 59822144;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_SHARED_RW: u32 = 59822176;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_SHARED_RX: u32 = 59822160;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_TOOL_R: u32 = 66113600;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_TOOL_RW: u32 = 66113632;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_SHARED_TOOL_RX: u32 = 66113616;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_TOOL_NC_RW: u32 = 217088096;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_TOOL_R: u32 = 149999680;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_TOOL_RW: u32 = 149999712;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_TOOL_RX: u32 = 149999696;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_TOOL_UNK_RW: u32 = 149999622;
pub const SCE_KERNEL_MEMBLOCK_TYPE_USER_UNK_0720D006_RW: u32 = 119590918;
pub const SCE_KERNEL_MEMORY_ACCESS_R: SceKernelMemoryAccessType = 4;
pub const SCE_KERNEL_MEMORY_ACCESS_W: SceKernelMemoryAccessType = 2;
pub const SCE_KERNEL_MEMORY_ACCESS_X: SceKernelMemoryAccessType = 1;
pub const SCE_KERNEL_MEMORY_REF_PERM_ANY: SceKernelMemoryRefPerm = 0;
pub const SCE_KERNEL_MEMORY_REF_PERM_KERN_R: SceKernelMemoryRefPerm = 16;
pub const SCE_KERNEL_MEMORY_REF_PERM_KERN_W: SceKernelMemoryRefPerm = 32;
pub const SCE_KERNEL_MEMORY_REF_PERM_KERN_X: SceKernelMemoryRefPerm = 64;
pub const SCE_KERNEL_MEMORY_REF_PERM_USER_R: SceKernelMemoryRefPerm = 1;
pub const SCE_KERNEL_MEMORY_REF_PERM_USER_W: SceKernelMemoryRefPerm = 2;
pub const SCE_KERNEL_MEMORY_REF_PERM_USER_X: SceKernelMemoryRefPerm = 4;
pub const SCE_KERNEL_MEMORY_TYPE_NORMAL: SceKernelMemoryType = 208;
pub const SCE_KERNEL_MEMORY_TYPE_NORMAL_NC: SceKernelMemoryType = 128;
pub const SCE_KERNEL_MODEL_VITA: SceKernelModel = 65536;
pub const SCE_KERNEL_MODEL_VITATV: SceKernelModel = 131072;
pub const SCE_KERNEL_MODULE_STATE_ENDED: SceKernelModuleState = 9;
pub const SCE_KERNEL_MODULE_STATE_READY: SceKernelModuleState = 2;
pub const SCE_KERNEL_MODULE_STATE_STARTED: SceKernelModuleState = 6;
pub const SCE_KERNEL_MUTEX_ATTR_CEILING: SceKernelMutexAttribute = 4;
pub const SCE_KERNEL_MUTEX_ATTR_RECURSIVE: SceKernelMutexAttribute = 2;
pub const SCE_KERNEL_OK: SceKernelErrorCode = 0;
#[doc = "Cancel all timers"]
pub const SCE_KERNEL_POWER_TICK_DEFAULT: SceKernelPowerTickType = 0;
#[doc = "Cancel OLED dimming timer"]
pub const __SCE_KERNEL_POWER_TICK_DISABLE: SceKernelPowerTickType = 4294967295;
#[doc = "Cancel automatic suspension timer"]
pub const SCE_KERNEL_POWER_TICK_DISABLE_AUTO_SUSPEND: SceKernelPowerTickType = 1;
#[doc = "Cancel OLED dimming timer"]
pub const SCE_KERNEL_POWER_TICK_DISABLE_OLED_DIMMING: SceKernelPowerTickType = 6;
#[doc = "Cancel OLED-off timer"]
pub const SCE_KERNEL_POWER_TICK_DISABLE_OLED_OFF: SceKernelPowerTickType = 4;
pub const SCE_KERNEL_PRELOAD_INHIBIT_APPUTIL: SceKernelPreloadInhibit = 4194304;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBC: SceKernelPreloadInhibit = 65536;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBCDLG: SceKernelPreloadInhibit = 1048576;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBDBG: SceKernelPreloadInhibit = 131072;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBFIOS2: SceKernelPreloadInhibit = 2097152;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBPERF: SceKernelPreloadInhibit = 33554432;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBPVF: SceKernelPreloadInhibit = 16777216;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBSCEFT2: SceKernelPreloadInhibit = 8388608;
pub const SCE_KERNEL_PRELOAD_INHIBIT_LIBSHELLSVC: SceKernelPreloadInhibit = 524288;
pub const SCE_KERNEL_PRELOAD_INHIBIT_NONE: SceKernelPreloadInhibit = 0;
pub const SCE_KERNEL_PROCESS_ID_SELF: u32 = 0;
pub const __SCE_KERNEL_PROCESS_PRIORITY_SYSTEM: SceKernelProcessPrioritySystem = 4294967295;
pub const SCE_KERNEL_PROCESS_PRIORITY_SYSTEM_DEFAULT: SceKernelProcessPrioritySystem = 96;
pub const SCE_KERNEL_PROCESS_PRIORITY_SYSTEM_HIGH: SceKernelProcessPrioritySystem = 32;
pub const SCE_KERNEL_PROCESS_PRIORITY_SYSTEM_LOW: SceKernelProcessPrioritySystem = 159;
pub const __SCE_KERNEL_PROCESS_PRIORITY_USER: SceKernelProcessPriorityUser = 4294967295;
pub const SCE_KERNEL_PROCESS_PRIORITY_USER_DEFAULT: SceKernelProcessPriorityUser = 96;
pub const SCE_KERNEL_PROCESS_PRIORITY_USER_HIGH: SceKernelProcessPriorityUser = 64;
pub const SCE_KERNEL_PROCESS_PRIORITY_USER_LOW: SceKernelProcessPriorityUser = 127;
pub const SCE_KERNEL_START_FAILED: u32 = 2;
pub const SCE_KERNEL_START_NO_RESIDENT: u32 = 1;
pub const SCE_KERNEL_START_RESIDENT: u32 = 0;
pub const SCE_KERNEL_START_SUCCESS: u32 = 0;
pub const SCE_KERNEL_STOP_CANCEL: u32 = 1;
pub const SCE_KERNEL_STOP_FAIL: u32 = 1;
pub const SCE_KERNEL_STOP_SUCCESS: u32 = 0;
pub const SCE_KERNEL_SYSROOT_SELF_INDEX_ENCDEC_W_PORTABILITY_SM: SceKernelSysrootSelfIndex = 2;
pub const SCE_KERNEL_SYSROOT_SELF_INDEX_GCAUTHMGR_SM: SceKernelSysrootSelfIndex = 0;
pub const SCE_KERNEL_SYSROOT_SELF_INDEX_RMAUTH_SM: SceKernelSysrootSelfIndex = 1;
pub const SCE_KERNEL_THREAD_CPU_AFFINITY_MASK_DEFAULT: u32 = 0;
pub const SCE_KERNEL_THREAD_ID_SELF: u32 = 0;
pub const SCE_KERNEL_TMID_Alarm: SceKernelIdListType = 10;
pub const SCE_KERNEL_TMID_Callback: SceKernelIdListType = 8;
pub const SCE_KERNEL_TMID_DelayThread: SceKernelIdListType = 65;
pub const SCE_KERNEL_TMID_DormantThread: SceKernelIdListType = 67;
pub const SCE_KERNEL_TMID_EventFlag: SceKernelIdListType = 3;
pub const SCE_KERNEL_TMID_Fpl: SceKernelIdListType = 6;
pub const SCE_KERNEL_TMID_Mbox: SceKernelIdListType = 4;
pub const SCE_KERNEL_TMID_Mpipe: SceKernelIdListType = 7;
pub const SCE_KERNEL_TMID_Semaphore: SceKernelIdListType = 2;
pub const SCE_KERNEL_TMID_SleepThread: SceKernelIdListType = 64;
pub const SCE_KERNEL_TMID_SuspendThread: SceKernelIdListType = 66;
pub const SCE_KERNEL_TMID_Thread: SceKernelIdListType = 1;
pub const SCE_KERNEL_TMID_ThreadEventHandler: SceKernelIdListType = 9;
pub const SCE_KERNEL_TMID_Vpl: SceKernelIdListType = 5;
pub const SCE_KERNEL_TMID_VTimer: SceKernelIdListType = 11;
pub const SCE_LOCATION_DATA_INVALID: f64 = -9999.0;
pub const __SCE_LOCATION_DIALOG_RESULT: SceLocationDialogResult = 4294967295;
#[doc = "Negative result is stored"]
pub const SCE_LOCATION_DIALOG_RESULT_DISABLE: SceLocationDialogResult = 1;
#[doc = "Positive result is stored"]
pub const SCE_LOCATION_DIALOG_RESULT_ENABLE: SceLocationDialogResult = 2;
#[doc = "Result is not stored"]
pub const SCE_LOCATION_DIALOG_RESULT_NONE: SceLocationDialogResult = 0;
pub const __SCE_LOCATION_DIALOG_STATUS: SceLocationDialogStatus = 4294967295;
#[doc = "Dialog operation finished"]
pub const SCE_LOCATION_DIALOG_STATUS_FINISHED: SceLocationDialogStatus = 2;
#[doc = "Dialog initial idle status"]
pub const SCE_LOCATION_DIALOG_STATUS_IDLE: SceLocationDialogStatus = 0;
#[doc = "Dialog running"]
pub const SCE_LOCATION_DIALOG_STATUS_RUNNING: SceLocationDialogStatus = 1;
pub const SCE_LOCATION_ERROR_DIALOG_RESULT_NONE: SceLocationErrorCode = 2148536844;
pub const SCE_LOCATION_ERROR_DISABLE_APPLICATION: SceLocationErrorCode = 2148536845;
pub const SCE_LOCATION_ERROR_FATAL_ERROR: SceLocationErrorCode = 2148537087;
pub const SCE_LOCATION_ERROR_FILE_IO: SceLocationErrorCode = 2148536962;
pub const SCE_LOCATION_ERROR_INVALID_ADDRESS: SceLocationErrorCode = 2148536836;
pub const SCE_LOCATION_ERROR_INVALID_FILE_FORMAT: SceLocationErrorCode = 2148536963;
pub const SCE_LOCATION_ERROR_INVALID_HANDLE: SceLocationErrorCode = 2148536837;
pub const SCE_LOCATION_ERROR_INVALID_HEADING_METHOD: SceLocationErrorCode = 2148536841;
pub const SCE_LOCATION_ERROR_INVALID_LOCATION_METHOD: SceLocationErrorCode = 2148536840;
pub const SCE_LOCATION_ERROR_INVALID_TITLE_ID: SceLocationErrorCode = 2148536966;
pub const SCE_LOCATION_ERROR_MULTIPLE_CALLBACK: SceLocationErrorCode = 2148536842;
pub const SCE_LOCATION_ERROR_MULTIPLE_CONFIRM: SceLocationErrorCode = 2148536846;
pub const SCE_LOCATION_ERROR_NO_MEMORY: SceLocationErrorCode = 2148536838;
pub const SCE_LOCATION_ERROR_NO_SERVER_MEMORY: SceLocationErrorCode = 2148536965;
pub const SCE_LOCATION_ERROR_NOT_RUNNING_CALLBACK: SceLocationErrorCode = 2148536843;
pub const SCE_LOCATION_ERROR_PROVIDER_UNAVAILABLE: SceLocationErrorCode = 2148536961;
pub const SCE_LOCATION_ERROR_TIME_OUT: SceLocationErrorCode = 2148536964;
pub const SCE_LOCATION_ERROR_TOO_MANY_HANDLES: SceLocationErrorCode = 2148536839;
pub const SCE_LOCATION_ERROR_UNAUTHORIZED: SceLocationErrorCode = 2148536960;
pub const __SCE_LOCATION_HMETHOD: SceLocationHeadingMethod = 4294967295;
#[doc = "Automatically determine hold orientation and outputs its value"]
pub const SCE_LOCATION_HMETHOD_AUTO: SceLocationHeadingMethod = 1;
#[doc = "Output value in camera axis reference system"]
pub const SCE_LOCATION_HMETHOD_CAMERA: SceLocationHeadingMethod = 4;
#[doc = "Output value in horizontal hold reference system"]
pub const SCE_LOCATION_HMETHOD_HORIZONTAL: SceLocationHeadingMethod = 3;
#[doc = "Don't perform heading measurement"]
pub const SCE_LOCATION_HMETHOD_NONE: SceLocationHeadingMethod = 0;
#[doc = "Output value in vertical hold reference system"]
pub const SCE_LOCATION_HMETHOD_VERTICAL: SceLocationHeadingMethod = 2;
pub const SCE_LOCATION_INFO_DENIED_BY_USER: SceLocationErrorCode = 2148536835;
pub const SCE_LOCATION_INFO_GET_LOCATION_CANCELED: SceLocationErrorCode = 2148536834;
pub const SCE_LOCATION_INFO_INSUFFICIENT_INFORMATION: SceLocationErrorCode = 2148536833;
pub const SCE_LOCATION_INFO_UNDETERMINED_LOCATION: SceLocationErrorCode = 2148536832;
pub const __SCE_LOCATION_LMETHOD: SceLocationLocationMethod = 4294967295;
#[doc = "Use only 3G"]
pub const SCE_LOCATION_LMETHOD_3G: SceLocationLocationMethod = 4;
#[doc = "Perform measurement by switching between AGPS, Wi-Fi, and 3G"]
pub const SCE_LOCATION_LMETHOD_AGPS_AND_3G_AND_WIFI: SceLocationLocationMethod = 1;
#[doc = "Use only GPS"]
pub const SCE_LOCATION_LMETHOD_GPS: SceLocationLocationMethod = 5;
#[doc = "Perform measurement by switching between GPS and Wi-Fi"]
pub const SCE_LOCATION_LMETHOD_GPS_AND_WIFI: SceLocationLocationMethod = 2;
#[doc = "Do not perform location measurement"]
pub const SCE_LOCATION_LMETHOD_NONE: SceLocationLocationMethod = 0;
#[doc = "Use only Wi-Fi"]
pub const SCE_LOCATION_LMETHOD_WIFI: SceLocationLocationMethod = 3;
pub const __SCE_LOCATION_PERMISSION: SceLocationPermissionStatus = 4294967295;
#[doc = "liblocation access allowed status"]
pub const SCE_LOCATION_PERMISSION_ALLOW: SceLocationPermissionStatus = 1;
pub const __SCE_LOCATION_PERMISSION_APPLICATION: SceLocationPermissionApplicationStatus =
    4294967295;
#[doc = "liblocation access allowed status"]
pub const SCE_LOCATION_PERMISSION_APPLICATION_ALLOW: SceLocationPermissionApplicationStatus = 3;
#[doc = "liblocation access denied status"]
pub const SCE_LOCATION_PERMISSION_APPLICATION_DENY: SceLocationPermissionApplicationStatus = 2;
#[doc = "liblocation not accessed"]
pub const SCE_LOCATION_PERMISSION_APPLICATION_INIT: SceLocationPermissionApplicationStatus = 1;
#[doc = "liblocation not used"]
pub const SCE_LOCATION_PERMISSION_APPLICATION_NONE: SceLocationPermissionApplicationStatus = 0;
#[doc = "liblocation access denied status"]
pub const SCE_LOCATION_PERMISSION_DENY: SceLocationPermissionStatus = 0;
pub const SCE_LOCATION_SUCCESS: SceLocationErrorCode = 0;
pub const SCE_MOTION_ERROR_ALREADY_SAMPLING: SceMotionErrorCode = 2151023111;
pub const SCE_MOTION_ERROR_CALIB_READ_FAIL: SceMotionErrorCode = 2151023108;
pub const SCE_MOTION_ERROR_DATA_INVALID: SceMotionErrorCode = 2151023104;
pub const SCE_MOTION_ERROR_MEM_IN_USE: SceMotionErrorCode = 2151023112;
pub const SCE_MOTION_ERROR_NON_INIT_ERR: SceMotionErrorCode = 2151023106;
pub const SCE_MOTION_ERROR_NOT_SAMPLING: SceMotionErrorCode = 2151023110;
pub const SCE_MOTION_ERROR_OUT_OF_BOUNDS: SceMotionErrorCode = 2151023109;
pub const SCE_MOTION_ERROR_READING: SceMotionErrorCode = 2151023105;
pub const SCE_MOTION_ERROR_STATE_INVALID: SceMotionErrorCode = 2151023107;
pub const SCE_MOTION_MAGFIELD_STABLE: SceMotionMagFieldStability = 2;
pub const SCE_MOTION_MAGFIELD_UNSTABLE: SceMotionMagFieldStability = 0;
pub const SCE_MOTION_MAGFIELD_UNUSED: SceMotionMagFieldStability = 1;
pub const SCE_MSG_DIALOG_BUTTON_ID_BUTTON1: SceMsgDialogButtonId = 1;
pub const SCE_MSG_DIALOG_BUTTON_ID_BUTTON2: SceMsgDialogButtonId = 2;
pub const SCE_MSG_DIALOG_BUTTON_ID_BUTTON3: SceMsgDialogButtonId = 3;
pub const SCE_MSG_DIALOG_BUTTON_ID_INVALID: SceMsgDialogButtonId = 0;
pub const SCE_MSG_DIALOG_BUTTON_ID_NO: SceMsgDialogButtonId = 2;
pub const SCE_MSG_DIALOG_BUTTON_ID_OK: SceMsgDialogButtonId = 1;
pub const SCE_MSG_DIALOG_BUTTON_ID_RETRY: SceMsgDialogButtonId = 3;
pub const SCE_MSG_DIALOG_BUTTON_ID_YES: SceMsgDialogButtonId = 1;
pub const SCE_MSG_DIALOG_BUTTON_TYPE_3BUTTONS: SceMsgDialogButtonType = 5;
pub const SCE_MSG_DIALOG_BUTTON_TYPE_CANCEL: SceMsgDialogButtonType = 4;
pub const SCE_MSG_DIALOG_BUTTON_TYPE_NONE: SceMsgDialogButtonType = 2;
pub const SCE_MSG_DIALOG_BUTTON_TYPE_OK: SceMsgDialogButtonType = 0;
pub const SCE_MSG_DIALOG_BUTTON_TYPE_OK_CANCEL: SceMsgDialogButtonType = 3;
pub const SCE_MSG_DIALOG_BUTTON_TYPE_YESNO: SceMsgDialogButtonType = 1;
pub const SCE_MSG_DIALOG_ENV_FLAG_DEFAULT: SceMsgDialogEnvFlag = 0;
#[doc = "Illegal parameter"]
pub const SCE_MSG_DIALOG_ERROR_PARAM: SceMsgDialogErrorCode = 2148534785;
pub const SCE_MSG_DIALOG_FONT_SIZE_DEFAULT: SceMsgDialogFontSize = 0;
pub const SCE_MSG_DIALOG_FONT_SIZE_SMALL: SceMsgDialogFontSize = 1;
pub const SCE_MSG_DIALOG_MODE_ERROR_CODE: SceMsgDialogMode = 3;
pub const SCE_MSG_DIALOG_MODE_INVALID: SceMsgDialogMode = 0;
pub const SCE_MSG_DIALOG_MODE_PROGRESS_BAR: SceMsgDialogMode = 4;
pub const SCE_MSG_DIALOG_MODE_SYSTEM_MSG: SceMsgDialogMode = 2;
pub const SCE_MSG_DIALOG_MODE_USER_MSG: SceMsgDialogMode = 1;
pub const SCE_MSG_DIALOG_PROGRESSBAR_TARGET_BAR_DEFAULT: SceMsgDialogProgressBarTarget = 0;
pub const SCE_MSG_DIALOG_PROGRESSBAR_TYPE_PERCENTAGE: SceMsgDialogProgressBarType = 0;
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_INVALID: SceMsgDialogSystemMessageType = 0;
#[doc = "Displays \"Move away from the source of interference, or adjust the compass by moving your PS Vita system as shown below.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_MAGNETIC_CALIBRATION: SceMsgDialogSystemMessageType = 3;
#[doc = "Displays \"Cannot continue the application. No memory card is inserted.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_NEED_MC_CONTINUE: SceMsgDialogSystemMessageType = 7;
#[doc = "Displays \"Cannot perform this operation. No memory card is inserted.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_NEED_MC_OPERATION: SceMsgDialogSystemMessageType = 8;
#[doc = "Displays \"There is not enough free space on the memory card.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_NOSPACE: SceMsgDialogSystemMessageType = 2;
#[doc = "Displays \"No content is available yet.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_TRC_EMPTY_STORE: SceMsgDialogSystemMessageType = 103;
#[doc = "Displays \"You must enable the microphone.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_TRC_MIC_DISABLED: SceMsgDialogSystemMessageType = 100;
#[doc = "Displays \"You must use Wi-Fi to use this application.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_TRC_WIFI_REQUIRED_APPLICATION: SceMsgDialogSystemMessageType =
    102;
#[doc = "Displays \"You must use Wi-Fi to do this.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_TRC_WIFI_REQUIRED_OPERATION: SceMsgDialogSystemMessageType =
    101;
#[doc = "Displays \"Please wait.\""]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_WAIT: SceMsgDialogSystemMessageType = 1;
#[doc = "Displays \"Please wait...\" with a cancel button"]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_WAIT_CANCEL: SceMsgDialogSystemMessageType = 6;
#[doc = "Displays \"Please wait.\" in a small message dialog"]
pub const SCE_MSG_DIALOG_SYSMSG_TYPE_WAIT_SMALL: SceMsgDialogSystemMessageType = 5;
pub const SCE_MSG_DIALOG_USER_MSG_SIZE: u32 = 512;
pub const SCE_NET_ADHOCCTL_ADHOCID_LEN: u32 = 9;
pub const SCE_NET_ADHOCCTL_ADHOCTYPE_PRODUCT_ID: ScePspnetAdhocctlAdhocType = 0;
pub const SCE_NET_ADHOCCTL_ADHOCTYPE_RESERVED: ScePspnetAdhocctlAdhocType = 1;
pub const SCE_NET_ADHOCCTL_ADHOCTYPE_SYSTEM: ScePspnetAdhocctlAdhocType = 2;
pub const SCE_NET_ADHOCCTL_BSSID_LEN: u32 = 6;
pub const SCE_NET_ADHOCCTL_GROUPNAME_LEN: u32 = 8;
pub const SCE_NET_ADHOCCTL_NICKNAME_LEN: u32 = 128;
pub const SCE_NET_ADHOC_EV_ACCEPT: ScePspnetAdhocEvent = 8;
pub const SCE_NET_ADHOC_EV_ALERT: ScePspnetAdhocEvent = 1024;
pub const SCE_NET_ADHOC_EV_CONNECT: ScePspnetAdhocEvent = 4;
pub const SCE_NET_ADHOC_EV_DELETE: ScePspnetAdhocEvent = 512;
pub const SCE_NET_ADHOC_EV_DISCONNECT: ScePspnetAdhocEvent = 2048;
pub const SCE_NET_ADHOC_EV_FLUSH: ScePspnetAdhocEvent = 16;
pub const SCE_NET_ADHOC_EV_INVALID: ScePspnetAdhocEvent = 256;
pub const SCE_NET_ADHOC_EV_RECV: ScePspnetAdhocEvent = 2;
pub const SCE_NET_ADHOC_EV_SEND: ScePspnetAdhocEvent = 1;
pub const SCE_NET_ADHOC_F_ALERTACCEPT: ScePspnetAdhocFlags = 256;
pub const SCE_NET_ADHOC_F_ALERTCONNECT: ScePspnetAdhocFlags = 128;
pub const SCE_NET_ADHOC_F_ALERTFLUSH: ScePspnetAdhocFlags = 512;
pub const SCE_NET_ADHOC_F_ALERTPOLL: ScePspnetAdhocFlags = 64;
pub const SCE_NET_ADHOC_F_ALERTRECV: ScePspnetAdhocFlags = 32;
pub const SCE_NET_ADHOC_F_ALERTSEND: ScePspnetAdhocFlags = 16;
pub const SCE_NET_ADHOC_F_NONBLOCK: ScePspnetAdhocFlags = 1;
pub const SCE_NET_ADHOC_PDP_MFS: u32 = 1444;
pub const SCE_NET_ADHOC_PDP_MTU: u32 = 65523;
pub const SCE_NET_ADHOC_PORT: u32 = 3658;
pub const SCE_NET_ADHOC_PTP_MSS: u32 = 1444;
pub const SCE_NET_ADHOC_PTP_STATE_CLOSED: ScePspnetAdhocPtpState = 0;
pub const SCE_NET_ADHOC_PTP_STATE_ESTABLISHED: ScePspnetAdhocPtpState = 4;
pub const SCE_NET_ADHOC_PTP_STATE_LISTEN: ScePspnetAdhocPtpState = 1;
pub const SCE_NET_ADHOC_PTP_STATE_SYN_RCVD: ScePspnetAdhocPtpState = 3;
pub const SCE_NET_ADHOC_PTP_STATE_SYN_SENT: ScePspnetAdhocPtpState = 2;
pub const SCE_NET_AF_INET: u32 = 2;
pub const SCE_NETCHECK_DIALOG_AGE_RESTRICTION_COUNT_MAX: u32 = 200;
pub const SCE_NETCHECK_DIALOG_COUNTRY_CODE_LEN: u32 = 2;
pub const SCE_NETCHECK_DIALOG_ERROR_INVALID_MODE: SceNetCheckDialoErrorCode = 2148535298;
pub const SCE_NETCHECK_DIALOG_ERROR_INVALID_PSPADHOC_PARAM: SceNetCheckDialoErrorCode = 2148535303;
pub const SCE_NETCHECK_DIALOG_ERROR_INVALID_TIMEOUT_PARAM: SceNetCheckDialoErrorCode = 2148535304;
pub const SCE_NETCHECK_DIALOG_ERROR_LACK_OF_LIBHTTP_POOL_SIZE: SceNetCheckDialoErrorCode =
    2148535299;
pub const SCE_NETCHECK_DIALOG_ERROR_LACK_OF_LIBSSL_POOL_SIZE: SceNetCheckDialoErrorCode =
    2148535300;
pub const SCE_NETCHECK_DIALOG_ERROR_LATEST_PATCH_PKG_EXIST: SceNetCheckDialoErrorCode = 2148535301;
pub const SCE_NETCHECK_DIALOG_ERROR_PARAM: SceNetCheckDialoErrorCode = 2148535297;
pub const SCE_NETCHECK_DIALOG_ERROR_PSN_AGE_RESTRICTION: SceNetCheckDialoErrorCode = 2148535305;
pub const SCE_NETCHECK_DIALOG_ERROR_SIGN_OUT: SceNetCheckDialoErrorCode = 2148535302;
pub const SCE_NETCHECK_DIALOG_INITIAL_AGE_RESTRICTION: i32 = -1;
pub const SCE_NETCHECK_DIALOG_LEAST_HTTP_POOL_SIZE: u32 = 36864;
pub const SCE_NETCHECK_DIALOG_LEAST_SSL_POOL_SIZE: u32 = 98304;
pub const SCE_NETCHECK_DIALOG_MODE_ADHOC_CONN: SceNetCheckDialogMode = 1;
pub const SCE_NETCHECK_DIALOG_MODE_INVALID: SceNetCheckDialogMode = 0;
pub const SCE_NETCHECK_DIALOG_MODE_PS3_CONNECT: SceNetCheckDialogMode = 4;
pub const SCE_NETCHECK_DIALOG_MODE_PSN: SceNetCheckDialogMode = 2;
pub const SCE_NETCHECK_DIALOG_MODE_PSN_ONLINE: SceNetCheckDialogMode = 3;
pub const SCE_NETCHECK_DIALOG_MODE_PSP_ADHOC_CONN: SceNetCheckDialogMode = 5;
pub const SCE_NETCHECK_DIALOG_MODE_PSP_ADHOC_CREATE: SceNetCheckDialogMode = 6;
pub const SCE_NETCHECK_DIALOG_MODE_PSP_ADHOC_JOIN: SceNetCheckDialogMode = 7;
pub const SCE_NETCHECK_DIALOG_PS3_CONNECT_ACTION_ENTER: SceNetCheckDialogPS3ConnectAction = 0;
pub const SCE_NETCHECK_DIALOG_PS3_CONNECT_ACTION_LEAVE: SceNetCheckDialogPS3ConnectAction = 1;
pub const SCE_NETCTL_INFO_CONFIG_NAME_LEN_MAX: u32 = 64;
pub const SCE_NETCTL_INFO_GET_BSSID: SceNetCtlInfoType = 6;
pub const SCE_NETCTL_INFO_GET_CHANNEL: SceNetCtlInfoType = 11;
pub const SCE_NETCTL_INFO_GET_CNF_NAME: SceNetCtlInfoType = 1;
pub const SCE_NETCTL_INFO_GET_DEFAULT_ROUTE: SceNetCtlInfoType = 17;
pub const SCE_NETCTL_INFO_GET_DEVICE: SceNetCtlInfoType = 2;
pub const SCE_NETCTL_INFO_GET_DHCP_HOSTNAME: SceNetCtlInfoType = 13;
pub const SCE_NETCTL_INFO_GET_ETHER_ADDR: SceNetCtlInfoType = 3;
pub const SCE_NETCTL_INFO_GET_HTTP_PROXY_CONFIG: SceNetCtlInfoType = 20;
pub const SCE_NETCTL_INFO_GET_HTTP_PROXY_PORT: SceNetCtlInfoType = 22;
pub const SCE_NETCTL_INFO_GET_HTTP_PROXY_SERVER: SceNetCtlInfoType = 21;
pub const SCE_NETCTL_INFO_GET_IP_ADDRESS: SceNetCtlInfoType = 15;
pub const SCE_NETCTL_INFO_GET_IP_CONFIG: SceNetCtlInfoType = 12;
pub const SCE_NETCTL_INFO_GET_LINK: SceNetCtlInfoType = 5;
pub const SCE_NETCTL_INFO_GET_MTU: SceNetCtlInfoType = 4;
pub const SCE_NETCTL_INFO_GET_NETMASK: SceNetCtlInfoType = 16;
pub const SCE_NETCTL_INFO_GET_PPPOE_AUTH_NAME: SceNetCtlInfoType = 14;
pub const SCE_NETCTL_INFO_GET_PRIMARY_DNS: SceNetCtlInfoType = 18;
pub const SCE_NETCTL_INFO_GET_RSSI_DBM: SceNetCtlInfoType = 9;
pub const SCE_NETCTL_INFO_GET_RSSI_PERCENTAGE: SceNetCtlInfoType = 10;
pub const SCE_NETCTL_INFO_GET_SECONDARY_DNS: SceNetCtlInfoType = 19;
pub const SCE_NETCTL_INFO_GET_SSID: SceNetCtlInfoType = 7;
pub const SCE_NETCTL_INFO_GET_WIFI_SECURITY: SceNetCtlInfoType = 8;
pub const SCE_NETCTL_INFO_SSID_LEN_MAX: u32 = 32;
pub const SCE_NETCTL_STATE_CONNECTED: SceNetCtlState = 3;
pub const SCE_NETCTL_STATE_CONNECTING: SceNetCtlState = 1;
pub const SCE_NETCTL_STATE_DISCONNECTED: SceNetCtlState = 0;
pub const SCE_NETCTL_STATE_FINALIZING: SceNetCtlState = 2;
pub const SCE_NET_DEBUG_NAME_LEN_MAX: u32 = 31;
pub const SCE_NET_DUMP_ABORT_FLAG_PRESERVATION: SceNetDumpType = 1;
pub const SCE_NET_DUMP_DONTWAIT: SceNetDumpType = 32;
pub const SCE_NET_DUMP_OVERFLOW: SceNetDumpType = 64;
pub const SCE_NET_DUMP_PEEK: SceNetDumpType = 16;
pub const SCE_NET_E2BIG: SceNetKernelErrorCode = 7;
pub const SCE_NET_EACCES: SceNetKernelErrorCode = 13;
pub const SCE_NET_EADDRINUSE: SceNetKernelErrorCode = 48;
pub const SCE_NET_EADDRNOTAVAIL: SceNetKernelErrorCode = 49;
pub const SCE_NET_EADHOC: SceNetKernelErrorCode = 160;
pub const SCE_NET_EAFNOSUPPORT: SceNetKernelErrorCode = 47;
pub const SCE_NET_EAGAIN: SceNetKernelErrorCode = 35;
pub const SCE_NET_EALREADY: SceNetKernelErrorCode = 37;
pub const SCE_NET_EAUTH: SceNetKernelErrorCode = 80;
pub const SCE_NET_EBADF: SceNetKernelErrorCode = 9;
pub const SCE_NET_EBADMSG: SceNetKernelErrorCode = 88;
pub const SCE_NET_EBADRPC: SceNetKernelErrorCode = 72;
pub const SCE_NET_EBUSY: SceNetKernelErrorCode = 16;
pub const SCE_NET_ECALLBACK: SceNetLibnetErrorCode = 203;
pub const SCE_NET_ECANCELED: SceNetKernelErrorCode = 87;
pub const SCE_NET_ECHILD: SceNetKernelErrorCode = 10;
pub const SCE_NET_ECONNABORTED: SceNetKernelErrorCode = 53;
pub const SCE_NET_ECONNREFUSED: SceNetKernelErrorCode = 61;
pub const SCE_NET_ECONNRESET: SceNetKernelErrorCode = 54;
pub const SCE_NET_EDEADLK: SceNetKernelErrorCode = 11;
pub const SCE_NET_EDESTADDRREQ: SceNetKernelErrorCode = 39;
pub const SCE_NET_EDISABLEDIF: SceNetKernelErrorCode = 161;
pub const SCE_NET_EDOM: SceNetKernelErrorCode = 33;
pub const SCE_NET_EDQUOT: SceNetKernelErrorCode = 69;
pub const SCE_NET_EEXIST: SceNetKernelErrorCode = 17;
pub const SCE_NET_EFAULT: SceNetKernelErrorCode = 14;
pub const SCE_NET_EFBIG: SceNetKernelErrorCode = 27;
pub const SCE_NET_EFTYPE: SceNetKernelErrorCode = 79;
pub const SCE_NET_EHOSTDOWN: SceNetKernelErrorCode = 64;
pub const SCE_NET_EHOSTUNREACH: SceNetKernelErrorCode = 65;
pub const SCE_NET_EIDRM: SceNetKernelErrorCode = 82;
pub const SCE_NET_EILSEQ: SceNetKernelErrorCode = 85;
pub const SCE_NET_EINPROGRESS: SceNetKernelErrorCode = 36;
pub const SCE_NET_EINTERNAL: SceNetLibnetErrorCode = 204;
pub const SCE_NET_EINTR: SceNetKernelErrorCode = 4;
pub const SCE_NET_EINVAL: SceNetKernelErrorCode = 22;
pub const SCE_NET_EIO: SceNetKernelErrorCode = 5;
pub const SCE_NET_EISCONN: SceNetKernelErrorCode = 56;
pub const SCE_NET_EISDIR: SceNetKernelErrorCode = 21;
pub const SCE_NET_ELOOP: SceNetKernelErrorCode = 62;
pub const SCE_NET_EMFILE: SceNetKernelErrorCode = 24;
pub const SCE_NET_EMLINK: SceNetKernelErrorCode = 31;
pub const SCE_NET_EMSGSIZE: SceNetKernelErrorCode = 40;
pub const SCE_NET_EMULATION_FLAG_ETH0: SceNetEmulationFlag = 1;
pub const SCE_NET_EMULATION_FLAG_WLAN0: SceNetEmulationFlag = 2;
pub const SCE_NET_ENAMETOOLONG: SceNetKernelErrorCode = 63;
pub const SCE_NET_ENEEDAUTH: SceNetKernelErrorCode = 81;
pub const SCE_NET_ENETDOWN: SceNetKernelErrorCode = 50;
pub const SCE_NET_ENETRESET: SceNetKernelErrorCode = 52;
pub const SCE_NET_ENETUNREACH: SceNetKernelErrorCode = 51;
pub const SCE_NET_ENFILE: SceNetKernelErrorCode = 23;
pub const SCE_NET_ENOBUFS: SceNetKernelErrorCode = 55;
pub const SCE_NET_ENODATA: SceNetKernelErrorCode = 89;
pub const SCE_NET_ENODEV: SceNetKernelErrorCode = 19;
pub const SCE_NET_ENOENT: SceNetKernelErrorCode = 2;
pub const SCE_NET_ENOEXEC: SceNetKernelErrorCode = 8;
pub const SCE_NET_ENOLCK: SceNetKernelErrorCode = 77;
pub const SCE_NET_ENOLIBMEM: SceNetLibnetErrorCode = 201;
pub const SCE_NET_ENOMEM: SceNetKernelErrorCode = 12;
pub const SCE_NET_ENOMSG: SceNetKernelErrorCode = 83;
pub const SCE_NET_ENOPROTOOPT: SceNetKernelErrorCode = 42;
pub const SCE_NET_ENOSPC: SceNetKernelErrorCode = 28;
pub const SCE_NET_ENOSR: SceNetKernelErrorCode = 90;
pub const SCE_NET_ENOSTR: SceNetKernelErrorCode = 91;
pub const SCE_NET_ENOSYS: SceNetKernelErrorCode = 78;
pub const SCE_NET_ENOTBLK: SceNetKernelErrorCode = 15;
pub const SCE_NET_ENOTCONN: SceNetKernelErrorCode = 57;
pub const SCE_NET_ENOTDIR: SceNetKernelErrorCode = 20;
pub const SCE_NET_ENOTEMPTY: SceNetKernelErrorCode = 66;
pub const SCE_NET_ENOTINIT: SceNetLibnetErrorCode = 200;
pub const SCE_NET_ENOTSOCK: SceNetKernelErrorCode = 38;
pub const SCE_NET_ENOTSUP: SceNetKernelErrorCode = 86;
pub const SCE_NET_ENOTTY: SceNetKernelErrorCode = 25;
pub const SCE_NET_ENXIO: SceNetKernelErrorCode = 6;
pub const SCE_NET_EOPNOTSUPP: SceNetKernelErrorCode = 45;
pub const SCE_NET_EOVERFLOW: SceNetKernelErrorCode = 84;
pub const SCE_NET_EPERM: SceNetKernelErrorCode = 1;
pub const SCE_NET_EPFNOSUPPORT: SceNetKernelErrorCode = 46;
pub const SCE_NET_EPIPE: SceNetKernelErrorCode = 32;
pub const SCE_NET_EPOLL_ABORT_FLAG_PRESERVATION: u32 = 1;
pub const SCE_NET_EPOLL_CTL_ADD: SceNetEpollControlFlag = 1;
pub const SCE_NET_EPOLL_CTL_DEL: SceNetEpollControlFlag = 3;
pub const SCE_NET_EPOLL_CTL_MOD: SceNetEpollControlFlag = 2;
pub const SCE_NET_EPOLLDESCID: SceNetEpollEventType = 65536;
pub const SCE_NET_EPOLLERR: SceNetEpollEventType = 8;
pub const SCE_NET_EPOLLHUP: SceNetEpollEventType = 16;
pub const SCE_NET_EPOLLIN: SceNetEpollEventType = 1;
pub const SCE_NET_EPOLLOUT: SceNetEpollEventType = 2;
pub const SCE_NET_EPROCLIM: SceNetKernelErrorCode = 67;
pub const SCE_NET_EPROCUNAVAIL: SceNetKernelErrorCode = 76;
pub const SCE_NET_EPROGMISMATCH: SceNetKernelErrorCode = 75;
pub const SCE_NET_EPROGUNAVAIL: SceNetKernelErrorCode = 74;
pub const SCE_NET_EPROTONOSUPPORT: SceNetKernelErrorCode = 43;
pub const SCE_NET_EPROTOTYPE: SceNetKernelErrorCode = 41;
pub const SCE_NET_ERANGE: SceNetKernelErrorCode = 34;
pub const SCE_NET_EREMOTE: SceNetKernelErrorCode = 71;
pub const SCE_NET_ERESUME: SceNetKernelErrorCode = 162;
pub const SCE_NET_ERETURN: SceNetLibnetErrorCode = 205;
pub const SCE_NET_EROFS: SceNetKernelErrorCode = 30;
pub const SCE_NET_ERPCMISMATCH: SceNetKernelErrorCode = 73;
pub const SCE_NET_ERROR_E2BIG: SceNetErrorCode = 2151743751;
pub const SCE_NET_ERROR_EACCES: SceNetErrorCode = 2151743757;
pub const SCE_NET_ERROR_EADDRINUSE: SceNetErrorCode = 2151743792;
pub const SCE_NET_ERROR_EADDRNOTAVAIL: SceNetErrorCode = 2151743793;
pub const SCE_NET_ERROR_EADHOC: SceNetErrorCode = 2151743904;
pub const SCE_NET_ERROR_EAFNOSUPPORT: SceNetErrorCode = 2151743791;
pub const SCE_NET_ERROR_EAGAIN: SceNetErrorCode = 2151743779;
pub const SCE_NET_ERROR_EALREADY: SceNetErrorCode = 2151743781;
pub const SCE_NET_ERROR_EAUTH: SceNetErrorCode = 2151743824;
pub const SCE_NET_ERROR_EBADF: SceNetErrorCode = 2151743753;
pub const SCE_NET_ERROR_EBADMSG: SceNetErrorCode = 2151743832;
pub const SCE_NET_ERROR_EBADRPC: SceNetErrorCode = 2151743816;
pub const SCE_NET_ERROR_EBUSY: SceNetErrorCode = 2151743760;
pub const SCE_NET_ERROR_ECALLBACK: SceNetErrorCode = 2151743947;
pub const SCE_NET_ERROR_ECANCELED: SceNetErrorCode = 2151743831;
pub const SCE_NET_ERROR_ECHILD: SceNetErrorCode = 2151743754;
pub const SCE_NET_ERROR_ECONNABORTED: SceNetErrorCode = 2151743797;
pub const SCE_NET_ERROR_ECONNREFUSED: SceNetErrorCode = 2151743805;
pub const SCE_NET_ERROR_ECONNRESET: SceNetErrorCode = 2151743798;
pub const SCE_NET_ERROR_EDEADLK: SceNetErrorCode = 2151743755;
pub const SCE_NET_ERROR_EDESTADDRREQ: SceNetErrorCode = 2151743783;
pub const SCE_NET_ERROR_EDISABLEDIF: SceNetErrorCode = 2151743905;
pub const SCE_NET_ERROR_EDOM: SceNetErrorCode = 2151743777;
pub const SCE_NET_ERROR_EDQUOT: SceNetErrorCode = 2151743813;
pub const SCE_NET_ERROR_EEXIST: SceNetErrorCode = 2151743761;
pub const SCE_NET_ERROR_EFAULT: SceNetErrorCode = 2151743758;
pub const SCE_NET_ERROR_EFBIG: SceNetErrorCode = 2151743771;
pub const SCE_NET_ERROR_EFTYPE: SceNetErrorCode = 2151743823;
pub const SCE_NET_ERROR_EHOSTDOWN: SceNetErrorCode = 2151743808;
pub const SCE_NET_ERROR_EHOSTUNREACH: SceNetErrorCode = 2151743809;
pub const SCE_NET_ERROR_EIDRM: SceNetErrorCode = 2151743826;
pub const SCE_NET_ERROR_EILSEQ: SceNetErrorCode = 2151743829;
pub const SCE_NET_ERROR_EINPROGRESS: SceNetErrorCode = 2151743780;
pub const SCE_NET_ERROR_EINTERNAL: SceNetErrorCode = 2151743948;
pub const SCE_NET_ERROR_EINTR: SceNetErrorCode = 2151743748;
pub const SCE_NET_ERROR_EINVAL: SceNetErrorCode = 2151743766;
pub const SCE_NET_ERROR_EIO: SceNetErrorCode = 2151743749;
pub const SCE_NET_ERROR_EISCONN: SceNetErrorCode = 2151743800;
pub const SCE_NET_ERROR_EISDIR: SceNetErrorCode = 2151743765;
pub const SCE_NET_ERROR_ELOOP: SceNetErrorCode = 2151743806;
pub const SCE_NET_ERROR_EMFILE: SceNetErrorCode = 2151743768;
pub const SCE_NET_ERROR_EMLINK: SceNetErrorCode = 2151743775;
pub const SCE_NET_ERROR_EMSGSIZE: SceNetErrorCode = 2151743784;
pub const SCE_NET_ERROR_ENAMETOOLONG: SceNetErrorCode = 2151743807;
pub const SCE_NET_ERROR_ENEEDAUTH: SceNetErrorCode = 2151743825;
pub const SCE_NET_ERROR_ENETDOWN: SceNetErrorCode = 2151743794;
pub const SCE_NET_ERROR_ENETRESET: SceNetErrorCode = 2151743796;
pub const SCE_NET_ERROR_ENETUNREACH: SceNetErrorCode = 2151743795;
pub const SCE_NET_ERROR_ENFILE: SceNetErrorCode = 2151743767;
pub const SCE_NET_ERROR_ENOBUFS: SceNetErrorCode = 2151743799;
pub const SCE_NET_ERROR_ENODATA: SceNetErrorCode = 2151743833;
pub const SCE_NET_ERROR_ENODEV: SceNetErrorCode = 2151743763;
pub const SCE_NET_ERROR_ENOENT: SceNetErrorCode = 2151743746;
pub const SCE_NET_ERROR_ENOEXEC: SceNetErrorCode = 2151743752;
pub const SCE_NET_ERROR_ENOLCK: SceNetErrorCode = 2151743821;
pub const SCE_NET_ERROR_ENOLIBMEM: SceNetErrorCode = 2151743945;
pub const SCE_NET_ERROR_ENOMEM: SceNetErrorCode = 2151743756;
pub const SCE_NET_ERROR_ENOMS: SceNetErrorCode = 2151743827;
pub const SCE_NET_ERROR_ENOPROTOOPT: SceNetErrorCode = 2151743786;
pub const SCE_NET_ERROR_ENOSPC: SceNetErrorCode = 2151743772;
pub const SCE_NET_ERROR_ENOSR: SceNetErrorCode = 2151743834;
pub const SCE_NET_ERROR_ENOSTR: SceNetErrorCode = 2151743835;
pub const SCE_NET_ERROR_ENOSYS: SceNetErrorCode = 2151743822;
pub const SCE_NET_ERROR_ENOTBLK: SceNetErrorCode = 2151743759;
pub const SCE_NET_ERROR_ENOTCONN: SceNetErrorCode = 2151743801;
pub const SCE_NET_ERROR_ENOTDIR: SceNetErrorCode = 2151743764;
pub const SCE_NET_ERROR_ENOTEMPTY: SceNetErrorCode = 2151743810;
pub const SCE_NET_ERROR_ENOTINIT: SceNetErrorCode = 2151743944;
pub const SCE_NET_ERROR_ENOTSOCK: SceNetErrorCode = 2151743782;
pub const SCE_NET_ERROR_ENOTSUP: SceNetErrorCode = 2151743830;
pub const SCE_NET_ERROR_ENOTTY: SceNetErrorCode = 2151743769;
pub const SCE_NET_ERROR_ENXIO: SceNetErrorCode = 2151743750;
pub const SCE_NET_ERROR_EOPNOTSUPP: SceNetErrorCode = 2151743789;
pub const SCE_NET_ERROR_EOVERFLOW: SceNetErrorCode = 2151743828;
pub const SCE_NET_ERROR_EPERM: SceNetErrorCode = 2151743745;
pub const SCE_NET_ERROR_EPFNOSUPPORT: SceNetErrorCode = 2151743790;
pub const SCE_NET_ERROR_EPIPE: SceNetErrorCode = 2151743776;
pub const SCE_NET_ERROR_EPROCLIM: SceNetErrorCode = 2151743811;
pub const SCE_NET_ERROR_EPROCUNAVAIL: SceNetErrorCode = 2151743820;
pub const SCE_NET_ERROR_EPROGMISMATCH: SceNetErrorCode = 2151743819;
pub const SCE_NET_ERROR_EPROGUNAVAIL: SceNetErrorCode = 2151743818;
pub const SCE_NET_ERROR_EPROTONOSUPPORT: SceNetErrorCode = 2151743787;
pub const SCE_NET_ERROR_EPROTOTYPE: SceNetErrorCode = 2151743785;
pub const SCE_NET_ERROR_ERANGE: SceNetErrorCode = 2151743778;
pub const SCE_NET_ERROR_EREMOTE: SceNetErrorCode = 2151743815;
pub const SCE_NET_ERROR_ERESERVED202: SceNetErrorCode = 2151743946;
pub const SCE_NET_ERROR_ERESUME: SceNetErrorCode = 2151743906;
pub const SCE_NET_ERROR_ERETURN: SceNetErrorCode = 2151743949;
pub const SCE_NET_ERROR_EROFS: SceNetErrorCode = 2151743774;
pub const SCE_NET_ERROR_ERPCMISMATCH: SceNetErrorCode = 2151743817;
pub const SCE_NET_ERROR_ESHUTDOWN: SceNetErrorCode = 2151743802;
pub const SCE_NET_ERROR_ESOCKTNOSUPPORT: SceNetErrorCode = 2151743788;
pub const SCE_NET_ERROR_ESPIPE: SceNetErrorCode = 2151743773;
pub const SCE_NET_ERROR_ESRCH: SceNetErrorCode = 2151743747;
pub const SCE_NET_ERROR_ESTALE: SceNetErrorCode = 2151743814;
pub const SCE_NET_ERROR_ETIME: SceNetErrorCode = 2151743836;
pub const SCE_NET_ERROR_ETIMEDOUT: SceNetErrorCode = 2151743804;
pub const SCE_NET_ERROR_ETOOMANYREFS: SceNetErrorCode = 2151743803;
pub const SCE_NET_ERROR_ETXTBSY: SceNetErrorCode = 2151743770;
pub const SCE_NET_ERROR_EUSERS: SceNetErrorCode = 2151743812;
pub const SCE_NET_ERROR_EWOULDBLOCK: SceNetErrorCode = 2151743779;
pub const SCE_NET_ERROR_EXDEV: SceNetErrorCode = 2151743762;
pub const SCE_NET_ERROR_RESOLVER_EALIGNMENT: SceNetErrorCode = 2151743978;
pub const SCE_NET_ERROR_RESOLVER_EBUSY: SceNetErrorCode = 2151743965;
pub const SCE_NET_ERROR_RESOLVER_EFORMAT: SceNetErrorCode = 2151743972;
pub const SCE_NET_ERROR_RESOLVER_EINTERNAL: SceNetErrorCode = 2151743964;
pub const SCE_NET_ERROR_RESOLVER_ENODNS: SceNetErrorCode = 2151743969;
pub const SCE_NET_ERROR_RESOLVER_ENOHOST: SceNetErrorCode = 2151743974;
pub const SCE_NET_ERROR_RESOLVER_ENORECORD: SceNetErrorCode = 2151743977;
pub const SCE_NET_ERROR_RESOLVER_ENOSPACE: SceNetErrorCode = 2151743966;
pub const SCE_NET_ERROR_RESOLVER_ENOSUPPORT: SceNetErrorCode = 2151743971;
pub const SCE_NET_ERROR_RESOLVER_ENOTIMPLEMENTED: SceNetErrorCode = 2151743975;
pub const SCE_NET_ERROR_RESOLVER_EPACKET: SceNetErrorCode = 2151743967;
pub const SCE_NET_ERROR_RESOLVER_ERESERVED22: SceNetErrorCode = 2151743968;
pub const SCE_NET_ERROR_RESOLVER_ESERVERFAILURE: SceNetErrorCode = 2151743973;
pub const SCE_NET_ERROR_RESOLVER_ESERVERREFUSED: SceNetErrorCode = 2151743976;
pub const SCE_NET_ERROR_RESOLVER_ETIMEDOUT: SceNetErrorCode = 2151743970;
pub const SCE_NET_ESHUTDOWN: SceNetKernelErrorCode = 58;
pub const SCE_NET_ESOCKTNOSUPPORT: SceNetKernelErrorCode = 44;
pub const SCE_NET_ESPIPE: SceNetKernelErrorCode = 29;
pub const SCE_NET_ESRCH: SceNetKernelErrorCode = 3;
pub const SCE_NET_ESTALE: SceNetKernelErrorCode = 70;
pub const SCE_NET_ETIME: SceNetKernelErrorCode = 92;
pub const SCE_NET_ETIMEDOUT: SceNetKernelErrorCode = 60;
pub const SCE_NET_ETLS: SceNetLibnetErrorCode = 202;
pub const SCE_NET_ETOOMANYREFS: SceNetKernelErrorCode = 59;
pub const SCE_NET_ETXTBSY: SceNetKernelErrorCode = 26;
pub const SCE_NET_EUSERS: SceNetKernelErrorCode = 68;
pub const SCE_NET_EWOULDBLOCK: SceNetKernelErrorCode = 35;
pub const SCE_NET_EXDEV: SceNetKernelErrorCode = 18;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_DST_HOST_UNKNOWN: SceNetIcmpCode = 7;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_DST_NET_UNKNOWN: SceNetIcmpCode = 6;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_FRAG_AND_DF: SceNetIcmpCode = 4;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_HOST_TOS: SceNetIcmpCode = 12;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_HOST_UNREACH: SceNetIcmpCode = 1;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_NET_ADMIN_PROHIBITED: SceNetIcmpCode = 9;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_NET_HOST_PROHIBITED: SceNetIcmpCode = 10;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_NET_TOS: SceNetIcmpCode = 11;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_NET_UNREACH: SceNetIcmpCode = 0;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_PORT_UNREACH: SceNetIcmpCode = 3;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_PROTO_UNREACH: SceNetIcmpCode = 2;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_SRC_HOST_FAILED: SceNetIcmpCode = 5;
pub const SCE_NET_ICMP_CODE_DEST_UNREACH_SRC_HOST_ISOLATED: SceNetIcmpCode = 8;
pub const SCE_NET_ICMP_CODE_TIME_EXCEEDED_FRT_EXCEEDED: SceNetIcmpCode = 1;
pub const SCE_NET_ICMP_CODE_TIME_EXCEEDED_TTL_EXCEEDED: SceNetIcmpCode = 0;
pub const SCE_NET_ICMP_TYPE_ADDRESS_MASK_REPLY: SceNetIcmpType = 18;
pub const SCE_NET_ICMP_TYPE_ADDRESS_MASK_REQUEST: SceNetIcmpType = 17;
pub const SCE_NET_ICMP_TYPE_DEST_UNREACH: SceNetIcmpType = 3;
pub const SCE_NET_ICMP_TYPE_ECHO_REPLY: SceNetIcmpType = 0;
pub const SCE_NET_ICMP_TYPE_ECHO_REQUEST: SceNetIcmpType = 8;
pub const SCE_NET_ICMP_TYPE_INFORMATION_REPLY: SceNetIcmpType = 16;
pub const SCE_NET_ICMP_TYPE_INFORMATION_REQUEST: SceNetIcmpType = 15;
pub const SCE_NET_ICMP_TYPE_PARAMETER_PROBLEM: SceNetIcmpType = 12;
pub const SCE_NET_ICMP_TYPE_REDIRECT: SceNetIcmpType = 5;
pub const SCE_NET_ICMP_TYPE_SOURCE_QUENCH: SceNetIcmpType = 4;
pub const SCE_NET_ICMP_TYPE_TIME_EXCEEDED: SceNetIcmpType = 11;
pub const SCE_NET_ICMP_TYPE_TIMESTAMP_REPLY: SceNetIcmpType = 14;
pub const SCE_NET_ICMP_TYPE_TIMESTAMP_REQUEST: SceNetIcmpType = 13;
pub const SCE_NET_ID_SOCKET_MAX: u32 = 1023;
pub const SCE_NET_ID_SOCKET_MIN: u32 = 0;
pub const SCE_NET_INADDR_ANY: u32 = 0;
pub const SCE_NET_INADDR_AUTOIP: u32 = 2851995648;
pub const SCE_NET_INADDR_BROADCAST: u32 = 4294967295;
pub const SCE_NET_INADDR_LOOPBACK: u32 = 2130706433;
pub const SCE_NET_INADDR_UNSPEC_GROUP: u32 = 3758096384;
pub const SCE_NET_IN_AUTOIP_NET: u32 = 4294901760;
pub const SCE_NET_IN_CLASSD_NET: u32 = 4026531840;
pub const SCE_NET_IP_ADD_MEMBERSHIP: SceNetSocketOption = 12;
pub const SCE_NET_IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const SCE_NET_IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const SCE_NET_IP_DF: u32 = 16384;
pub const SCE_NET_IP_DROP_MEMBERSHIP: SceNetSocketOption = 13;
pub const SCE_NET_IP_HDRINCL: SceNetSocketOption = 2;
pub const SCE_NET_IP_MAXTTL: SceNetSocketOption = 24;
pub const SCE_NET_IP_MF: u32 = 8192;
pub const SCE_NET_IP_MULTICAST_IF: SceNetSocketOption = 9;
pub const SCE_NET_IP_MULTICAST_LOOP: SceNetSocketOption = 11;
pub const SCE_NET_IP_MULTICAST_TTL: SceNetSocketOption = 10;
pub const SCE_NET_IP_OFFMASK: u32 = 8191;
pub const SCE_NET_IPPROTO_ICMP: SceNetProtocol = 1;
pub const SCE_NET_IPPROTO_IGMP: SceNetProtocol = 2;
pub const SCE_NET_IPPROTO_IP: SceNetProtocol = 0;
pub const SCE_NET_IPPROTO_TCP: SceNetProtocol = 6;
pub const SCE_NET_IPPROTO_UDP: SceNetProtocol = 17;
pub const SCE_NET_IP_RF: u32 = 32768;
pub const SCE_NET_IP_TOS: SceNetSocketOption = 3;
pub const SCE_NET_IP_TTL: SceNetSocketOption = 4;
pub const SCE_NET_IP_TTLCHK: SceNetSocketOption = 23;
pub const SCE_NET_IPVERSION: u32 = 4;
pub const SCE_NET_MSG_DONTWAIT: SceNetMsgFlag = 128;
pub const SCE_NET_MSG_PEEK: SceNetMsgFlag = 2;
pub const SCE_NET_MSG_USECRYPTO: SceNetMsgFlag = 1024;
pub const SCE_NET_MSG_USESIGNATURE: SceNetMsgFlag = 2048;
pub const SCE_NET_MSG_WAITALL: SceNetMsgFlag = 64;
pub const SCE_NET_RESOLVER_ABORT_FLAG_ATON_PRESERVATION: SceNetResolverAbortFlag = 2;
pub const SCE_NET_RESOLVER_ABORT_FLAG_NTOA_PRESERVATION: SceNetResolverAbortFlag = 1;
pub const SCE_NET_RESOLVER_ASYNC: SceNetResolverFlag = 1;
pub const SCE_NET_RESOLVER_EALIGNMENT: SceNetResolverErrorCode = 234;
pub const SCE_NET_RESOLVER_EBUSY: SceNetResolverErrorCode = 221;
pub const SCE_NET_RESOLVER_EFORMAT: SceNetResolverErrorCode = 228;
pub const SCE_NET_RESOLVER_EINTERNAL: SceNetResolverErrorCode = 220;
pub const SCE_NET_RESOLVER_ENODNS: SceNetResolverErrorCode = 225;
pub const SCE_NET_RESOLVER_ENOHOST: SceNetResolverErrorCode = 230;
pub const SCE_NET_RESOLVER_ENORECORD: SceNetResolverErrorCode = 233;
pub const SCE_NET_RESOLVER_ENOSPACE: SceNetResolverErrorCode = 222;
pub const SCE_NET_RESOLVER_ENOSUPPORT: SceNetResolverErrorCode = 227;
pub const SCE_NET_RESOLVER_ENOTIMPLEMENTED: SceNetResolverErrorCode = 231;
pub const SCE_NET_RESOLVER_EPACKET: SceNetResolverErrorCode = 223;
pub const SCE_NET_RESOLVER_ERESERVED224: SceNetResolverErrorCode = 224;
pub const SCE_NET_RESOLVER_ESERVERFAILURE: SceNetResolverErrorCode = 229;
pub const SCE_NET_RESOLVER_ESERVERREFUSED: SceNetResolverErrorCode = 232;
pub const SCE_NET_RESOLVER_ETIMEDOUT: SceNetResolverErrorCode = 226;
pub const SCE_NET_RESOLVER_HOSTNAME_LEN_MAX: u32 = 255;
pub const SCE_NET_RESOLVER_PORT: u32 = 53;
pub const SCE_NET_RESOLVER_START_NTOA_DISABLE_IPADDRESS: SceNetResolverFlag = 65536;
pub const SCE_NET_SHUT_RD: SceNetShutdownFlag = 0;
pub const SCE_NET_SHUT_RDWR: SceNetShutdownFlag = 2;
pub const SCE_NET_SHUT_WR: SceNetShutdownFlag = 1;
pub const SCE_NET_SO_BROADCAST: SceNetSocketOption = 32;
pub const SCE_NET_SOCK_DGRAM: SceNetSocketType = 2;
pub const SCE_NET_SOCK_DGRAM_P2P: SceNetSocketType = 6;
pub const SCE_NET_SOCKET_ABORT_FLAG_RCV_PRESERVATION: SceNetSocketAbortFlag = 1;
pub const SCE_NET_SOCKET_ABORT_FLAG_SND_PRESERVATION: SceNetSocketAbortFlag = 2;
pub const SCE_NET_SOCKINFO_F_ALL: SceNetSockInfoFlag = 2031623;
pub const SCE_NET_SOCKINFO_F_KERNEL: SceNetSockInfoFlag = 2;
pub const SCE_NET_SOCKINFO_F_OTHERS: SceNetSockInfoFlag = 4;
pub const SCE_NET_SOCKINFO_F_RECV_EWAIT: SceNetSockInfoFlag = 262144;
pub const SCE_NET_SOCKINFO_F_RECV_WAIT: SceNetSockInfoFlag = 65536;
pub const SCE_NET_SOCKINFO_F_SELF: SceNetSockInfoFlag = 1;
pub const SCE_NET_SOCKINFO_F_SEND_EWAIT: SceNetSockInfoFlag = 524288;
pub const SCE_NET_SOCKINFO_F_SEND_WAIT: SceNetSockInfoFlag = 131072;
pub const SCE_NET_SOCKINFO_F_WAKEUP_SIGNAL: SceNetSockInfoFlag = 1048576;
pub const SCE_NET_SOCKINFO_STATE_CLOSED: SceNetSockInfoState = 1;
pub const SCE_NET_SOCKINFO_STATE_CLOSE_WAIT: SceNetSockInfoState = 9;
pub const SCE_NET_SOCKINFO_STATE_CLOSING: SceNetSockInfoState = 10;
pub const SCE_NET_SOCKINFO_STATE_ESTABLISHED: SceNetSockInfoState = 6;
pub const SCE_NET_SOCKINFO_STATE_FIN_WAIT_1: SceNetSockInfoState = 7;
pub const SCE_NET_SOCKINFO_STATE_FIN_WAIT_2: SceNetSockInfoState = 8;
pub const SCE_NET_SOCKINFO_STATE_LAST_ACK: SceNetSockInfoState = 11;
pub const SCE_NET_SOCKINFO_STATE_LISTEN: SceNetSockInfoState = 3;
pub const SCE_NET_SOCKINFO_STATE_OPENED: SceNetSockInfoState = 2;
pub const SCE_NET_SOCKINFO_STATE_SYN_RECEIVED: SceNetSockInfoState = 5;
pub const SCE_NET_SOCKINFO_STATE_SYN_SENT: SceNetSockInfoState = 4;
pub const SCE_NET_SOCKINFO_STATE_TIME_WAIT: SceNetSockInfoState = 12;
pub const SCE_NET_SOCKINFO_STATE_UNKNOWN: SceNetSockInfoState = 0;
pub const SCE_NET_SOCK_RAW: SceNetSocketType = 3;
pub const SCE_NET_SOCK_STREAM: SceNetSocketType = 1;
pub const SCE_NET_SOCK_STREAM_P2P: SceNetSocketType = 10;
pub const SCE_NET_SO_ERROR: SceNetSocketOption = 4103;
pub const SCE_NET_SO_KEEPALIVE: SceNetSocketOption = 8;
pub const SCE_NET_SO_LINGER: SceNetSocketOption = 128;
pub const SCE_NET_SOL_SOCKET: SceNetProtocol = 65535;
pub const SCE_NET_SO_NAME: SceNetSocketOption = 4354;
pub const SCE_NET_SO_NBIO: SceNetSocketOption = 4352;
pub const SCE_NET_SO_ONESBCAST: SceNetSocketOption = 2048;
pub const SCE_NET_SO_OOBINLINE: SceNetSocketOption = 256;
pub const SCE_NET_SO_RCVBUF: SceNetSocketOption = 4098;
pub const SCE_NET_SO_RCVLOWAT: SceNetSocketOption = 4100;
pub const SCE_NET_SO_RCVTIMEO: SceNetSocketOption = 4102;
pub const SCE_NET_SO_REUSEADDR: SceNetSocketOption = 4;
pub const SCE_NET_SO_REUSEPORT: SceNetSocketOption = 512;
pub const SCE_NET_SO_SNDBUF: SceNetSocketOption = 4097;
pub const SCE_NET_SO_SNDLOWAT: SceNetSocketOption = 4099;
pub const SCE_NET_SO_SNDTIMEO: SceNetSocketOption = 4101;
pub const SCE_NET_SO_TPPOLICY: SceNetSocketOption = 4353;
pub const SCE_NET_SO_TYPE: SceNetSocketOption = 4104;
pub const SCE_NET_SO_USECRYPTO: SceNetSocketOption = 4096;
pub const SCE_NET_SO_USESIGNATURE: SceNetSocketOption = 8192;
pub const SCE_NET_TCP_MAXSEG: SceNetSocketOption = 2;
pub const SCE_NET_TCP_MSS_TO_ADVERTISE: SceNetSocketOption = 3;
pub const SCE_NET_TCP_NODELAY: SceNetSocketOption = 1;
pub const SCE_NOTIFICATIONUTIL_ERROR_INTERNAL: SceNotificationUitlErrorCode = 2148557568;
pub const SCE_NOTIFICATIONUTIL_TEXT_MAX: u32 = 63;
#[doc = "Append"]
pub const SCE_O_APPEND: SceIoMode = 256;
#[doc = "Create"]
pub const SCE_O_CREAT: SceIoMode = 512;
#[doc = "Internal use for ::sceIoDopen"]
pub const SCE_O_DIROPEN: SceIoMode = 8;
#[doc = "Exclusive create"]
pub const SCE_O_EXCL: SceIoMode = 2048;
#[doc = "Exclusive access"]
pub const SCE_O_FDEXCL: SceIoMode = 16777216;
#[doc = "Gamedata access"]
pub const SCE_O_FGAMEDATA: SceIoMode = 1073741824;
pub const SCE_OK: u32 = 0;
#[doc = "Non blocking"]
pub const SCE_O_NBLOCK: SceIoMode = 4;
#[doc = "Number device buffer"]
pub const SCE_O_NOBUF: SceIoMode = 16384;
#[doc = "Asynchronous I/O"]
pub const SCE_O_NOWAIT: SceIoMode = 32768;
#[doc = "Power control lock"]
pub const SCE_O_PWLOCK: SceIoMode = 33554432;
#[doc = "Remote command entry"]
pub const SCE_O_RCOM: SceIoMode = 8192;
#[doc = "Read locked (non-shared)"]
pub const SCE_O_RDLOCK: SceIoMode = 16;
#[doc = "Read-only"]
pub const SCE_O_RDONLY: SceIoMode = 1;
#[doc = "Read/Write"]
pub const SCE_O_RDWR: SceIoMode = 3;
#[doc = "Scan type"]
pub const SCE_O_SCAN: SceIoMode = 4096;
#[doc = "Truncate"]
pub const SCE_O_TRUNC: SceIoMode = 1024;
#[doc = "Write locked (non-shared)"]
pub const SCE_O_WRLOCK: SceIoMode = 32;
#[doc = "Write-only"]
pub const SCE_O_WRONLY: SceIoMode = 2;
pub const SCE_PERF_ARM_PMON_BRANCH_MISPREDICT: _ScePerfArmPmonEventCode = 16;
pub const SCE_PERF_ARM_PMON_COHERENT_LF_HIT: _ScePerfArmPmonEventCode = 81;
pub const SCE_PERF_ARM_PMON_COHERENT_LF_MISS: _ScePerfArmPmonEventCode = 80;
pub const SCE_PERF_ARM_PMON_CYCLE_COUNT: _ScePerfArmPmonEventCode = 17;
pub const SCE_PERF_ARM_PMON_DATAENGINE_CLOCK: _ScePerfArmPmonEventCode = 139;
pub const SCE_PERF_ARM_PMON_DATA_EVICTION: _ScePerfArmPmonEventCode = 101;
pub const SCE_PERF_ARM_PMON_DATA_MAINTLB_STALL: _ScePerfArmPmonEventCode = 131;
pub const SCE_PERF_ARM_PMON_DATA_READ: _ScePerfArmPmonEventCode = 6;
pub const SCE_PERF_ARM_PMON_DATA_UTLB_STALL: _ScePerfArmPmonEventCode = 133;
pub const SCE_PERF_ARM_PMON_DATA_WRITE: _ScePerfArmPmonEventCode = 7;
pub const SCE_PERF_ARM_PMON_DCACHE_ACCESS: _ScePerfArmPmonEventCode = 4;
pub const SCE_PERF_ARM_PMON_DCACHE_MISS: _ScePerfArmPmonEventCode = 3;
pub const SCE_PERF_ARM_PMON_DCACHE_STALL: _ScePerfArmPmonEventCode = 97;
pub const SCE_PERF_ARM_PMON_DMB: _ScePerfArmPmonEventCode = 146;
pub const SCE_PERF_ARM_PMON_DMB_STALL: _ScePerfArmPmonEventCode = 134;
pub const SCE_PERF_ARM_PMON_DSB: _ScePerfArmPmonEventCode = 145;
pub const SCE_PERF_ARM_PMON_DTLB_MISS: _ScePerfArmPmonEventCode = 5;
pub const SCE_PERF_ARM_PMON_EXCEPTION_RETURN: _ScePerfArmPmonEventCode = 10;
pub const SCE_PERF_ARM_PMON_EXCEPTION_TAKEN: _ScePerfArmPmonEventCode = 9;
pub const SCE_PERF_ARM_PMON_EXT_INTERRUPT: _ScePerfArmPmonEventCode = 147;
pub const SCE_PERF_ARM_PMON_FPU_RENAME: _ScePerfArmPmonEventCode = 115;
pub const SCE_PERF_ARM_PMON_ICACHE_MISS: _ScePerfArmPmonEventCode = 1;
pub const SCE_PERF_ARM_PMON_ICACHE_STALL: _ScePerfArmPmonEventCode = 96;
pub const SCE_PERF_ARM_PMON_IMMEDIATE_BRANCH: _ScePerfArmPmonEventCode = 13;
pub const SCE_PERF_ARM_PMON_INST_MAINTLB_STALL: _ScePerfArmPmonEventCode = 130;
pub const SCE_PERF_ARM_PMON_INST_RENAME: _ScePerfArmPmonEventCode = 104;
pub const SCE_PERF_ARM_PMON_INST_UTLB_STALL: _ScePerfArmPmonEventCode = 132;
pub const SCE_PERF_ARM_PMON_INTEGER_CLOCK: _ScePerfArmPmonEventCode = 138;
pub const SCE_PERF_ARM_PMON_ISB: _ScePerfArmPmonEventCode = 144;
pub const SCE_PERF_ARM_PMON_ISSUE_EMPTY: _ScePerfArmPmonEventCode = 103;
pub const SCE_PERF_ARM_PMON_ISSUE_NO_DISPATCH: _ScePerfArmPmonEventCode = 102;
pub const SCE_PERF_ARM_PMON_ITLB_MISS: _ScePerfArmPmonEventCode = 2;
pub const SCE_PERF_ARM_PMON_LS_PIPE: _ScePerfArmPmonEventCode = 114;
pub const SCE_PERF_ARM_PMON_MAIN_PIPE: _ScePerfArmPmonEventCode = 112;
pub const SCE_PERF_ARM_PMON_MAINTLB_STALL: _ScePerfArmPmonEventCode = 98;
pub const SCE_PERF_ARM_PMON_NEON_RENAME: _ScePerfArmPmonEventCode = 116;
pub const SCE_PERF_ARM_PMON_PLD_STALL: _ScePerfArmPmonEventCode = 128;
pub const SCE_PERF_ARM_PMON_PLE_CHANNEL_SKIPPED: _ScePerfArmPmonEventCode = 161;
pub const SCE_PERF_ARM_PMON_PLE_FIFO_FLUSH: _ScePerfArmPmonEventCode = 162;
pub const SCE_PERF_ARM_PMON_PLE_FIFO_OVERFLOW: _ScePerfArmPmonEventCode = 164;
pub const SCE_PERF_ARM_PMON_PLE_LINE_REQ_COMPLETED: _ScePerfArmPmonEventCode = 160;
pub const SCE_PERF_ARM_PMON_PLE_REQ_COMPLETED: _ScePerfArmPmonEventCode = 163;
pub const SCE_PERF_ARM_PMON_PLE_REQ_PROGRAMMED: _ScePerfArmPmonEventCode = 165;
pub const SCE_PERF_ARM_PMON_PREDICT_BRANCH: _ScePerfArmPmonEventCode = 18;
pub const SCE_PERF_ARM_PMON_PREDICT_FUNC_RET: _ScePerfArmPmonEventCode = 110;
pub const SCE_PERF_ARM_PMON_SECOND_PIPE: _ScePerfArmPmonEventCode = 113;
pub const SCE_PERF_ARM_PMON_SOFT_CHANGEPC: _ScePerfArmPmonEventCode = 12;
pub const SCE_PERF_ARM_PMON_SOFT_INCREMENT: _ScePerfArmPmonEventCode = 0;
pub const SCE_PERF_ARM_PMON_STREX_FAILED: _ScePerfArmPmonEventCode = 100;
pub const SCE_PERF_ARM_PMON_STREX_PASSED: _ScePerfArmPmonEventCode = 99;
pub const SCE_PERF_ARM_PMON_THREAD_ID_SELF: u32 = 0;
pub const SCE_PERF_ARM_PMON_UNALIGNED: _ScePerfArmPmonEventCode = 15;
pub const SCE_PERF_ARM_PMON_WRITE_CONTEXTID: _ScePerfArmPmonEventCode = 11;
pub const SCE_PERF_ARM_PMON_WRITE_STALL: _ScePerfArmPmonEventCode = 129;
#[doc = "PlayStation Mobile"]
pub const SCE_PKG_TYPE_PSM: ScePromoterUtilityPackageType = 3;
#[doc = "PSP Games"]
pub const SCE_PKG_TYPE_PSP: ScePromoterUtilityPackageType = 1;
#[doc = "PSVita Apps"]
pub const SCE_PKG_TYPE_VITA: ScePromoterUtilityPackageType = 1;
pub const SCE_POWER_CB_AFTER_SYSTEM_RESUME: ScePowerCallbackType = 128;
pub const SCE_POWER_CB_APP_RESUME: ScePowerCallbackType = 2097152;
pub const SCE_POWER_CB_APP_RESUMING: ScePowerCallbackType = 8388608;
pub const SCE_POWER_CB_APP_SUSPEND: ScePowerCallbackType = 4194304;
pub const SCE_POWER_CB_BATTERY_ONLINE: ScePowerCallbackType = 256;
pub const SCE_POWER_CB_BUTTON_POWER_HOLD: ScePowerCallbackType = 1073741824;
pub const SCE_POWER_CB_BUTTON_POWER_PRESS: ScePowerCallbackType = 2147483648;
pub const SCE_POWER_CB_BUTTON_PS_HOLD: ScePowerCallbackType = 268435456;
pub const SCE_POWER_CB_BUTTON_PS_POWER_PRESS: ScePowerCallbackType = 134217728;
pub const SCE_POWER_CB_BUTTON_PS_PRESS: ScePowerCallbackType = 536870912;
pub const SCE_POWER_CB_BUTTON_PS_START_PRESS: ScePowerCallbackType = 67108864;
pub const SCE_POWER_CB_LOW_BATTERY: ScePowerCallbackType = 2048;
pub const SCE_POWER_CB_LOW_BATTERY_SUSPEND: ScePowerCallbackType = 1024;
pub const SCE_POWER_CB_POWER_ONLINE: ScePowerCallbackType = 4096;
pub const SCE_POWER_CB_SYSTEM_RESUME: ScePowerCallbackType = 262144;
pub const SCE_POWER_CB_SYSTEM_RESUMING: ScePowerCallbackType = 131072;
pub const SCE_POWER_CB_SYSTEM_SUSPEND: ScePowerCallbackType = 65536;
pub const SCE_POWER_CB_THERMAL_SUSPEND: ScePowerCallbackType = 512;
pub const SCE_POWER_CB_UNK_0x100000: ScePowerCallbackType = 1048576;
pub const SCE_POWER_CB_VALID_MASK_KERNEL: ScePowerCallbackType = 4244053888;
pub const SCE_POWER_CB_VALID_MASK_NON_SYSTEM: ScePowerCallbackType = 3543424;
pub const SCE_POWER_CB_VALID_MASK_SYSTEM: ScePowerCallbackType = 4244053888;
pub const __SCE_POWER_CONFIGURATION_MODE: ScePowerConfigurationMode = 4294967295;
pub const SCE_POWER_CONFIGURATION_MODE_A: ScePowerConfigurationMode = 128;
pub const SCE_POWER_CONFIGURATION_MODE_B: ScePowerConfigurationMode = 2048;
pub const SCE_POWER_CONFIGURATION_MODE_C: ScePowerConfigurationMode = 67712;
pub const SCE_POWER_ERROR_ALREADY_REGISTERED: ScePowerErrorCode = 2150301697;
pub const SCE_POWER_ERROR_CALLBACK_NOT_REGISTERED: ScePowerErrorCode = 2150301698;
pub const SCE_POWER_ERROR_CANT_SUSPEND: ScePowerErrorCode = 2150301699;
pub const SCE_POWER_ERROR_DETECTING: ScePowerErrorCode = 2150301953;
pub const SCE_POWER_ERROR_INVALID_VALUE: ScePowerErrorCode = 2150301696;
pub const SCE_POWER_ERROR_NO_BATTERY: ScePowerErrorCode = 2150301952;
pub const SCE_PRODUCT_CODE_CEX_AU3: SceProductCode = 265;
pub const SCE_PRODUCT_CODE_CEX_CEK: SceProductCode = 263;
pub const SCE_PRODUCT_CODE_CEX_CEL: SceProductCode = 261;
pub const SCE_PRODUCT_CODE_CEX_CN9: SceProductCode = 269;
pub const SCE_PRODUCT_CODE_CEX_E12: SceProductCode = 266;
pub const SCE_PRODUCT_CODE_CEX_HK5: SceProductCode = 270;
pub const SCE_PRODUCT_CODE_CEX_J1: SceProductCode = 259;
pub const SCE_PRODUCT_CODE_CEX_KR2: SceProductCode = 262;
pub const SCE_PRODUCT_CODE_CEX_MX2: SceProductCode = 264;
pub const SCE_PRODUCT_CODE_CEX_RSV1: SceProductCode = 271;
pub const SCE_PRODUCT_CODE_CEX_RSV2: SceProductCode = 272;
pub const SCE_PRODUCT_CODE_CEX_RSV3: SceProductCode = 273;
pub const SCE_PRODUCT_CODE_CEX_RU3: SceProductCode = 268;
pub const SCE_PRODUCT_CODE_CEX_TW1: SceProductCode = 267;
pub const SCE_PRODUCT_CODE_CEX_UC2: SceProductCode = 260;
pub const SCE_PRODUCT_CODE_DEX: SceProductCode = 258;
pub const SCE_PRODUCT_CODE_NONE: SceProductCode = 0;
pub const SCE_PRODUCT_CODE_TEST: SceProductCode = 256;
pub const SCE_PRODUCT_CODE_TOOL: SceProductCode = 257;
pub const SCE_PVF_COUNTRY_JAPAN: ScePvfFontVendorCountryCode = 1;
pub const SCE_PVF_COUNTRY_KOREA: ScePvfFontVendorCountryCode = 3;
pub const SCE_PVF_COUNTRY_USA: ScePvfFontVendorCountryCode = 2;
pub const SCE_PVF_DEFAULT_FAMILY_CODE: ScePvfFamilyCode = 0;
pub const SCE_PVF_DEFAULT_LANGUAGE_CODE: ScePvfLanguageCode = 0;
pub const SCE_PVF_DEFAULT_STYLE_CODE: ScePvfStyleCode = 0;
pub const SCE_PVF_ERROR_ARG: ScePvfErrorCode = 2152071171;
pub const SCE_PVF_ERROR_DATAINCONSISTENT: ScePvfErrorCode = 2152071179;
pub const SCE_PVF_ERROR_EXPIRED: ScePvfErrorCode = 2152071180;
pub const SCE_PVF_ERROR_FILECLOSE: ScePvfErrorCode = 2152071174;
pub const SCE_PVF_ERROR_FILEOPEN: ScePvfErrorCode = 2152071173;
pub const SCE_PVF_ERROR_FILEREAD: ScePvfErrorCode = 2152071175;
pub const SCE_PVF_ERROR_FILESEEK: ScePvfErrorCode = 2152071176;
pub const SCE_PVF_ERROR_ILLEGALVERSION: ScePvfErrorCode = 2152071178;
pub const SCE_PVF_ERROR_LIBID: ScePvfErrorCode = 2152071170;
pub const SCE_PVF_ERROR_NOFILE: ScePvfErrorCode = 2152071172;
pub const SCE_PVF_ERROR_NOGLYPH: ScePvfErrorCode = 2152071183;
pub const SCE_PVF_ERROR_NOMEMORY: ScePvfErrorCode = 2152071169;
pub const SCE_PVF_ERROR_NOSUPPORT: ScePvfErrorCode = 2152071182;
pub const SCE_PVF_ERROR_TOOMANYOPENED: ScePvfErrorCode = 2152071177;
pub const SCE_PVF_ERROR_UNKNOWN: ScePvfErrorCode = 2152136703;
pub const SCE_PVF_FALSE: ScePvfBoolValue = 0;
pub const SCE_PVF_FAMILY_ROUNDED: ScePvfFamilyCode = 3;
pub const SCE_PVF_FAMILY_SANSERIF: ScePvfFamilyCode = 1;
pub const SCE_PVF_FAMILY_SERIF: ScePvfFamilyCode = 2;
pub const SCE_PVF_FILEBASEDSTREAM: ScePvfDataAccessMode = 0;
pub const SCE_PVF_FONTFILENAME_LENGTH: u32 = 64;
pub const SCE_PVF_FONTNAME_LENGTH: u32 = 64;
pub const SCE_PVF_GENERIC_COUNTRY_CODE: ScePvfFontVendorCountryCode = 0;
pub const SCE_PVF_GENERIC_REGION_CODE: ScePvfRegionCode = 0;
pub const SCE_PVF_LANGUAGE_C: ScePvfLanguageCode = 4;
pub const SCE_PVF_LANGUAGE_CJK: ScePvfLanguageCode = 5;
pub const SCE_PVF_LANGUAGE_J: ScePvfLanguageCode = 1;
pub const SCE_PVF_LANGUAGE_K: ScePvfLanguageCode = 3;
pub const SCE_PVF_LANGUAGE_LATIN: ScePvfLanguageCode = 2;
pub const SCE_PVF_MAX_EMBOLDEN_RATE: f64 = 40.0;
pub const SCE_PVF_MAX_OPEN: u32 = 18;
pub const SCE_PVF_MAX_SKEW_VALUE: f64 = 30.0;
pub const SCE_PVF_MEMORYBASEDSTREAM: ScePvfDataAccessMode = 1;
pub const SCE_PVF_MIN_EMBOLDEN_RATE: f64 = -20.0;
pub const SCE_PVF_MIN_SKEW_VALUE: f64 = -30.0;
pub const SCE_PVF_REGION_001: ScePvfRegionCode = 1;
pub const SCE_PVF_REGION_002: ScePvfRegionCode = 2;
pub const SCE_PVF_REGION_003: ScePvfRegionCode = 3;
pub const SCE_PVF_REGION_004: ScePvfRegionCode = 4;
pub const SCE_PVF_REGION_005: ScePvfRegionCode = 5;
pub const SCE_PVF_REGION_006: ScePvfRegionCode = 6;
pub const SCE_PVF_REGION_007: ScePvfRegionCode = 7;
pub const SCE_PVF_STYLE_B: ScePvfStyleCode = 104;
pub const SCE_PVF_STYLE_BLACK: ScePvfStyleCode = 7;
pub const SCE_PVF_STYLE_BLACK_OBLIQUE: ScePvfStyleCode = 8;
pub const SCE_PVF_STYLE_BOLD: ScePvfStyleCode = 5;
pub const SCE_PVF_STYLE_BOLD_OBLIQUE: ScePvfStyleCode = 6;
pub const SCE_PVF_STYLE_DB: ScePvfStyleCode = 103;
pub const SCE_PVF_STYLE_EB: ScePvfStyleCode = 105;
pub const SCE_PVF_STYLE_L: ScePvfStyleCode = 101;
pub const SCE_PVF_STYLE_M: ScePvfStyleCode = 102;
pub const SCE_PVF_STYLENAME_LENGTH: u32 = 64;
pub const SCE_PVF_STYLE_NARROW: ScePvfStyleCode = 3;
pub const SCE_PVF_STYLE_NARROW_OBLIQUE: ScePvfStyleCode = 4;
pub const SCE_PVF_STYLE_OBLIQUE: ScePvfStyleCode = 2;
pub const SCE_PVF_STYLE_REGULAR: ScePvfStyleCode = 1;
pub const SCE_PVF_STYLE_UB: ScePvfStyleCode = 106;
pub const SCE_PVF_SUBSTYLE_PSEUDO_BOLD: ScePvfSubstyle = 2;
pub const SCE_PVF_SUBSTYLE_PSEUDO_SLANT: ScePvfSubstyle = 4;
pub const SCE_PVF_SUBSTYLE_VERTICALLAYOUT: ScePvfSubstyle = 1;
pub const SCE_PVF_TRUE: ScePvfBoolValue = 1;
pub const SCE_PVF_USERIMAGE_DIRECT4_L: ScePvfImageByfferPixelFormatType = 0;
pub const SCE_PVF_USERIMAGE_DIRECT8: ScePvfImageByfferPixelFormatType = 2;
pub const SCE_RAZOR_GPU_LIVE_METRICS_GROUP_OVERVIEW_1: SceRazorGpuLiveMetricsGroup = 1;
pub const SCE_RAZOR_GPU_LIVE_METRICS_GROUP_OVERVIEW_2: SceRazorGpuLiveMetricsGroup = 2;
pub const SCE_RAZOR_GPU_LIVE_METRICS_GROUP_OVERVIEW_3: SceRazorGpuLiveMetricsGroup = 3;
pub const SCE_RAZOR_GPU_LIVE_METRICS_GROUP_PBUFFER_USAGE: SceRazorGpuLiveMetricsGroup = 0;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_ENTRY_TYPE_FRAME: SceRazorLiveTraceMetricEntryType = 2;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_ENTRY_TYPE_JOB: SceRazorLiveTraceMetricEntryType = 0;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_ENTRY_TYPE_PARAMETER_BUFFER:
    SceRazorLiveTraceMetricEntryType = 1;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FIRMWARE: SceRazorLiveTraceMetricJobType = 0;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT0: SceRazorLiveTraceMetricJobType = 8;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT1: SceRazorLiveTraceMetricJobType = 2;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT2: SceRazorLiveTraceMetricJobType = 4;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_FRAGMENT3: SceRazorLiveTraceMetricJobType = 6;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX0: SceRazorLiveTraceMetricJobType = 7;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX1: SceRazorLiveTraceMetricJobType = 1;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX2: SceRazorLiveTraceMetricJobType = 3;
pub const SCE_RAZOR_LIVE_TRACE_METRIC_JOB_TYPE_VERTEX3: SceRazorLiveTraceMetricJobType = 5;
pub const __SCE_RTC_DAYOFWEEK: SceRtcDayOfWeek = 4294967295;
pub const SCE_RTC_DAYOFWEEK_FRIDAY: SceRtcDayOfWeek = 5;
pub const SCE_RTC_DAYOFWEEK_MONDAY: SceRtcDayOfWeek = 1;
pub const SCE_RTC_DAYOFWEEK_SATURDAY: SceRtcDayOfWeek = 6;
pub const SCE_RTC_DAYOFWEEK_SUNDAY: SceRtcDayOfWeek = 0;
pub const SCE_RTC_DAYOFWEEK_THURSDAY: SceRtcDayOfWeek = 4;
pub const SCE_RTC_DAYOFWEEK_TUESDAY: SceRtcDayOfWeek = 2;
pub const SCE_RTC_DAYOFWEEK_WEDNESDAY: SceRtcDayOfWeek = 3;
pub const SCE_RTC_ERROR_ALREADY_REGISTERD: SceRtcErrorCode = 2149912579;
pub const SCE_RTC_ERROR_BAD_PARSE: SceRtcErrorCode = 2149912704;
pub const SCE_RTC_ERROR_INVALID_DAY: SceRtcErrorCode = 2149912707;
pub const SCE_RTC_ERROR_INVALID_HOUR: SceRtcErrorCode = 2149912708;
pub const SCE_RTC_ERROR_INVALID_MICROSECOND: SceRtcErrorCode = 2149912711;
pub const SCE_RTC_ERROR_INVALID_MINUTE: SceRtcErrorCode = 2149912709;
pub const SCE_RTC_ERROR_INVALID_MONTH: SceRtcErrorCode = 2149912706;
pub const SCE_RTC_ERROR_INVALID_POINTER: SceRtcErrorCode = 2149912577;
pub const SCE_RTC_ERROR_INVALID_SECOND: SceRtcErrorCode = 2149912710;
pub const SCE_RTC_ERROR_INVALID_VALUE: SceRtcErrorCode = 2149912576;
pub const SCE_RTC_ERROR_INVALID_YEAR: SceRtcErrorCode = 2149912705;
pub const SCE_RTC_ERROR_NOT_FOUND: SceRtcErrorCode = 2149912580;
pub const SCE_RTC_ERROR_NOT_INITIALIZED: SceRtcErrorCode = 2149912578;
pub const SCE_SCREENSHOT_ERROR_FILE_NOT_FOUND: SceScreenshotErrorCode = 2148544259;
pub const SCE_SCREENSHOT_ERROR_INTERNAL: SceScreenshotErrorCode = 2148544262;
pub const SCE_SCREENSHOT_ERROR_INVALID_ARGUMENT: SceScreenshotErrorCode = 2148544257;
pub const SCE_SCREENSHOT_ERROR_MEDIA_FULL: SceScreenshotErrorCode = 2148544261;
pub const SCE_SCREENSHOT_ERROR_NO_MEMORY: SceScreenshotErrorCode = 2148544258;
pub const SCE_SCREENSHOT_ERROR_NOT_SUPPORTED_FORMAT: SceScreenshotErrorCode = 2148544260;
pub const SCE_SCREENSHOT_MAX_FS_PATH: u32 = 1024;
pub const SCE_SCREENSHOT_MAX_GAME_COMMENT_LEN: u32 = 128;
pub const SCE_SCREENSHOT_MAX_GAME_COMMENT_SIZE: u32 = 512;
pub const SCE_SCREENSHOT_MAX_GAME_TITLE_LEN: u32 = 64;
pub const SCE_SCREENSHOT_MAX_GAME_TITLE_SIZE: u32 = 256;
pub const SCE_SCREENSHOT_MAX_PHOTO_TITLE_LEN: u32 = 64;
pub const SCE_SCREENSHOT_MAX_PHOTO_TITLE_SIZE: u32 = 256;
#[doc = "Starts from current position"]
pub const SCE_SEEK_CUR: SceIoSeekMode = 1;
#[doc = "Starts from the end of the file"]
pub const SCE_SEEK_END: SceIoSeekMode = 2;
#[doc = "Starts from the begin of the file"]
pub const SCE_SEEK_SET: SceIoSeekMode = 0;
pub const SCE_SHA1_BLOCK_SIZE: u32 = 64;
pub const SCE_SHA1_DIGEST_SIZE: u32 = 20;
pub const SCE_SHA224_BLOCK_SIZE: u32 = 64;
pub const SCE_SHA224_DIGEST_SIZE: u32 = 28;
pub const SCE_SHA256_BLOCK_SIZE: u32 = 64;
pub const SCE_SHA256_DIGEST_SIZE: u32 = 32;
pub const SCE_SHACCCG_DIAGNOSTIC_LEVEL_ERROR: SceShaccCgDiagnosticLevel = 2;
pub const SCE_SHACCCG_DIAGNOSTIC_LEVEL_INFO: SceShaccCgDiagnosticLevel = 0;
pub const SCE_SHACCCG_DIAGNOSTIC_LEVEL_WARNING: SceShaccCgDiagnosticLevel = 1;
pub const SCE_SHACCCG_ENGLISH: SceShaccCgLocale = 0;
pub const SCE_SHACCCG_JAPANESE: SceShaccCgLocale = 1;
pub const SCE_SHACCCG_PROFILE_FP: SceShaccCgTargetProfile = 1;
pub const SCE_SHACCCG_PROFILE_VP: SceShaccCgTargetProfile = 0;
pub const SCE_SHACCCG_SYSTEM_FILES: SceShaccCgCallbackDefaults = 0;
pub const SCE_SHACCCG_TRIVIAL: SceShaccCgCallbackDefaults = 1;
pub const SCE_SHELL_UTIL_LOCK_MODE_LOCK: SceShellUtilLockMode = 1;
pub const SCE_SHELL_UTIL_LOCK_MODE_UNLOCK: SceShellUtilLockMode = 2;
pub const SCE_SHELL_UTIL_LOCK_TYPE_MC_INSERTED: SceShellUtilLockType = 32;
pub const SCE_SHELL_UTIL_LOCK_TYPE_MC_REMOVED: SceShellUtilLockType = 64;
pub const SCE_SHELL_UTIL_LOCK_TYPE_MUSIC_PLAYER: SceShellUtilLockType = 1024;
pub const SCE_SHELL_UTIL_LOCK_TYPE_POWEROFF_MENU: SceShellUtilLockType = 4;
pub const SCE_SHELL_UTIL_LOCK_TYPE_PS_BTN: SceShellUtilLockType = 1;
pub const SCE_SHELL_UTIL_LOCK_TYPE_PS_BTN_2: SceShellUtilLockType = 2048;
pub const SCE_SHELL_UTIL_LOCK_TYPE_QUICK_MENU: SceShellUtilLockType = 2;
pub const SCE_SHELL_UTIL_LOCK_TYPE_UNK100: SceShellUtilLockType = 256;
pub const SCE_SHELL_UTIL_LOCK_TYPE_UNK200: SceShellUtilLockType = 512;
pub const SCE_SHELL_UTIL_LOCK_TYPE_UNK8: SceShellUtilLockType = 8;
pub const SCE_SHELL_UTIL_LOCK_TYPE_UNK80: SceShellUtilLockType = 128;
pub const SCE_SHELL_UTIL_LOCK_TYPE_USB_CONNECTION: SceShellUtilLockType = 16;
#[doc = "Fatal error"]
pub const SCE_SHUTTER_SOUND_ERROR_FATAL: SceShutterSoundErrorCode = 2148553219;
#[doc = "Internal error"]
pub const SCE_SHUTTER_SOUND_ERROR_INTERNAL: SceShutterSoundErrorCode = 2148553218;
#[doc = "Invalid argument"]
pub const SCE_SHUTTER_SOUND_ERROR_INVALID_ARGUMENT: SceShutterSoundErrorCode = 2148553217;
pub const SCE_SHUTTER_SOUND_TYPE_SAVE_IMAGE: SceShutterSoundType = 0;
pub const SCE_SHUTTER_SOUND_TYPE_SAVE_VIDEO_END: SceShutterSoundType = 2;
pub const SCE_SHUTTER_SOUND_TYPE_SAVE_VIDEO_START: SceShutterSoundType = 1;
#[doc = "Directory"]
pub const SCE_S_IFDIR: SceIoAccessMode = 4096;
#[doc = "Symbolic link"]
pub const SCE_S_IFLNK: SceIoAccessMode = 16384;
#[doc = "Format bits mask"]
pub const SCE_S_IFMT: SceIoAccessMode = 61440;
#[doc = "Regular file"]
pub const SCE_S_IFREG: SceIoAccessMode = 8192;
#[doc = "Group read permission. Ignored and reset to 0 by system"]
pub const SCE_S_IRGRP: SceIoAccessMode = 0;
#[doc = "Others read permission. Deprecated, use ::SCE_S_IXSYS"]
pub const SCE_S_IROTH: SceIoAccessMode = 4;
#[doc = "System read permission"]
pub const SCE_S_IRSYS: SceIoAccessMode = 4;
#[doc = "User read permission"]
pub const SCE_S_IRUSR: SceIoAccessMode = 256;
#[doc = "Group access rights mask. Ignored and reset to 0 by system"]
pub const SCE_S_IRWXG: SceIoAccessMode = 0;
#[doc = "Others access rights mask. Deprecated, use ::SCE_S_IRWXS"]
pub const SCE_S_IRWXO: SceIoAccessMode = 7;
#[doc = "System access rights mask"]
pub const SCE_S_IRWXS: SceIoAccessMode = 7;
#[doc = "User access rights mask"]
pub const SCE_S_IRWXU: SceIoAccessMode = 448;
#[doc = "Set GID. Deprecated"]
pub const SCE_S_ISGID: SceIoAccessMode = 0;
#[doc = "Set UID. Deprecated"]
pub const SCE_S_ISUID: SceIoAccessMode = 0;
#[doc = "Sticky. Deprecated"]
pub const SCE_S_ISVTX: SceIoAccessMode = 0;
#[doc = "Group write permission. Ignored and reset to 0 by system"]
pub const SCE_S_IWGRP: SceIoAccessMode = 0;
#[doc = "Others write permission. Deprecated, use ::SCE_S_IXSYS"]
pub const SCE_S_IWOTH: SceIoAccessMode = 2;
#[doc = "System write permission"]
pub const SCE_S_IWSYS: SceIoAccessMode = 2;
#[doc = "User write permission"]
pub const SCE_S_IWUSR: SceIoAccessMode = 128;
#[doc = "Group execute permission. Ignored and reset to 0 by system"]
pub const SCE_S_IXGRP: SceIoAccessMode = 0;
#[doc = "Others execute permission. Deprecated, use ::SCE_S_IXSYS"]
pub const SCE_S_IXOTH: SceIoAccessMode = 1;
#[doc = "System execute permission"]
pub const SCE_S_IXSYS: SceIoAccessMode = 1;
#[doc = "User execute permission"]
pub const SCE_S_IXUSR: SceIoAccessMode = 64;
#[doc = "Directory"]
pub const SCE_SO_IFDIR: SceIoFileMode = 16;
#[doc = "Symbolic link"]
pub const SCE_SO_IFLNK: SceIoFileMode = 8;
#[doc = "Format mask"]
pub const SCE_SO_IFMT: SceIoFileMode = 56;
#[doc = "Regular file"]
pub const SCE_SO_IFREG: SceIoFileMode = 32;
#[doc = "Hidden read permission"]
pub const SCE_SO_IROTH: SceIoFileMode = 4;
#[doc = "Hidden write permission"]
pub const SCE_SO_IWOTH: SceIoFileMode = 2;
#[doc = "Hidden execute permission"]
pub const SCE_SO_IXOTH: SceIoFileMode = 1;
pub const SCE_SSL_ERROR_ALREADY_INITED: SceSslErrorCode = 2151895072;
pub const SCE_SSL_ERROR_BEFORE_INIT: SceSslErrorCode = 2151895041;
pub const SCE_SSL_ERROR_INTERNAL: SceSslErrorCode = 2151895078;
pub const SCE_SSL_ERROR_INVALID_FORMAT: SceSslErrorCode = 2151895304;
pub const SCE_SSL_ERROR_INVALID_VALUE: SceSslErrorCode = 2151895550;
pub const SCE_SSL_ERROR_NOT_FOUND: SceSslErrorCode = 2151895077;
pub const SCE_SSL_ERROR_OUT_OF_MEMORY: SceSslErrorCode = 2151895074;
pub const SCE_SYSCON_CMD_RESET_DEVICE: SceSysconCmd = 12;
pub const SCE_SYSCON_CTRL_CIRCLE: SceSysconControl = 32;
pub const SCE_SYSCON_CTRL_CROSS: SceSysconControl = 64;
pub const SCE_SYSCON_CTRL_DOWN: SceSysconControl = 4;
pub const SCE_SYSCON_CTRL_HEADPHONE: SceSysconControl = 134217728;
pub const SCE_SYSCON_CTRL_LEFT: SceSysconControl = 8;
pub const SCE_SYSCON_CTRL_LTRIGGER: SceSysconControl = 512;
pub const SCE_SYSCON_CTRL_POWER: SceSysconControl = 16384;
pub const SCE_SYSCON_CTRL_PSBUTTON: SceSysconControl = 4096;
pub const SCE_SYSCON_CTRL_RIGHT: SceSysconControl = 2;
pub const SCE_SYSCON_CTRL_RTRIGGER: SceSysconControl = 1024;
pub const SCE_SYSCON_CTRL_SELECT: SceSysconControl = 256;
pub const SCE_SYSCON_CTRL_SQUARE: SceSysconControl = 128;
pub const SCE_SYSCON_CTRL_START: SceSysconControl = 2048;
pub const SCE_SYSCON_CTRL_TRIANGLE: SceSysconControl = 16;
pub const SCE_SYSCON_CTRL_UP: SceSysconControl = 1;
pub const SCE_SYSCON_CTRL_VOLDOWN: SceSysconControl = 131072;
pub const SCE_SYSCON_CTRL_VOLUP: SceSysconControl = 65536;
pub const SCE_SYSCON_PACKET_RX_LENGTH: u32 = 2;
pub const SCE_SYSCON_PACKET_RX_RESULT: u32 = 3;
pub const SCE_SYSCON_PACKET_RX_STATUS_HI: u32 = 1;
pub const SCE_SYSCON_PACKET_RX_STATUS_LO: u32 = 0;
pub const SCE_SYSCON_PACKET_TX_CMD_HI: u32 = 1;
pub const SCE_SYSCON_PACKET_TX_CMD_LO: u32 = 0;
pub const SCE_SYSCON_PACKET_TX_LENGTH: u32 = 2;
pub const SCE_SYSCON_RESET_TYPE_COLD_RESET: SceSysconResetType = 2;
pub const SCE_SYSCON_RESET_TYPE_POWEROFF: SceSysconResetType = 0;
pub const SCE_SYSCON_RESET_TYPE_SOFT_RESET: SceSysconResetType = 17;
pub const SCE_SYSCON_RESET_TYPE_SUSPEND: SceSysconResetType = 1;
#[doc = "AacEnc module"]
pub const SCE_SYSMODULE_AACENC: SceSysmoduleModuleId = 46;
#[doc = "AppUtil module"]
pub const SCE_SYSMODULE_APPUTIL: SceSysmoduleModuleId = 15;
#[doc = "AppUtilExt module"]
pub const SCE_SYSMODULE_APPUTIL_EXT: SceSysmoduleModuleId = 82;
#[doc = "Atrac module"]
pub const SCE_SYSMODULE_ATRAC: SceSysmoduleModuleId = 48;
#[doc = "AudioCodec module"]
pub const SCE_SYSMODULE_AUDIOCODEC: SceSysmoduleModuleId = 55;
#[doc = "AVCDec module"]
pub const SCE_SYSMODULE_AVCDEC: SceSysmoduleModuleId = 84;
#[doc = "AVPlayer module"]
pub const SCE_SYSMODULE_AVPLAYER: SceSysmoduleModuleId = 76;
#[doc = "BEISOBMF module"]
pub const SCE_SYSMODULE_BEISOBMF: SceSysmoduleModuleId = 71;
#[doc = "BEMP2SYS module"]
pub const SCE_SYSMODULE_BEMP2SYS: SceSysmoduleModuleId = 72;
#[doc = "BgAppUtil module"]
pub const SCE_SYSMODULE_BG_APP_UTIL: SceSysmoduleModuleId = 52;
#[doc = "Clipboard module"]
pub const SCE_SYSMODULE_CLIPBOARD: SceSysmoduleModuleId = 40;
#[doc = "CodecEngine Perf module"]
pub const SCE_SYSMODULE_CODECENGINE_PERF: SceSysmoduleModuleId = 34;
#[doc = "DBG module"]
pub const SCE_SYSMODULE_DBG: SceSysmoduleModuleId = 8;
#[doc = "DTCP/IP module"]
pub const SCE_SYSMODULE_DTCP_IP: SceSysmoduleModuleId = 68;
#[doc = "Fatal error"]
pub const SCE_SYSMODULE_ERROR_FATAL: SceSysmoduleErrorCode = 2153386239;
#[doc = "Invalid value"]
pub const SCE_SYSMODULE_ERROR_INVALID_VALUE: SceSysmoduleErrorCode = 2153385984;
#[doc = "Module is not loaded"]
pub const SCE_SYSMODULE_ERROR_UNLOADED: SceSysmoduleErrorCode = 2153385985;
#[doc = "Face module"]
pub const SCE_SYSMODULE_FACE: SceSysmoduleModuleId = 56;
#[doc = "Fiber module"]
pub const SCE_SYSMODULE_FIBER: SceSysmoduleModuleId = 6;
#[doc = "Fios2 module"]
pub const SCE_SYSMODULE_FIOS2: SceSysmoduleModuleId = 16;
#[doc = "Game Update module"]
pub const SCE_SYSMODULE_GAME_UPDATE: SceSysmoduleModuleId = 77;
#[doc = "Handwriting module"]
pub const SCE_SYSMODULE_HANDWRITING: SceSysmoduleModuleId = 47;
#[doc = "HTTP module"]
pub const SCE_SYSMODULE_HTTP: SceSysmoduleModuleId = 2;
#[doc = "HTTPS module"]
pub const SCE_SYSMODULE_HTTPS: SceSysmoduleModuleId = 4;
#[doc = "Ime module"]
pub const SCE_SYSMODULE_IME: SceSysmoduleModuleId = 17;
#[doc = "Incoming Dialog module"]
pub const SCE_SYSMODULE_INCOMING_DIALOG: SceSysmoduleModuleId = 53;
#[doc = "ActivityDB module"]
pub const SCE_SYSMODULE_INTERNAL_ACTIVITY_DB: SceSysmoduleInternalModuleId = 2147483659;
#[doc = "AudioCodec module"]
pub const SCE_SYSMODULE_INTERNAL_AUDIOCODEC: SceSysmoduleInternalModuleId = 2147483650;
#[doc = "BXCE module"]
pub const SCE_SYSMODULE_INTERNAL_BXCE: SceSysmoduleInternalModuleId = 2147483653;
#[doc = "Checkout Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_CHECKOUT_DIALOG: SceSysmoduleInternalModuleId = 2147483665;
#[doc = "Common Dialog Main module"]
pub const SCE_SYSMODULE_INTERNAL_COMMON_DIALOG_MAIN: SceSysmoduleInternalModuleId = 2147483666;
#[doc = "Common Gui Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_COMMON_GUI_DIALOG: SceSysmoduleInternalModuleId = 2147483660;
#[doc = "DBRecoveryUtil module"]
pub const SCE_SYSMODULE_INTERNAL_DB_RECOVERY_UTILITY: SceSysmoduleInternalModuleId = 2147483683;
#[doc = "DBUtil module"]
pub const SCE_SYSMODULE_INTERNAL_DBUTIL: SceSysmoduleInternalModuleId = 2147483658;
#[doc = "DRM PSM KDC module"]
pub const SCE_SYSMODULE_INTERNAL_DRM_PSM_KDC: SceSysmoduleInternalModuleId = 2147483687;
#[doc = "FriendList Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_FRIEND_LIST_DIALOG: SceSysmoduleInternalModuleId = 2147483672;
#[doc = "G729 module"]
pub const SCE_SYSMODULE_INTERNAL_G729: SceSysmoduleInternalModuleId = 2147483652;
#[doc = "Ime Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_IME_DIALOG: SceSysmoduleInternalModuleId = 2147483662;
#[doc = "INI File Processor module"]
pub const SCE_SYSMODULE_INTERNAL_INI_FILE_PROCESSOR: SceSysmoduleInternalModuleId = 2147483654;
#[doc = "sceJpegArm module"]
pub const SCE_SYSMODULE_INTERNAL_JPEG_ARM: SceSysmoduleInternalModuleId = 2147483651;
#[doc = "sceJpegEncArm module"]
pub const SCE_SYSMODULE_INTERNAL_JPEG_ENC_ARM: SceSysmoduleInternalModuleId = 2147483649;
#[doc = "Location Factory module"]
pub const SCE_SYSMODULE_INTERNAL_LOCATION_FACTORY: SceSysmoduleInternalModuleId = 2147483689;
#[doc = "sceLocation module"]
pub const SCE_SYSMODULE_INTERNAL_LOCATION_INTERNAL: SceSysmoduleInternalModuleId = 2147483688;
#[doc = "sceMsgDialog module"]
pub const SCE_SYSMODULE_INTERNAL_MSG_DIALOG: SceSysmoduleInternalModuleId = 2147483667;
#[doc = "Music Export module"]
pub const SCE_SYSMODULE_INTERNAL_MUSIC_EXPORT: SceSysmoduleInternalModuleId = 2147483679;
#[doc = "Near Profile module"]
pub const SCE_SYSMODULE_INTERNAL_NEAR_PROFILE: SceSysmoduleInternalModuleId = 2147483674;
#[doc = "NetCheck Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_NET_CHECK_DIALOG: SceSysmoduleInternalModuleId = 2147483668;
#[doc = "NpActivityNet module"]
pub const SCE_SYSMODULE_INTERNAL_NP_ACTIVITY_NET: SceSysmoduleInternalModuleId = 2147483655;
#[doc = "NpCommerce2 module"]
pub const SCE_SYSMODULE_INTERNAL_NP_COMMERCE2: SceSysmoduleInternalModuleId = 2147483677;
#[doc = "NpFriend Privacy Level module"]
pub const SCE_SYSMODULE_INTERNAL_NP_FRIEND_PRIVACY_LEVEL: SceSysmoduleInternalModuleId = 2147483675;
#[doc = "NpKdc module"]
pub const SCE_SYSMODULE_INTERNAL_NP_KDC: SceSysmoduleInternalModuleId = 2147483678;
#[doc = "NpMessageContacts module"]
pub const SCE_SYSMODULE_INTERNAL_NP_MESSAGE_CONTACTS: SceSysmoduleInternalModuleId = 2147483682;
#[doc = "NpMessage Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_NP_MESSAGE_DIALOG: SceSysmoduleInternalModuleId = 2147483670;
#[doc = "NpMessageDlg module"]
pub const SCE_SYSMODULE_INTERNAL_NP_MESSAGE_DIALOG_IMPL: SceSysmoduleInternalModuleId = 2147483681;
#[doc = "Paf module"]
pub const SCE_SYSMODULE_INTERNAL_PAF: SceSysmoduleInternalModuleId = 2147483656;
#[doc = "Party Member List module"]
pub const SCE_SYSMODULE_INTERNAL_PARTY_MEMBER_LIST: SceSysmoduleInternalModuleId = 2147483686;
#[doc = "Photo Import Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_PHOTO_IMPORT_DIALOG: SceSysmoduleInternalModuleId = 2147483663;
#[doc = "Photo Review Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_PHOTO_REVIEW_DIALOG: SceSysmoduleInternalModuleId = 2147483664;
#[doc = "scePromoterUtil module"]
pub const SCE_SYSMODULE_INTERNAL_PROMOTER_UTIL: SceSysmoduleInternalModuleId = 2147483684;
#[doc = "SaveData Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_SAVEDATA_DIALOG: SceSysmoduleInternalModuleId = 2147483669;
#[doc = "sceSqliteVsh module"]
pub const SCE_SYSMODULE_INTERNAL_SQLITE_VSH: SceSysmoduleInternalModuleId = 2147483657;
#[doc = "Store Checkout module"]
pub const SCE_SYSMODULE_INTERNAL_STORE_CHECKOUT: SceSysmoduleInternalModuleId = 2147483661;
#[doc = "Trophy Setup Dialog module"]
pub const SCE_SYSMODULE_INTERNAL_TROPHY_SETUP_DIALOG: SceSysmoduleInternalModuleId = 2147483671;
#[doc = "Ult module"]
pub const SCE_SYSMODULE_INTERNAL_ULT: SceSysmoduleInternalModuleId = 2147483685;
#[doc = "Video Export module"]
pub const SCE_SYSMODULE_INTERNAL_VIDEO_EXPORT: SceSysmoduleInternalModuleId = 2147483680;
#[doc = "Invalid module"]
pub const SCE_SYSMODULE_INVALID: SceSysmoduleModuleId = 0;
#[doc = "IPMI module"]
pub const SCE_SYSMODULE_IPMI: SceSysmoduleModuleId = 54;
#[doc = "JSON module"]
pub const SCE_SYSMODULE_JSON: SceSysmoduleModuleId = 85;
#[doc = "Livearea module"]
pub const SCE_SYSMODULE_LIVEAREA: SceSysmoduleModuleId = 35;
#[doc = "Module is already loaded"]
pub const SCE_SYSMODULE_LOADED: SceSysmoduleErrorCode = 0;
#[doc = "Location module"]
pub const SCE_SYSMODULE_LOCATION: SceSysmoduleModuleId = 20;
#[doc = "LocationExt module"]
pub const SCE_SYSMODULE_LOCATION_EXTENSION: SceSysmoduleModuleId = 75;
#[doc = "Mail Api module"]
pub const SCE_SYSMODULE_MAIL_API: SceSysmoduleModuleId = 78;
#[doc = "Marlin module"]
pub const SCE_SYSMODULE_MARLIN: SceSysmoduleModuleId = 58;
#[doc = "Marlin AppLib module"]
pub const SCE_SYSMODULE_MARLIN_APP_LIB: SceSysmoduleModuleId = 60;
#[doc = "Marlin Downloader module"]
pub const SCE_SYSMODULE_MARLIN_DOWNLOADER: SceSysmoduleModuleId = 59;
#[doc = "Mono module"]
pub const SCE_SYSMODULE_MONO: SceSysmoduleModuleId = 64;
#[doc = "Mono bridge module"]
pub const SCE_SYSMODULE_MONO_BRIDGE: SceSysmoduleModuleId = 63;
#[doc = "MP4 module"]
pub const SCE_SYSMODULE_MP4: SceSysmoduleModuleId = 45;
#[doc = "MP4 Recorder module"]
pub const SCE_SYSMODULE_MP4_RECORDER: SceSysmoduleModuleId = 81;
#[doc = "Music Export module"]
pub const SCE_SYSMODULE_MUSIC_EXPORT: SceSysmoduleModuleId = 73;
#[doc = "NearDialogUtil module"]
pub const SCE_SYSMODULE_NEAR_DIALOG_UTIL: SceSysmoduleModuleId = 74;
#[doc = "NearUtil module"]
pub const SCE_SYSMODULE_NEAR_UTIL: SceSysmoduleModuleId = 43;
#[doc = "Net module"]
pub const SCE_SYSMODULE_NET: SceSysmoduleModuleId = 1;
#[doc = "NetAdhoc Matching module"]
pub const SCE_SYSMODULE_NET_ADHOC_MATCHING: SceSysmoduleModuleId = 42;
#[doc = "NGS module"]
pub const SCE_SYSMODULE_NGS: SceSysmoduleModuleId = 11;
#[doc = "NotificationUtil module"]
pub const SCE_SYSMODULE_NOTIFICATION_UTIL: SceSysmoduleModuleId = 51;
#[doc = "Np module"]
pub const SCE_SYSMODULE_NP: SceSysmoduleModuleId = 21;
#[doc = "NpActivity module"]
pub const SCE_SYSMODULE_NP_ACTIVITY: SceSysmoduleModuleId = 36;
#[doc = "NpBasic module"]
pub const SCE_SYSMODULE_NP_BASIC: SceSysmoduleModuleId = 18;
#[doc = "NPCommerce2 module"]
pub const SCE_SYSMODULE_NP_COMMERCE2: SceSysmoduleModuleId = 24;
#[doc = "NpMatching2 module"]
pub const SCE_SYSMODULE_NP_MATCHING2: SceSysmoduleModuleId = 28;
#[doc = "NpMessage module"]
pub const SCE_SYSMODULE_NP_MESSAGE: SceSysmoduleModuleId = 38;
#[doc = "NpParty module"]
pub const SCE_SYSMODULE_NP_PARTY: SceSysmoduleModuleId = 41;
#[doc = "NpScoreRanking module"]
pub const SCE_SYSMODULE_NP_SCORE_RANKING: SceSysmoduleModuleId = 30;
#[doc = "NpSignaling module"]
pub const SCE_SYSMODULE_NP_SIGNALING: SceSysmoduleModuleId = 70;
#[doc = "NpSns Facebook module"]
pub const SCE_SYSMODULE_NP_SNS_FACEBOOK: SceSysmoduleModuleId = 49;
#[doc = "NpTrophy module"]
pub const SCE_SYSMODULE_NP_TROPHY: SceSysmoduleModuleId = 37;
#[doc = "NpTus module"]
pub const SCE_SYSMODULE_NP_TUS: SceSysmoduleModuleId = 44;
#[doc = "NpUtility module"]
pub const SCE_SYSMODULE_NP_UTILITY: SceSysmoduleModuleId = 25;
#[doc = "NpWebApi module"]
pub const SCE_SYSMODULE_NP_WEBAPI: SceSysmoduleModuleId = 83;
#[doc = "Perf module"]
pub const SCE_SYSMODULE_PERF: SceSysmoduleModuleId = 5;
#[doc = "Pgf module"]
pub const SCE_SYSMODULE_PGF: SceSysmoduleModuleId = 14;
#[doc = "Photo Export module"]
pub const SCE_SYSMODULE_PHOTO_EXPORT: SceSysmoduleModuleId = 22;
#[doc = "Psm module"]
pub const SCE_SYSMODULE_PSM: SceSysmoduleModuleId = 65;
#[doc = "Psm devagent module"]
pub const SCE_SYSMODULE_PSM_DEVAGENT: SceSysmoduleModuleId = 66;
#[doc = "PSPNet Adhoc module"]
pub const SCE_SYSMODULE_PSPNET_ADHOC: SceSysmoduleModuleId = 67;
#[doc = "Razor Capture module"]
pub const SCE_SYSMODULE_RAZOR_CAPTURE: SceSysmoduleModuleId = 9;
#[doc = "Razor HUD module"]
pub const SCE_SYSMODULE_RAZOR_HUD: SceSysmoduleModuleId = 10;
#[doc = "Rudp module"]
pub const SCE_SYSMODULE_RUDP: SceSysmoduleModuleId = 33;
#[doc = "Sas module"]
pub const SCE_SYSMODULE_SAS: SceSysmoduleModuleId = 13;
#[doc = "ScreenShot module"]
pub const SCE_SYSMODULE_SCREEN_SHOT: SceSysmoduleModuleId = 29;
#[doc = "ShaccCg module"]
pub const SCE_SYSMODULE_SHACCCG: SceSysmoduleModuleId = 62;
#[doc = "Shutter Sound module"]
pub const SCE_SYSMODULE_SHUTTER_SOUND: SceSysmoduleModuleId = 39;
#[doc = "Smart module"]
pub const SCE_SYSMODULE_SMART: SceSysmoduleModuleId = 57;
#[doc = "Sqlite module"]
pub const SCE_SYSMODULE_SQLITE: SceSysmoduleModuleId = 31;
#[doc = "SSL module"]
pub const SCE_SYSMODULE_SSL: SceSysmoduleModuleId = 3;
#[doc = "Sulpha module"]
pub const SCE_SYSMODULE_SULPHA: SceSysmoduleModuleId = 12;
#[doc = "System Gesture module"]
pub const SCE_SYSMODULE_SYSTEM_GESTURE: SceSysmoduleModuleId = 19;
#[doc = "TelephonyUtil module"]
pub const SCE_SYSMODULE_TELEPHONY_UTIL: SceSysmoduleModuleId = 61;
#[doc = "Teleport Client module"]
pub const SCE_SYSMODULE_TELEPORT_CLIENT: SceSysmoduleModuleId = 79;
#[doc = "Teleport Server module"]
pub const SCE_SYSMODULE_TELEPORT_SERVER: SceSysmoduleModuleId = 80;
#[doc = "TriggerUtil module"]
pub const SCE_SYSMODULE_TRIGGER_UTIL: SceSysmoduleModuleId = 32;
#[doc = "Ult module"]
pub const SCE_SYSMODULE_ULT: SceSysmoduleModuleId = 7;
#[doc = "Video Export module"]
pub const SCE_SYSMODULE_VIDEO_EXPORT: SceSysmoduleModuleId = 50;
#[doc = "VideoSearch module"]
pub const SCE_SYSMODULE_VIDEO_SEARCH_EMPR: SceSysmoduleModuleId = 69;
#[doc = "Voice module"]
pub const SCE_SYSMODULE_VOICE: SceSysmoduleModuleId = 26;
#[doc = "VoiceQos module"]
pub const SCE_SYSMODULE_VOICEQOS: SceSysmoduleModuleId = 27;
#[doc = "XML module"]
pub const SCE_SYSMODULE_XML: SceSysmoduleModuleId = 23;
pub const SCE_SYSROOT_INIT_CALLBACK_MAX_FUNC: u32 = 9;
pub const SCE_SYSROOT_INIT_CALLBACK_MAX_SLOT: u32 = 8;
#[doc = "Day/Month/Year"]
pub const SCE_SYSTEM_PARAM_DATE_FORMAT_DDMMYYYY: SceSystemParamDateFormat = 1;
#[doc = "Month/Day/Year"]
pub const SCE_SYSTEM_PARAM_DATE_FORMAT_MMDDYYYY: SceSystemParamDateFormat = 2;
#[doc = "Year/Month/Day"]
pub const SCE_SYSTEM_PARAM_DATE_FORMAT_YYYYMMDD: SceSystemParamDateFormat = 0;
pub const SCE_SYSTEM_PARAM_ENTER_BUTTON_CIRCLE: SceSystemParamEnterButtonAssign = 0;
pub const SCE_SYSTEM_PARAM_ENTER_BUTTON_CROSS: SceSystemParamEnterButtonAssign = 1;
pub const SCE_SYSTEM_PARAM_ENTER_BUTTON_MAX_VALUE: SceSystemParamEnterButtonAssign = 4294967295;
pub const SCE_SYSTEM_PARAM_ID_DATE_FORMAT: SceSystemParamId = 4;
pub const SCE_SYSTEM_PARAM_ID_DAYLIGHT_SAVINGS: SceSystemParamId = 7;
pub const SCE_SYSTEM_PARAM_ID_ENTER_BUTTON: SceSystemParamId = 2;
pub const SCE_SYSTEM_PARAM_ID_LANG: SceSystemParamId = 1;
pub const SCE_SYSTEM_PARAM_ID_MAX_VALUE: SceSystemParamId = 4294967295;
pub const SCE_SYSTEM_PARAM_ID_TIME_FORMAT: SceSystemParamId = 5;
pub const SCE_SYSTEM_PARAM_ID_TIME_ZONE: SceSystemParamId = 6;
pub const SCE_SYSTEM_PARAM_ID_USERNAME: SceSystemParamId = 3;
#[doc = "Simplified Chinese"]
pub const SCE_SYSTEM_PARAM_LANG_CHINESE_S: SceSystemParamLang = 11;
#[doc = "Traditional Chinese"]
pub const SCE_SYSTEM_PARAM_LANG_CHINESE_T: SceSystemParamLang = 10;
#[doc = "Danish"]
pub const SCE_SYSTEM_PARAM_LANG_DANISH: SceSystemParamLang = 14;
#[doc = "Dutch"]
pub const SCE_SYSTEM_PARAM_LANG_DUTCH: SceSystemParamLang = 6;
#[doc = "British English"]
pub const SCE_SYSTEM_PARAM_LANG_ENGLISH_GB: SceSystemParamLang = 18;
#[doc = "American English"]
pub const SCE_SYSTEM_PARAM_LANG_ENGLISH_US: SceSystemParamLang = 1;
#[doc = "Finnish"]
pub const SCE_SYSTEM_PARAM_LANG_FINNISH: SceSystemParamLang = 12;
#[doc = "French"]
pub const SCE_SYSTEM_PARAM_LANG_FRENCH: SceSystemParamLang = 2;
#[doc = "German"]
pub const SCE_SYSTEM_PARAM_LANG_GERMAN: SceSystemParamLang = 4;
#[doc = "Italian"]
pub const SCE_SYSTEM_PARAM_LANG_ITALIAN: SceSystemParamLang = 5;
#[doc = "Japanese"]
pub const SCE_SYSTEM_PARAM_LANG_JAPANESE: SceSystemParamLang = 0;
#[doc = "Korean"]
pub const SCE_SYSTEM_PARAM_LANG_KOREAN: SceSystemParamLang = 9;
#[doc = "Max allowed value"]
pub const SCE_SYSTEM_PARAM_LANG_MAX_VALUE: SceSystemParamLang = 4294967295;
#[doc = "Norwegian"]
pub const SCE_SYSTEM_PARAM_LANG_NORWEGIAN: SceSystemParamLang = 15;
#[doc = "Polish"]
pub const SCE_SYSTEM_PARAM_LANG_POLISH: SceSystemParamLang = 16;
#[doc = "Brazil Portuguese"]
pub const SCE_SYSTEM_PARAM_LANG_PORTUGUESE_BR: SceSystemParamLang = 17;
#[doc = "Portugal Portuguese"]
pub const SCE_SYSTEM_PARAM_LANG_PORTUGUESE_PT: SceSystemParamLang = 7;
#[doc = "Russian"]
pub const SCE_SYSTEM_PARAM_LANG_RUSSIAN: SceSystemParamLang = 8;
#[doc = "Spanish"]
pub const SCE_SYSTEM_PARAM_LANG_SPANISH: SceSystemParamLang = 3;
#[doc = "Swedish"]
pub const SCE_SYSTEM_PARAM_LANG_SWEDISH: SceSystemParamLang = 13;
#[doc = "Turkish"]
pub const SCE_SYSTEM_PARAM_LANG_TURKISH: SceSystemParamLang = 19;
#[doc = "12-hour clock"]
pub const SCE_SYSTEM_PARAM_TIME_FORMAT_12HR: SceSystemParamTimeFormat = 0;
#[doc = "24-hour clock"]
pub const SCE_SYSTEM_PARAM_TIME_FORMAT_24HR: SceSystemParamTimeFormat = 1;
pub const SCE_SYSTEM_PARAM_USERNAME_MAXSIZE: u32 = 17;
#[doc = "48MHz Frequency. Used by GpuEs4 and Threadmgr timers"]
pub const SCE_SYSTIMER_CLOCK_SOURCE_48MHZ: SceSysTimerClockSource = 3;
#[doc = "190/222MHz Frequency. Controlled by kscePower[Get|Set]SysClockFrequency"]
pub const SCE_SYSTIMER_CLOCK_SOURCE_SYS: SceSysTimerClockSource = 0;
#[doc = "64-bit timer"]
pub const SCE_SYSTIMER_TYPE_LONG: SceSysTimerType = 1;
#[doc = "32-bit timer"]
pub const SCE_SYSTIMER_TYPE_WORD: SceSysTimerType = 2;
pub const SCE_THREAD_DEAD: SceThreadStatus = 64;
pub const SCE_THREAD_DELETED: SceThreadStatus = 32;
pub const SCE_THREAD_DORMANT: SceThreadStatus = 16;
pub const SCE_THREAD_KILLED: SceThreadStatus = 32;
pub const SCE_THREAD_READY: SceThreadStatus = 2;
pub const SCE_THREAD_RUNNING: SceThreadStatus = 1;
pub const SCE_THREAD_STAGNANT: SceThreadStatus = 128;
pub const SCE_THREAD_STANDBY: SceThreadStatus = 4;
pub const SCE_THREAD_STOPPED: SceThreadStatus = 16;
pub const SCE_THREAD_SUSPEND: SceThreadStatus = 8;
pub const SCE_THREAD_SUSPENDED: SceThreadStatus = 256;
pub const SCE_THREAD_WAITING: SceThreadStatus = 8;
pub const SCE_TOUCH_ERROR_FATAL: SceTouchErrorCode = 2150957311;
pub const SCE_TOUCH_ERROR_INVALID_ARG: SceTouchErrorCode = 2150957057;
pub const SCE_TOUCH_ERROR_PRIV_REQUIRED: SceTouchErrorCode = 2150957058;
pub const SCE_TOUCH_MAX_REPORT: u32 = 8;
#[doc = "Back touch panel id"]
pub const SCE_TOUCH_PORT_BACK: SceTouchPortType = 1;
#[doc = "Front touch panel id"]
pub const SCE_TOUCH_PORT_FRONT: SceTouchPortType = 0;
#[doc = "Number of touch panels"]
pub const SCE_TOUCH_PORT_MAX_NUM: SceTouchPortType = 2;
pub const SCE_TOUCH_REPORT_INFO_HIDE_UPPER_LAYER: SceTouchReportInfo = 1;
pub const SCE_TOUCH_SAMPLING_STATE_START: SceTouchSamplingState = 1;
pub const SCE_TOUCH_SAMPLING_STATE_STOP: SceTouchSamplingState = 0;
pub const SCE_TRIGGER_UTIL_ERROR_BUSY: SceTriggerUtilErrorCode = 2148546048;
pub const SCE_TRIGGER_UTIL_ERROR_EVENT_TYPE_MISMATCH: SceTriggerUtilErrorCode = 2148546084;
pub const SCE_TRIGGER_UTIL_ERROR_INVALID_ARG: SceTriggerUtilErrorCode = 2148546144;
pub const SCE_TRIGGER_UTIL_ERROR_NOT_FOUND_SYSTEM: SceTriggerUtilErrorCode = 2148546068;
pub const SCE_TRIGGER_UTIL_ERROR_NOT_FOUND_USER: SceTriggerUtilErrorCode = 2148546065;
pub const SCE_TRIGGER_UTIL_ERROR_NOT_REGISTERED: SceTriggerUtilErrorCode = 2148546081;
pub const SCE_TRIGGER_UTIL_FRIDAY: SceTriggerUtilDays = 32;
pub const SCE_TRIGGER_UTIL_MONDAY: SceTriggerUtilDays = 2;
pub const SCE_TRIGGER_UTIL_SATURDAY: SceTriggerUtilDays = 64;
pub const SCE_TRIGGER_UTIL_SUNDAY: SceTriggerUtilDays = 1;
pub const SCE_TRIGGER_UTIL_THURSDAY: SceTriggerUtilDays = 16;
pub const SCE_TRIGGER_UTIL_TUESDAY: SceTriggerUtilDays = 4;
pub const SCE_TRIGGER_UTIL_VERSION: u32 = 52428800;
pub const SCE_TRIGGER_UTIL_WEDNESDAY: SceTriggerUtilDays = 8;
pub const SCE_TRUE: _bindgen_ty_1 = 1;
pub const SCE_UDCD_DEVICE_REQUEST_ATTR_PHYCONT: SceUdcdDeviceRequestAttr = 1;
pub const SCE_UDCD_ERROR_ALREADY_DONE: SceUdcdErrorCode = 2149855233;
pub const SCE_UDCD_ERROR_ARGUMENT_EXCEEDED_LIMIT: SceUdcdErrorCode = 2149855235;
pub const SCE_UDCD_ERROR_BUS_DRIVER_NOT_STARTED: SceUdcdErrorCode = 2149855239;
pub const SCE_UDCD_ERROR_DRIVER_IN_PROGRESS: SceUdcdErrorCode = 2149855238;
pub const SCE_UDCD_ERROR_DRIVER_NOT_FOUND: SceUdcdErrorCode = 2149855237;
pub const SCE_UDCD_ERROR_ILLEGAL_CONTEXT: SceUdcdErrorCode = 2147483696;
pub const SCE_UDCD_ERROR_INVALID_ARGUMENT: SceUdcdErrorCode = 2149855234;
pub const SCE_UDCD_ERROR_INVALID_FLAG: SceUdcdErrorCode = 2147483909;
pub const SCE_UDCD_ERROR_INVALID_POINTER: SceUdcdErrorCode = 2147483907;
pub const SCE_UDCD_ERROR_INVALID_VALUE: SceUdcdErrorCode = 2147484158;
pub const SCE_UDCD_ERROR_MEMORY_EXHAUSTED: SceUdcdErrorCode = 2149855236;
pub const SCE_UDCD_ERROR_USBDRIVER_INVALID_DRIVER: SceUdcdErrorCode = 2149855744;
pub const SCE_UDCD_ERROR_USBDRIVER_INVALID_FUNCS: SceUdcdErrorCode = 2149855746;
pub const SCE_UDCD_ERROR_USBDRIVER_INVALID_NAME: SceUdcdErrorCode = 2149855745;
pub const SCE_UDCD_ERROR_WAIT_CANCEL: SceUdcdErrorCode = 2149855241;
pub const SCE_UDCD_ERROR_WAIT_TIMEOUT: SceUdcdErrorCode = 2149855240;
pub const SCE_UDCD_MAX_ALTERNATE: u32 = 2;
pub const SCE_UDCD_MAX_ENDPOINTS: u32 = 9;
pub const SCE_UDCD_MAX_INTERFACES: u32 = 8;
pub const SCE_UDCD_RETCODE_CANCEL: SceUdcdRetcode = -1;
pub const SCE_UDCD_RETCODE_CANCEL_ALL: SceUdcdRetcode = -2;
pub const SCE_UDCD_RETCODE_CANCEL_TRANSMISSION: SceUdcdRetcode = -3;
pub const SCE_UDCD_RETCODE_RECV: SceUdcdRetcode = 2;
pub const SCE_UDCD_RETCODE_SEND: SceUdcdRetcode = 1;
pub const SCE_UDCD_RETCODE_SUCCESS: SceUdcdRetcode = 0;
pub const SCE_UDCD_STATUS_ACTIVATED: SceUdcdStatus = 512;
pub const SCE_UDCD_STATUS_CABLE_CONNECTED: SceUdcdStatus = 32;
pub const SCE_UDCD_STATUS_CABLE_DISCONNECTED: SceUdcdStatus = 16;
pub const SCE_UDCD_STATUS_CONNECTION_ESTABLISHED: SceUdcdStatus = 2;
pub const SCE_UDCD_STATUS_CONNECTION_NEW: SceUdcdStatus = 1;
pub const SCE_UDCD_STATUS_CONNECTION_SUSPENDED: SceUdcdStatus = 4;
pub const SCE_UDCD_STATUS_DEACTIVATED: SceUdcdStatus = 256;
pub const SCE_UDCD_STATUS_DRIVER_REGISTERED: SceUdcdStatusDriver = 2;
pub const SCE_UDCD_STATUS_DRIVER_STARTED: SceUdcdStatusDriver = 1;
pub const SCE_UDCD_STATUS_IS_CHARGING: SceUdcdStatus = 1024;
pub const SCE_UDCD_STATUS_UNKNOWN_1000: SceUdcdStatus = 4096;
pub const SCE_UDCD_STATUS_UNKNOWN_2000: SceUdcdStatus = 8192;
pub const SCE_UDCD_STATUS_USE_USB_CHARGING: SceUdcdStatus = 2048;
pub const SCE_UID_NAMELEN: u32 = 31;
pub const SCE_UPDATE_MODE_SWU_CUI: u32 = 48;
pub const SCE_UPDATE_MODE_SWU_GUI: u32 = 16;
pub const SCE_USBAUDIO_IN_ERROR_CANNOT_GET_PORT_OWNERSHIP: SceUsbAudioInErrorCode = 2151546886;
pub const SCE_USBAUDIO_IN_ERROR_DEVICE_NOT_FOUND: SceUsbAudioInErrorCode = 2151546884;
pub const SCE_USBAUDIO_IN_ERROR_DEVICE_WAS_HALTED: SceUsbAudioInErrorCode = 2151546890;
pub const SCE_USBAUDIO_IN_ERROR_DUPLICATE_ID: SceUsbAudioInErrorCode = 2151546882;
pub const SCE_USBAUDIO_IN_ERROR_FAILED_TO_COPY_BUFFER: SceUsbAudioInErrorCode = 2151546892;
pub const SCE_USBAUDIO_IN_ERROR_FAILED_TO_READ_STREAM: SceUsbAudioInErrorCode = 2151546889;
pub const SCE_USBAUDIO_IN_ERROR_FAILED_TO_REQUEST_ISOCHRONOUS: SceUsbAudioInErrorCode = 2151546893;
pub const SCE_USBAUDIO_IN_ERROR_INVALID_ARGUMENT: SceUsbAudioInErrorCode = 2151546881;
pub const SCE_USBAUDIO_IN_ERROR_NO_DATA_TO_READ: SceUsbAudioInErrorCode = 2151546891;
pub const SCE_USBAUDIO_IN_ERROR_NO_MEMORY: SceUsbAudioInErrorCode = 2151546883;
pub const SCE_USBAUDIO_IN_ERROR_NOT_SUPPORTED: SceUsbAudioInErrorCode = 2151546885;
pub const SCE_USBAUDIO_IN_ERROR_PORT_IS_ALREADY_OPENED: SceUsbAudioInErrorCode = 2151546887;
pub const SCE_USBAUDIO_IN_ERROR_PROCESS_CANNOT_OPEN_MORE_DEVICE: SceUsbAudioInErrorCode =
    2151546895;
pub const SCE_USBAUDIO_IN_ERROR_PROCESS_HAS_NOT_A_DEVICE_OWNERSHIP: SceUsbAudioInErrorCode =
    2151546888;
pub const SCE_USBAUDIO_IN_ERROR_TIMEOUT: SceUsbAudioInErrorCode = 2151546894;
pub const SCE_USBD_ATTACH_FAILED: i32 = -1;
pub const SCE_USBD_ATTACH_SUCCEEDED: u32 = 0;
pub const SCE_USBD_CLASS_AUDIO: u32 = 1;
pub const SCE_USBD_CLASS_COMMUNICATIONS: u32 = 2;
pub const SCE_USBD_CLASS_DATA: u32 = 10;
pub const SCE_USBD_CLASS_HID: u32 = 3;
pub const SCE_USBD_CLASS_HUB: u32 = 9;
pub const SCE_USBD_CLASS_MONITOR: u32 = 4;
pub const SCE_USBD_CLASS_PER_INTERFACE: u32 = 0;
pub const SCE_USBD_CLASS_PHYSICAL: u32 = 5;
pub const SCE_USBD_CLASS_POWER: u32 = 6;
pub const SCE_USBD_CLASS_PRINTER: u32 = 7;
pub const SCE_USBD_CLASS_STORAGE: u32 = 8;
pub const SCE_USBD_CLASS_VENDOR_SPECIFIC: u32 = 255;
pub const SCE_USBD_CONFIGURATION_REMOTE_WAKEUP: u32 = 32;
pub const SCE_USBD_CONFIGURATION_RESERVED_ONE: u32 = 128;
pub const SCE_USBD_CONFIGURATION_RESERVED_ZERO: u32 = 31;
pub const SCE_USBD_CONFIGURATION_SELF_POWERED: u32 = 64;
pub const SCE_USBD_DESCRIPTOR_CONFIGURATION: SceUsbdDescriptorType = 2;
pub const SCE_USBD_DESCRIPTOR_DEVICE: SceUsbdDescriptorType = 1;
pub const SCE_USBD_DESCRIPTOR_DEVICE_QUALIFIER: SceUsbdDescriptorType = 6;
pub const SCE_USBD_DESCRIPTOR_ENDPOINT: SceUsbdDescriptorType = 5;
pub const SCE_USBD_DESCRIPTOR_HID: SceUsbdDescriptorType = 33;
pub const SCE_USBD_DESCRIPTOR_INTERFACE: SceUsbdDescriptorType = 4;
pub const SCE_USBD_DESCRIPTOR_INTERFACE_POWER: SceUsbdDescriptorType = 8;
pub const SCE_USBD_DESCRIPTOR_OTG: SceUsbdDescriptorType = 9;
pub const SCE_USBD_DESCRIPTOR_OTHER_SPEED: SceUsbdDescriptorType = 7;
pub const SCE_USBD_DESCRIPTOR_REPORT: SceUsbdDescriptorType = 34;
pub const SCE_USBD_DESCRIPTOR_STRING: SceUsbdDescriptorType = 3;
pub const SCE_USBD_DETACH_FAILED: i32 = -1;
pub const SCE_USBD_DETACH_SUCCEEDED: u32 = 0;
pub const SCE_USBD_DEVICE_SPEED_FS: u32 = 1;
pub const SCE_USBD_DEVICE_SPEED_HS: u32 = 2;
pub const SCE_USBD_DEVICE_SPEED_LS: u32 = 0;
pub const SCE_USBD_ENDPOINT_DIRECTION_BITS: u32 = 128;
pub const SCE_USBD_ENDPOINT_DIRECTION_IN: u32 = 128;
pub const SCE_USBD_ENDPOINT_DIRECTION_OUT: u32 = 0;
pub const SCE_USBD_ENDPOINT_DIRECTION_SHIFT: u32 = 7;
pub const SCE_USBD_ENDPOINT_NUMBER_BITS: u32 = 31;
pub const SCE_USBD_ENDPOINT_NUMBER_SHIFT: u32 = 0;
pub const SCE_USBD_ENDPOINT_TRANSFER_TYPE_BITS: u32 = 3;
pub const SCE_USBD_ENDPOINT_TRANSFER_TYPE_BULK: u32 = 2;
pub const SCE_USBD_ENDPOINT_TRANSFER_TYPE_CONTROL: u32 = 0;
pub const SCE_USBD_ENDPOINT_TRANSFER_TYPE_INTERRUPT: u32 = 3;
pub const SCE_USBD_ENDPOINT_TRANSFER_TYPE_ISOCHRONOUS: u32 = 1;
pub const SCE_USBD_ENDPOINT_TRANSFER_TYPE_SHIFT: u32 = 0;
pub const SCE_USBD_ERROR_80240007: SceUsbdErrorCode = 2149842951;
pub const SCE_USBD_ERROR_80240009: SceUsbdErrorCode = 2149842953;
pub const SCE_USBD_ERROR_8024000A: SceUsbdErrorCode = 2149842954;
pub const SCE_USBD_ERROR_ALREADY_INITIALIZED: SceUsbdErrorCode = 2149842946;
pub const SCE_USBD_ERROR_DEVICE_NOT_FOUND: SceUsbdErrorCode = 2149842950;
pub const SCE_USBD_ERROR_FATAL: SceUsbdErrorCode = 2149843199;
pub const SCE_USBD_ERROR_INVALID_PARAM: SceUsbdErrorCode = 2149842947;
pub const SCE_USBD_ERROR_NO_MEMORY: SceUsbdErrorCode = 2149842949;
pub const SCE_USBD_ERROR_NOT_INITIALIZED: SceUsbdErrorCode = 2149842945;
pub const SCE_USBD_ERROR_PIPE_NOT_FOUND: SceUsbdErrorCode = 2149842948;
pub const SCE_USBD_FEATURE_DEVICE_REMOTE_WAKEUP: u32 = 1;
pub const SCE_USBD_FEATURE_ENDPOINT_HALT: u32 = 0;
pub const SCE_USBD_MAX_BULK_PACKET_SIZE: u32 = 64;
pub const SCE_USBD_MAX_FS_CONTROL_PACKET_SIZE: u32 = 64;
pub const SCE_USBD_MAX_FS_INTERRUPT_PACKET_SIZE: u32 = 64;
pub const SCE_USBD_MAX_ISOCHRONOUS_PACKET_SIZE: u32 = 1023;
pub const SCE_USBD_MAX_LS_CONTROL_PACKET_SIZE: u32 = 8;
pub const SCE_USBD_MAX_LS_INTERRUPT_PACKET_SIZE: u32 = 8;
pub const SCE_USBD_PROBE_FAILED: i32 = -1;
pub const SCE_USBD_PROBE_SUCCEEDED: u32 = 0;
pub const SCE_USBD_REQTYPE_DIR_BITS: SceUsbdReqtype = 128;
pub const SCE_USBD_REQTYPE_DIR_TO_DEVICE: SceUsbdReqtype = 0;
pub const SCE_USBD_REQTYPE_DIR_TO_HOST: SceUsbdReqtype = 128;
pub const SCE_USBD_REQTYPE_RECIP_BITS: SceUsbdReqtype = 31;
pub const SCE_USBD_REQTYPE_RECIP_DEVICE: SceUsbdReqtype = 0;
pub const SCE_USBD_REQTYPE_RECIP_ENDPOINT: SceUsbdReqtype = 2;
pub const SCE_USBD_REQTYPE_RECIP_INTERFACE: SceUsbdReqtype = 1;
pub const SCE_USBD_REQTYPE_RECIP_OTHER: SceUsbdReqtype = 3;
pub const SCE_USBD_REQTYPE_TYPE_BITS: SceUsbdReqtype = 96;
pub const SCE_USBD_REQTYPE_TYPE_CLASS: SceUsbdReqtype = 32;
pub const SCE_USBD_REQTYPE_TYPE_RESERVED: SceUsbdReqtype = 96;
pub const SCE_USBD_REQTYPE_TYPE_STANDARD: SceUsbdReqtype = 0;
pub const SCE_USBD_REQTYPE_TYPE_VENDOR: SceUsbdReqtype = 64;
pub const SCE_USBD_REQUEST_CLEAR_FEATURE: SceUsbdRequest = 1;
pub const SCE_USBD_REQUEST_GET_CONFIGURATION: SceUsbdRequest = 8;
pub const SCE_USBD_REQUEST_GET_DESCRIPTOR: SceUsbdRequest = 6;
pub const SCE_USBD_REQUEST_GET_INTERFACE: SceUsbdRequest = 10;
pub const SCE_USBD_REQUEST_GET_STATUS: SceUsbdRequest = 0;
pub const SCE_USBD_REQUEST_SET_ADDRESS: SceUsbdRequest = 5;
pub const SCE_USBD_REQUEST_SET_CONFIGURATION: SceUsbdRequest = 9;
pub const SCE_USBD_REQUEST_SET_DESCRIPTOR: SceUsbdRequest = 7;
pub const SCE_USBD_REQUEST_SET_FEATURE: SceUsbdRequest = 3;
pub const SCE_USBD_REQUEST_SET_INTERFACE: SceUsbdRequest = 11;
pub const SCE_USBD_REQUEST_SYNCH_FRAME: SceUsbdRequest = 12;
pub const SCE_USBSERV_ERROR_FATAL: SceUsbservErrorCode = 2149875967;
pub const SCE_USBSERV_ERROR_INVALID_PARAM: SceUsbservErrorCode = 2149875715;
pub const SCE_USBSERV_ERROR_NOT_SUPPORTED: SceUsbservErrorCode = 2149875716;
pub const SCE_USBSERV_ERROR_UNAVAILABLE: SceUsbservErrorCode = 2149875714;
pub const SCE_USBSTOR_VSTOR_TYPE_CDROM: SceUsbstorVstorType = 5;
pub const SCE_USBSTOR_VSTOR_TYPE_FAT: SceUsbstorVstorType = 0;
pub const SCE_VIDEODEC_ERROR_ALREADY_USED: SceVideodecErrorCode = 2153908232;
pub const SCE_VIDEODEC_ERROR_ES_BUFFER_FULL: SceVideodecErrorCode = 2153908234;
pub const SCE_VIDEODEC_ERROR_INITIALIZE: SceVideodecErrorCode = 2153908235;
pub const SCE_VIDEODEC_ERROR_INVALID_ARGUMENT_SIZE: SceVideodecErrorCode = 2153908238;
pub const SCE_VIDEODEC_ERROR_INVALID_COLOR_FORMAT: SceVideodecErrorCode = 2153908230;
pub const SCE_VIDEODEC_ERROR_INVALID_PARAM: SceVideodecErrorCode = 2153908226;
pub const SCE_VIDEODEC_ERROR_INVALID_POINTER: SceVideodecErrorCode = 2153908233;
pub const SCE_VIDEODEC_ERROR_INVALID_STATE: SceVideodecErrorCode = 2153908228;
pub const SCE_VIDEODEC_ERROR_INVALID_STREAM: SceVideodecErrorCode = 2153908237;
pub const SCE_VIDEODEC_ERROR_INVALID_TYPE: SceVideodecErrorCode = 2153908225;
pub const SCE_VIDEODEC_ERROR_NOT_INITIALIZE: SceVideodecErrorCode = 2153908236;
pub const SCE_VIDEODEC_ERROR_NOT_PHY_CONTINUOUS_MEMORY: SceVideodecErrorCode = 2153908231;
pub const SCE_VIDEODEC_ERROR_OUT_OF_MEMORY: SceVideodecErrorCode = 2153908227;
pub const SCE_VIDEODEC_ERROR_UNSUPPORT_IMAGE_SIZE: SceVideodecErrorCode = 2153908229;
pub const SCE_VIDEODEC_TYPE_HW_AVCDEC: SceVideodecType = 4097;
pub const USB_CLASS_AUDIO: SceUdcdUsbClass = 1;
pub const USB_CLASS_COMM: SceUdcdUsbClass = 2;
pub const USB_CLASS_DATA: SceUdcdUsbClass = 10;
pub const USB_CLASS_HID: SceUdcdUsbClass = 3;
pub const USB_CLASS_HUB: SceUdcdUsbClass = 9;
pub const USB_CLASS_MASS_STORAGE: SceUdcdUsbClass = 8;
#[doc = "for DeviceClass"]
pub const USB_CLASS_PER_INTERFACE: SceUdcdUsbClass = 0;
pub const USB_CLASS_PRINTER: SceUdcdUsbClass = 7;
pub const USB_CLASS_PTP: SceUdcdUsbClass = 6;
pub const USB_CLASS_VENDOR_SPEC: SceUdcdUsbClass = 255;
pub const USB_CLASS_VIDEO: SceUdcdUsbClass = 14;
pub const USB_CTRLTYPE_DIR_DEVICE2HOST: u32 = 128;
pub const USB_CTRLTYPE_DIR_HOST2DEVICE: u32 = 0;
pub const USB_CTRLTYPE_DIR_MASK: u32 = 128;
pub const USB_CTRLTYPE_REC_DEVICE: u32 = 0;
pub const USB_CTRLTYPE_REC_ENDPOINT: u32 = 2;
pub const USB_CTRLTYPE_REC_INTERFACE: u32 = 1;
pub const USB_CTRLTYPE_REC_MASK: u32 = 31;
pub const USB_CTRLTYPE_REC_OTHER: u32 = 3;
pub const USB_CTRLTYPE_TYPE_CLASS: u32 = 32;
pub const USB_CTRLTYPE_TYPE_MASK: u32 = 96;
pub const USB_CTRLTYPE_TYPE_RESERVED: u32 = 96;
pub const USB_CTRLTYPE_TYPE_STANDARD: u32 = 0;
pub const USB_CTRLTYPE_TYPE_VENDOR: u32 = 64;
pub const USBD_CC_BABBLE: u32 = 4;
pub const USBD_CC_DATABUF: u32 = 8;
pub const USBD_CC_MISSED_MICRO_FRAME: u32 = 1;
pub const USBD_CC_NOERR: u32 = 0;
pub const USBD_CC_XACTERR: u32 = 2;
pub const USB_DESCRIPTOR_CONFIGURATION: u32 = 2;
pub const USB_DESCRIPTOR_DEVICE: u32 = 1;
pub const USB_DESCRIPTOR_DEVICE_QUALIFIER: u32 = 6;
pub const USB_DESCRIPTOR_ENDPOINT: u32 = 5;
pub const USB_DESCRIPTOR_INTERFACE: u32 = 4;
pub const USB_DESCRIPTOR_INTERFACE_POWER: u32 = 8;
pub const USB_DESCRIPTOR_OTG: u32 = 9;
pub const USB_DESCRIPTOR_OTHER_SPEED: u32 = 7;
pub const USB_DESCRIPTOR_STRING: u32 = 3;
pub const USB_DT_CONFIG: SceUdcdUsbDt = 2;
pub const USB_DT_CONFIG_SIZE: u32 = 9;
pub const USB_DT_DEVICE: SceUdcdUsbDt = 1;
pub const USB_DT_DEVICE_SIZE: u32 = 18;
pub const USB_DT_ENDPOINT: SceUdcdUsbDt = 5;
pub const USB_DT_ENDPOINT_AUDIO_SIZE: u32 = 9;
pub const USB_DT_ENDPOINT_SIZE: u32 = 7;
pub const USB_DT_HUB_NONVAR_SIZE: u32 = 7;
pub const USB_DT_INTERFACE: SceUdcdUsbDt = 4;
pub const USB_DT_INTERFACE_SIZE: u32 = 9;
pub const USB_DT_STRING: SceUdcdUsbDt = 3;
pub const USB_ENDPOINT_ADDRESS_MASK: u32 = 15;
pub const USB_ENDPOINT_DIR_MASK: u32 = 128;
pub const USB_ENDPOINT_IN: u32 = 128;
pub const USB_ENDPOINT_OUT: u32 = 0;
pub const USB_ENDPOINT_TYPE_BULK: u32 = 2;
pub const USB_ENDPOINT_TYPE_CONTROL: u32 = 0;
pub const USB_ENDPOINT_TYPE_INTERRUPT: u32 = 3;
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS: u32 = 1;
pub const USB_ENDPOINT_TYPE_MASK: u32 = 3;
pub const USB_FEATURE_ENDPOINT_HALT: u32 = 0;
pub const USB_REQ_CLEAR_FEATURE: SceUdcdUsbReq = 1;
pub const USB_REQ_GET_CONFIG: SceUdcdUsbReq = 8;
pub const USB_REQ_GET_DESCRIPTOR: SceUdcdUsbReq = 6;
pub const USB_REQ_GET_INTERFACE: SceUdcdUsbReq = 10;
pub const USB_REQ_GET_STATUS: SceUdcdUsbReq = 0;
pub const USB_REQ_SET_ADDRESS: SceUdcdUsbReq = 5;
pub const USB_REQ_SET_CONFIG: SceUdcdUsbReq = 9;
pub const USB_REQ_SET_DESCRIPTOR: SceUdcdUsbReq = 7;
pub const USB_REQ_SET_FEATURE: SceUdcdUsbReq = 3;
pub const USB_REQ_SET_INTERFACE: SceUdcdUsbReq = 11;
pub const USB_REQ_SYNC_FRAME: SceUdcdUsbReq = 12;
#[link(name = "libScePiglet_stub", kind = "static")]
#[cfg(feature = "libScePiglet_stub")]
extern "C" {}
#[link(name = "SceAppMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceAppMgrForDriver_stub")]
extern "C" {
    #[doc = "Kill a process.\n # Arguments\n\n* `pid` (direction in) - The process to kill.\n # Returns\n\nZero on success, else < 0."]
    pub fn ksceAppMgrKillProcess(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Launch an application for debugging\n\n # Arguments\n\n* `path` (direction in) - Path to the executable to load\n * `args` (direction in) - Arguments to pass to the executable and to configure appmgr\n * `arg_size` (direction in) - The size of the args passed in\n * `type` (direction in) - Set to 0x80000000 for debugging launch\n * `param` (direction in) - pointer to launch params\n * `unk` - unknown, set to nullptr\n\n # Returns\n\npid on success, else < 0."]
    pub fn ksceAppMgrLaunchAppByPath(
        path: *const crate::ctypes::c_char,
        args: *const crate::ctypes::c_char,
        arg_size: SceSize,
        type_: crate::ctypes::c_uint,
        param: *const SceAppMgrLaunchParam,
        unk: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceAppMgr_stub", kind = "static")]
#[cfg(feature = "SceAppMgr_stub")]
extern "C" {
    #[doc = "Get an application state\n\n # Arguments\n\n* `appState` (direction out) - - State of the application\n * `len` (direction in) - - sizeof(SceAppMgrState)\n * `version` (direction in) - - Version (?)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceAppMgrGetAppState(
        appState: *mut SceAppMgrAppState,
        len: SceSize,
        version: u32,
    ) -> crate::ctypes::c_int;
    pub fn _sceSharedFbOpen(index: crate::ctypes::c_int, sysver: crate::ctypes::c_int) -> SceUID;
    #[doc = "Obtains the BGM port, even when it is not in front\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrAcquireBgmPort() -> crate::ctypes::c_int;
    #[doc = "Mount application data\n\n # Arguments\n\n* `id` (direction in) - - App data ID\n * `mount_point` (direction in) - - Mountpoint to use\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** id: 100 (photo0), 101 (friends), 102 (messages), 103 (near), 105 (music), 108 (calendar)"]
    pub fn sceAppMgrAppDataMount(
        id: crate::ctypes::c_int,
        mount_point: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount application data by Title ID\n\n # Arguments\n\n* `id` (direction in) - - App data ID\n * `titleid` (direction in) - - Application title ID\n * `mount_point` (direction in) - - Mountpoint to use\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** id: 106 (ad), 107 (ad)"]
    pub fn sceAppMgrAppDataMountById(
        id: crate::ctypes::c_int,
        titleid: *const crate::ctypes::c_char,
        mount_point: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get application params from SFO descriptor\n\n # Arguments\n\n* `pid` (direction in) - - Process ID\n * `param` (direction in) - - Param ID in the SFO descriptor\n * `string` (direction out) - - Param data\n * `length` (direction in) - - Length of the param data\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** param: 6 (contentid) 8 (category), 9 (stitle/title?), 10 (title/stitle?), 12 (titleid)"]
    pub fn sceAppMgrAppParamGetString(
        pid: crate::ctypes::c_int,
        param: crate::ctypes::c_int,
        string: *mut crate::ctypes::c_char,
        length: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert vs0 path string to a new one usable by applications\n\n # Arguments\n\n* `path` (direction in) - - Path to convert\n * `mount_point` (direction in) - - Mountpoint to use\n * `unk` (direction in) - - Unknown\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrConvertVs0UserDrivePath(
        path: *mut crate::ctypes::c_char,
        mount_point: *mut crate::ctypes::c_char,
        unk: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Destroy an application by Application ID\n\n # Arguments\n\n* `appId` (direction in) - - Application ID of the application\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrDestroyAppByAppId(appId: SceInt32) -> crate::ctypes::c_int;
    #[doc = "Destroy an application by Title ID\n\n # Arguments\n\n* `name` (direction in) - - Title ID of the application\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrDestroyAppByName(name: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Destroy other apps\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrDestroyOtherApp() -> crate::ctypes::c_int;
    pub fn sceAppMgrDrmOpen(param: *const SceAppMgrDrmOpenParam) -> SceInt32;
    #[doc = "Mount game data\n\n # Arguments\n\n* `app_path` (direction in) - - example : \"ux0:/app/${TITLEID}\"\n * `patch_path` (direction in) - - example : \"ux0:/patch/${TITLEID}\", \"invalid:\"\n * `rif_path` (direction in) - - If NULL the system will automatically search the rif path. example : \"ux0:/license/app/${TITLEID}/${HEX}.rif\"\n * `mount_point` (direction in) - - Mountpoint output\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrGameDataMount(
        app_path: *const crate::ctypes::c_char,
        patch_path: *const crate::ctypes::c_char,
        rif_path: *const crate::ctypes::c_char,
        mount_point: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get AppInfo via syscall directly\n\n # Arguments\n\n* `unk` (direction in) - - unknown; maybe titleid\n * `state` (direction out) - - The app state output buffer pointer\n * `syscall_validity` (direction in) - - The syscall validity buffer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrGetAppInfo(
        unk: *const crate::ctypes::c_char,
        state: *mut SceAppMgrAppState,
    ) -> SceInt32;
    #[doc = "Copies app param to an array\n\n # Arguments\n\n* `param` (direction out) - - pointer to a 1024 byte location to store the app param\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** App param example: type=LAUNCH_APP_BY_URI&uri=psgm:play?titleid=NPXS10031"]
    pub fn sceAppMgrGetAppParam(param: *mut crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Get memory budget info for a running system application\n\n # Arguments\n\n* `info` (direction out) - - Info related to the memory budget of the running application.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** This function will always return an error if used in a normal application."]
    pub fn sceAppMgrGetBudgetInfo(info: *mut SceAppMgrBudgetInfo) -> crate::ctypes::c_int;
    #[doc = "Get current coredump state for shell\n\n # Arguments\n\n* `state` (direction out) - - state info output.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrGetCoredumpStateForShell(
        state: *mut SceAppMgrCoredumpState,
    ) -> crate::ctypes::c_int;
    #[doc = "Get device info\n\n # Arguments\n\n* `dev` (direction in) - - Device to get info about\n * `max_size` (direction out) - - Capacity of the device\n * `free_size` (direction out) - - Free space of the device\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** dev: ux0:"]
    pub fn sceAppMgrGetDevInfo(
        dev: *const crate::ctypes::c_char,
        max_size: *mut u64,
        free_size: *mut u64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get Process ID by Title ID\n\n # Arguments\n\n* `pid` (direction out) - - Process ID\n * `name` (direction in) - - Title ID\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrGetIdByName(
        pid: *mut SceUID,
        name: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get Title ID by Process ID\n\n # Arguments\n\n* `pid` (direction in) - - Process ID\n * `name` (direction out) - - Title ID\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrGetNameById(
        pid: SceUID,
        name: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get PID of an application for Shell\n\n # Arguments\n\n* `appId` (direction in) - - Application ID of the application\n\n # Returns\n\nThe PID on success, < 0 on error."]
    pub fn sceAppMgrGetProcessIdByAppIdForShell(appId: SceInt32) -> SceUID;
    #[doc = "Get raw path for a given path\n\n # Arguments\n\n* `path` (direction out) - - Path to convert\n * `resolved_path` (direction in) - - The input process path\n * `resolved_path_size` (direction in) - - The input process path length\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrGetRawPath(
        path: *mut crate::ctypes::c_char,
        resolved_path: *mut crate::ctypes::c_char,
        resolved_path_size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the real/resolved path of app0: (where it's actually mounted)\n\n # Arguments\n\n* `appId` (direction in) - - Use -2 for the current application\n * `resolved_path` (direction out) - - Buffer that will hold the resolved path. It should have enough room to hold 292 characters or it will buffer overflow (noname120).\n\n # Returns\n\n0 on success."]
    pub fn sceAppMgrGetRawPathOfApp0ByAppIdForShell(
        appId: crate::ctypes::c_int,
        resolved_path: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a list of running applications\n\n # Arguments\n\n* `appIds` (direction out) - - Array of running application IDs\n * `count` (direction in) - - Max number of running applications to search\n\n # Returns\n\nNumber of running applications."]
    pub fn sceAppMgrGetRunningAppIdListForShell(
        appIds: *mut SceInt32,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Start an Application by Title ID\n\n # Arguments\n\n* `flags` (direction in) - - Usually 0x60000\n * `name` (direction in) - - Title ID of the application\n * `param` (direction in) - - The params passed to the application which can be retrieved with ::sceAppMgrGetAppParam\n\n # Returns\n\n0 on success < 0 on error."]
    pub fn sceAppMgrLaunchAppByName(
        flags: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
        param: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Start an application by Title ID\n\n # Arguments\n\n* `name` (direction in) - - Title ID of the application\n * `param` (direction in) - - The params passed to the application which can be retrieved with ::sceAppMgrGetAppParam\n * `optParam` (direction in) - - Optional params\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrLaunchAppByName2(
        name: *const crate::ctypes::c_char,
        param: *const crate::ctypes::c_char,
        optParam: *mut SceAppMgrLaunchAppOptParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Start an application by Title ID for Shell\n\n # Arguments\n\n* `name` (direction in) - - Title ID of the application\n * `param` (direction in) - - The params passed to the application which can be retrieved with ::sceAppMgrGetAppParam\n * `optParam` (direction in) - - Optional params\n\n # Returns\n\nApplication ID (?)"]
    pub fn sceAppMgrLaunchAppByName2ForShell(
        name: *const crate::ctypes::c_char,
        param: *const crate::ctypes::c_char,
        optParam: *mut SceAppMgrLaunchAppOptParam,
    ) -> SceUID;
    #[doc = "Start an application by URI\n\n # Arguments\n\n* `flags` (direction in) - - Must be 0x20000\n * `uri` (direction in) - - Uri to launch\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** If flags != 0x20000, Livearea is opened."]
    pub fn sceAppMgrLaunchAppByUri(
        flags: crate::ctypes::c_int,
        uri: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Load and start a SELF executable\n\n # Arguments\n\n* `appPath` (direction in) - - Path of the SELF file\n * `argv` (direction in) - - Args to pass to SELF module_start\n * `optParam` (direction in) - - Optional params\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** SELF file must be located in app0: partition."]
    pub fn sceAppMgrLoadExec(
        appPath: *const crate::ctypes::c_char,
        argv: *const *mut crate::ctypes::c_char,
        optParam: *const SceAppMgrExecOptParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount application data (PSPEmu)\n\n # Arguments\n\n* `id` (direction in) - - App data ID\n * `mount_point` (direction in) - - Mountpoint to use\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** id: 400 (ad), 401 (ad), 402 (ad)"]
    pub fn sceAppMgrMmsMount(
        id: crate::ctypes::c_int,
        mount_point: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount PSPEmu virtual memory stick\n\n # Arguments\n\n* `mount_point` (direction in) - - Mountpoint to use\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** mount_point: ms"]
    pub fn sceAppMgrPspSaveDataRootMount(
        mount_point: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Receive system event\n\n # Arguments\n\n* `systemEvent` (direction out) - - Received system event\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrReceiveSystemEvent(
        systemEvent: *mut SceAppMgrSystemEvent,
    ) -> crate::ctypes::c_int;
    #[doc = "Release acquired BGM port\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrReleaseBgmPort() -> crate::ctypes::c_int;
    #[doc = "Remove data on savedata0: partition\n\n # Arguments\n\n* `data` (direction in) - - Data to remove\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSaveDataDataRemove(
        data: *mut SceAppMgrSaveDataDataDelete,
    ) -> crate::ctypes::c_int;
    #[doc = "Save data on savedata0: partition\n\n # Arguments\n\n* `data` (direction in) - - Data to save\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSaveDataDataSave(data: *mut SceAppMgrSaveDataData) -> crate::ctypes::c_int;
    #[doc = "Create a savedata slot\n\n # Arguments\n\n* `data` (direction in) - - Slot data\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSaveDataSlotCreate(data: *mut SceAppMgrSaveDataSlot) -> crate::ctypes::c_int;
    #[doc = "Delete a savedata slot\n\n # Arguments\n\n* `data` (direction in) - - Slot data\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSaveDataSlotDelete(
        data: *mut SceAppMgrSaveDataSlotDelete,
    ) -> crate::ctypes::c_int;
    #[doc = "Get current param of a savedata slot\n\n # Arguments\n\n* `data` (direction out) - - Slot data\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSaveDataSlotGetParam(data: *mut SceAppMgrSaveDataSlot) -> crate::ctypes::c_int;
    #[doc = "Set current param of a savedata slot\n\n # Arguments\n\n* `data` (direction in) - - Slot data\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSaveDataSlotSetParam(data: *mut SceAppMgrSaveDataSlot) -> crate::ctypes::c_int;
    #[doc = "Set infobar state\n\n # Arguments\n\n* `visibility` (direction in) - - Infobar visibility\n * `color` (direction in) - - Infobar color\n * `transparency` (direction in) - - Infobar transparency\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppMgrSetInfobarState(
        visibility: SceAppMgrInfoBarVisibility,
        color: SceAppMgrInfoBarColor,
        transparency: SceAppMgrInfoBarTransparency,
    ) -> crate::ctypes::c_int;
    #[doc = "Unmount a mountpoint\n\n # Arguments\n\n* `mount_point` (direction in) - - Mountpoint to unmount\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** Unmount app0: for example to enable write access to ux0:app/TITLEID"]
    pub fn sceAppMgrUmount(mount_point: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Mount working directory\n\n # Arguments\n\n* `id` (direction in) - - Working directory ID\n * `mount_point` (direction in) - - Mountpoint to use\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** id: 200 (td), 201 (td), 203 (td), 204 (td), 206 (td)"]
    pub fn sceAppMgrWorkDirMount(
        id: crate::ctypes::c_int,
        mount_point: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount working directory by Title ID\n\n # Arguments\n\n* `id` (direction in) - - Working directory ID\n * `titleid` (direction in) - - Application Title ID\n * `mount_point` (direction in) - - Mountpoint to use\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** id: 205 (cache0), 207 (td)"]
    pub fn sceAppMgrWorkDirMountById(
        id: crate::ctypes::c_int,
        titleid: *const crate::ctypes::c_char,
        mount_point: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceSharedFbBegin(fb_id: SceUID, info: *mut SceSharedFbInfo) -> crate::ctypes::c_int;
    pub fn sceSharedFbClose(fb_id: SceUID) -> crate::ctypes::c_int;
    pub fn sceSharedFbEnd(fb_id: SceUID) -> crate::ctypes::c_int;
    pub fn sceSharedFbGetInfo(fb_id: SceUID, info: *mut SceSharedFbInfo) -> crate::ctypes::c_int;
}
#[link(name = "SceAppUtil_stub", kind = "static")]
#[cfg(feature = "SceAppUtil_stub")]
extern "C" {
    #[doc = "Parse received app event from LiveArea"]
    pub fn sceAppUtilAppEventParseLiveArea(
        eventParam: *const SceAppUtilAppEventParam,
        buffer: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get application parameters for int type"]
    pub fn sceAppUtilAppParamGetInt(
        paramId: SceAppUtilAppParamId,
        value: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get background download status"]
    pub fn sceAppUtilBgdlGetStatus(stat: *mut SceAppUtilBgdlStatus) -> crate::ctypes::c_int;
    #[doc = "Mount cache data"]
    pub fn sceAppUtilCacheMount() -> crate::ctypes::c_int;
    #[doc = "Unmount cache data"]
    pub fn sceAppUtilCacheUmount() -> crate::ctypes::c_int;
    #[doc = "Initializes the AppUtil library. Call this before any of the other functions.\n\n # Arguments\n\n* `initParam` (direction out) - - App init info. Must be initialized with zeros.\n * `bootParam` (direction out) - - App boot info. Must be initialized with zeros.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAppUtilInit(
        initParam: *mut SceAppUtilInitParam,
        bootParam: *mut SceAppUtilBootParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Launch web browser app"]
    pub fn sceAppUtilLaunchWebBrowser(
        param: *mut SceAppUtilWebBrowserParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Load safe memory"]
    pub fn sceAppUtilLoadSafeMemory(
        buf: *mut crate::ctypes::c_void,
        bufSize: SceSize,
        offset: SceOff,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount music data"]
    pub fn sceAppUtilMusicMount() -> crate::ctypes::c_int;
    #[doc = "Unmount music data"]
    pub fn sceAppUtilMusicUmount() -> crate::ctypes::c_int;
    #[doc = "Mount photo data"]
    pub fn sceAppUtilPhotoMount() -> crate::ctypes::c_int;
    #[doc = "Unmount photo data"]
    pub fn sceAppUtilPhotoUmount() -> crate::ctypes::c_int;
    #[doc = "Receive app event"]
    pub fn sceAppUtilReceiveAppEvent(
        eventParam: *mut SceAppUtilAppEventParam,
    ) -> crate::ctypes::c_int;
    pub fn sceAppUtilSaveDataDataRemove(
        slot: *mut SceAppUtilSaveDataFileSlot,
        files: *mut SceAppUtilSaveDataRemoveItem,
        fileNum: crate::ctypes::c_uint,
        mountPoint: *mut SceAppUtilSaveDataMountPoint,
    ) -> crate::ctypes::c_int;
    pub fn sceAppUtilSaveDataDataSave(
        slot: *mut SceAppUtilSaveDataFileSlot,
        files: *mut SceAppUtilSaveDataFile,
        fileNum: crate::ctypes::c_uint,
        mountPoint: *mut SceAppUtilSaveDataMountPoint,
        requiredSizeKB: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Create savedata slot"]
    pub fn sceAppUtilSaveDataSlotCreate(
        slotId: crate::ctypes::c_uint,
        param: *mut SceAppUtilSaveDataSlotParam,
        mountPoint: *mut SceAppUtilSaveDataMountPoint,
    ) -> crate::ctypes::c_int;
    #[doc = "Delete savedata slot"]
    pub fn sceAppUtilSaveDataSlotDelete(
        slotId: crate::ctypes::c_uint,
        mountPoint: *mut SceAppUtilSaveDataMountPoint,
    ) -> crate::ctypes::c_int;
    #[doc = "Get savedata slot param"]
    pub fn sceAppUtilSaveDataSlotGetParam(
        slotId: crate::ctypes::c_uint,
        param: *mut SceAppUtilSaveDataSlotParam,
        mountPoint: *mut SceAppUtilSaveDataMountPoint,
    ) -> crate::ctypes::c_int;
    #[doc = "Set savedata slot param"]
    pub fn sceAppUtilSaveDataSlotSetParam(
        slotId: crate::ctypes::c_uint,
        param: *mut SceAppUtilSaveDataSlotParam,
        mountPoint: *mut SceAppUtilSaveDataMountPoint,
    ) -> crate::ctypes::c_int;
    #[doc = "Save safe memory"]
    pub fn sceAppUtilSaveSafeMemory(
        buf: *mut crate::ctypes::c_void,
        bufSize: SceSize,
        offset: SceOff,
    ) -> crate::ctypes::c_int;
    #[doc = "Shutdown AppUtil library"]
    pub fn sceAppUtilShutdown() -> crate::ctypes::c_int;
    #[doc = "Launch PSN Store"]
    pub fn sceAppUtilStoreBrowse(param: *mut SceAppUtilStoreBrowseParam) -> crate::ctypes::c_int;
    #[doc = "Get system parameters for int type"]
    pub fn sceAppUtilSystemParamGetInt(
        paramId: crate::ctypes::c_uint,
        value: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get application parameters for string type"]
    pub fn sceAppUtilSystemParamGetString(
        paramId: crate::ctypes::c_uint,
        buf: *mut SceChar8,
        bufSize: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceAtrac_stub", kind = "static")]
#[cfg(feature = "SceAtrac_stub")]
extern "C" {
    pub fn sceAtracAddStreamData(
        atracHandle: crate::ctypes::c_int,
        addSize: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracCreateDecoderGroup(
        atracType: SceUInt32,
        pDecoderGroup: *const SceAtracDecoderGroup,
        pvWorkMem: *mut crate::ctypes::c_void,
        initAudiodecFlag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracDecode(
        atracHandle: crate::ctypes::c_int,
        pOutputBuffer: *mut crate::ctypes::c_void,
        pOutputSamples: *mut SceUInt32,
        pDecoderStatus: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracDeleteDecoderGroup(
        atracType: SceUInt32,
        termAudiodecFlag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetContentInfo(
        atracHandle: crate::ctypes::c_int,
        pContentInfo: *mut SceAtracContentInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetDecoderGroupInfo(
        atracType: SceUInt32,
        pCreatedDecoder: *mut SceAtracDecoderGroup,
        pAvailableDecoder: *mut SceAtracDecoderGroup,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetDecoderStatus(
        atracHandle: crate::ctypes::c_int,
        pDecoderStatus: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetInternalError(
        atracHandle: crate::ctypes::c_int,
        pInternalError: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetLoopInfo(
        atracHandle: crate::ctypes::c_int,
        pLoopNum: *mut crate::ctypes::c_int,
        pLoopStatus: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetNextOutputPosition(
        atracHandle: crate::ctypes::c_int,
        pNextOutputSample: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetOutputSamples(
        atracHandle: crate::ctypes::c_int,
        pOutputSamples: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetOutputableSamples(
        atracHandle: crate::ctypes::c_int,
        pOutputableSamples: *mut SceLong64,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetRemainSamples(
        atracHandle: crate::ctypes::c_int,
        pRemainSamples: *mut SceLong64,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetStreamInfo(
        atracHandle: crate::ctypes::c_int,
        pStreamInfo: *mut SceAtracStreamInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetSubBufferInfo(
        atracHandle: crate::ctypes::c_int,
        pReadPosition: *mut SceUInt32,
        pMinSubBufferSize: *mut SceUInt32,
        pDataSize: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracGetVacantSize(
        atracHandle: crate::ctypes::c_int,
        pVacantSize: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracIsSubBufferNeeded(atracHandle: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceAtracQueryDecoderGroupMemSize(
        atracType: SceUInt32,
        pDecoderGroup: *const SceAtracDecoderGroup,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracReleaseHandle(atracHandle: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceAtracResetNextOutputPosition(
        atracHandle: crate::ctypes::c_int,
        resetSample: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracSetDataAndAcquireHandle(
        pucBuffer: *mut SceUChar8,
        uiReadSize: SceUInt32,
        uiBufferSize: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracSetLoopNum(
        atracHandle: crate::ctypes::c_int,
        loopNum: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracSetOutputSamples(
        atracHandle: crate::ctypes::c_int,
        outputSamples: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceAtracSetSubBuffer(
        atracHandle: crate::ctypes::c_int,
        pSubBuffer: *mut SceUChar8,
        subBufferSize: SceUInt32,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceAudiodec_stub", kind = "static")]
#[cfg(feature = "SceAudiodec_stub")]
extern "C" {
    pub fn sceAudiodecClearContext(pCtrl: *mut SceAudiodecCtrl) -> SceInt32;
    pub fn sceAudiodecCreateDecoder(pCtrl: *mut SceAudiodecCtrl, codecType: SceUInt32) -> SceInt32;
    pub fn sceAudiodecCreateDecoderExternal(
        pCtrl: *mut SceAudiodecCtrl,
        codecType: SceUInt32,
        vaContext: SceUIntVAddr,
        contextSize: SceUInt32,
    ) -> SceInt32;
    pub fn sceAudiodecDecode(pCtrl: *mut SceAudiodecCtrl) -> SceInt32;
    pub fn sceAudiodecDecodeNFrames(pCtrl: *mut SceAudiodecCtrl, nFrames: SceUInt32) -> SceInt32;
    pub fn sceAudiodecDecodeNStreams(
        pCtrls: *mut *mut SceAudiodecCtrl,
        nStreams: SceUInt32,
    ) -> SceInt32;
    pub fn sceAudiodecDeleteDecoder(pCtrl: *mut SceAudiodecCtrl) -> SceInt32;
    pub fn sceAudiodecDeleteDecoderExternal(
        pCtrl: *mut SceAudiodecCtrl,
        pvaContext: *mut SceUIntVAddr,
    ) -> SceInt32;
    pub fn sceAudiodecGetContextSize(pCtrl: *mut SceAudiodecCtrl, codecType: SceUInt32)
        -> SceInt32;
    pub fn sceAudiodecGetInternalError(
        pCtrl: *mut SceAudiodecCtrl,
        pInternalError: *mut SceInt32,
    ) -> SceInt32;
    pub fn sceAudiodecInitLibrary(
        codecType: SceUInt32,
        pInitParam: *mut SceAudiodecInitParam,
    ) -> SceInt32;
    pub fn sceAudiodecTermLibrary(codecType: SceUInt32) -> SceInt32;
}
#[link(name = "SceAudioenc_stub", kind = "static")]
#[cfg(feature = "SceAudioenc_stub")]
extern "C" {
    pub fn sceAudioencClearContext(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
    pub fn sceAudioencCreateEncoder(
        pCtrl: *mut SceAudioencCtrl,
        codecType: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceAudioencDeleteEncoder(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
    pub fn sceAudioencEncode(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
    pub fn sceAudioencGetInternalError(
        pCtrl: *mut SceAudioencCtrl,
        pInternalError: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceAudioencGetOptInfo(pCtrl: *mut SceAudioencCtrl) -> crate::ctypes::c_int;
    pub fn sceAudioencInitLibrary(
        codecType: crate::ctypes::c_int,
        pInitParam: *mut SceAudioencInitParam,
    ) -> crate::ctypes::c_int;
    pub fn sceAudioencTermLibrary(codecType: crate::ctypes::c_uint) -> crate::ctypes::c_int;
}
#[link(name = "SceAudioIn_stub", kind = "static")]
#[cfg(feature = "SceAudioIn_stub")]
extern "C" {
    pub fn sceAudioInGetAdopt(portType: SceAudioInPortType) -> crate::ctypes::c_int;
    pub fn sceAudioInGetStatus(select: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceAudioInInput(
        port: crate::ctypes::c_int,
        destPtr: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Open port"]
    pub fn sceAudioInOpenPort(
        portType: SceAudioInPortType,
        grain: crate::ctypes::c_int,
        freq: crate::ctypes::c_int,
        param: SceAudioInParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Close port"]
    pub fn sceAudioInReleasePort(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
#[link(name = "SceAudio_stub", kind = "static")]
#[cfg(feature = "SceAudio_stub")]
extern "C" {
    #[doc = "Get status of port type\n Return different value on whether the port type is used for sound generation or not.\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceAudioOutPortType\n\n # Returns\n\n(1) if port is in use, (0) otherwise. < 0 on error."]
    pub fn sceAudioOutGetAdopt(type_: SceAudioOutPortType) -> crate::ctypes::c_int;
    #[doc = "Get a parameter value of specified output port\n\n # Arguments\n\n* `port` (direction in) - - Port number returned by ::sceAudioOutOpenPort\n * `type` (direction in) - - One of ::SceAudioOutConfigType\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAudioOutGetConfig(
        port: crate::ctypes::c_int,
        type_: SceAudioOutConfigType,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the number of remaining samples to be output on the specified port\n\n # Arguments\n\n* `port` (direction in) - - Port number returned by ::sceAudioOutOpenPort\n\n # Returns\n\nNumber of samples on success, < 0 on error."]
    pub fn sceAudioOutGetRestSample(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Initialize audio port\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceAudioOutPortType\n * `len` (direction in) - - Number of samples, between ::SCE_AUDIO_MIN_LEN and ::SCE_AUDIO_MAX_LEN (multiple of 64)\n * `freq` (direction in) - - Sampling frequency (in Hz), one of the followings :\n 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000\n * `mode` (direction in) - - One of ::SceAudioOutMode\n\n # Returns\n\nport number, < 0 on error.\n > **Note:** - The volume is initially set to its max value (::SCE_AUDIO_OUT_MAX_VOL)"]
    pub fn sceAudioOutOpenPort(
        type_: SceAudioOutPortType,
        len: crate::ctypes::c_int,
        freq: crate::ctypes::c_int,
        mode: SceAudioOutMode,
    ) -> crate::ctypes::c_int;
    #[doc = "Output audio (blocking function)\n\n # Arguments\n\n* `port` (direction in) - - Port number returned by ::sceAudioOutOpenPort\n * `*buf` (direction in) - : Pointer to audio data buffer\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - if NULL is specified for *buf, the function will not return until the last\n output audio data has been output."]
    pub fn sceAudioOutOutput(
        port: crate::ctypes::c_int,
        buf: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Release an audio port\n\n # Arguments\n\n* `type` (direction in) - - Port number returned by ::sceAudioOutOpenPort\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAudioOutReleasePort(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set 'Automatic Level Control' mode on the BGM port\n ALC is also known as 'Dynamic Normalizer'\n\n # Arguments\n\n* `mode` (direction in) - - One of ::SceAudioOutAlcMode\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAudioOutSetAlcMode(mode: SceAudioOutAlcMode) -> crate::ctypes::c_int;
    #[doc = "Change configuration of specified output port\n\n # Arguments\n\n* `port` (direction in) - - Port number returned by ::sceAudioOutOpenPort\n * `len` (direction in) - - see ::sceAudioOutOpenPort()\n * `freq` (direction in) - - see ::sceAudioOutOpenPort()\n * `mode` (direction in) - - see ::sceAudioOutOpenPort()\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If (-1) is specified for any argument (excepted for port), current configuration is used instead."]
    pub fn sceAudioOutSetConfig(
        port: crate::ctypes::c_int,
        len: SceSize,
        freq: crate::ctypes::c_int,
        mode: SceAudioOutMode,
    ) -> crate::ctypes::c_int;
    #[doc = "Set volume of specified output audio port\n\n # Arguments\n\n* `port` (direction in) - - Port number returned by ::sceAudioOutOpenPort\n * `ch` (direction in) - - Channel numbers as flags (see ::SceAudioOutChannelFlag)\n * `*vol` (direction in) - - Array to int specifying volume for each channel (Left channel first for stereo)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAudioOutSetVolume(
        port: crate::ctypes::c_int,
        ch: SceAudioOutChannelFlag,
        vol: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceAvcodecForDriver_stub", kind = "static")]
#[cfg(feature = "SceAvcodecForDriver_stub")]
extern "C" {
    #[doc = "Execute a color conversion from ARGB to YCbCr\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `outBuffer` (direction in) - - A physical continuous memory block 256 bytes aligned\n * `inBuffer` (direction in) - - A pointer to a valid ARGB buffer\n * `inPitch` (direction in) - - Input pitch value in pixels\n * `inPixelFormat` (direction in) - - A valid ::SceJpegEncoderPixelFormat set of values\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderCsc(
        context: SceJpegEncoderContext,
        outBuffer: *mut crate::ctypes::c_void,
        inBuffer: *const crate::ctypes::c_void,
        inPitch: crate::ctypes::c_int,
        inPixelFormat: SceJpegEncoderPixelFormat,
    ) -> crate::ctypes::c_int;
    #[doc = "Execute a jpeg encode\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `inBuffer` (direction in) - - A physically continuous memory block 256 bytes aligned\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderEncode(
        context: SceJpegEncoderContext,
        inBuffer: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Terminate a jpeg encoder\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderEnd(context: SceJpegEncoderContext) -> crate::ctypes::c_int;
    #[doc = "Return required free size to allocate a jpeg encoder\n\n # Returns\n\nRequired free memory size in bytes, < 0 on error."]
    pub fn ksceJpegEncoderGetContextSize() -> crate::ctypes::c_int;
    #[doc = "Initialize a jpeg encoder\n\n # Arguments\n\n* `context` (direction in) - - A pointer to a big enough allocated memory block\n * `inWidth` (direction in) - - Input width in pixels\n * `inHeight` (direction in) - - Input height in pixels\n * `pixelformat` (direction in) - - A valid ::SceJpegEncoderPixelFormat set of values\n * `outBuffer` (direction in) - - A physically continuous memory block 256 bytes aligned\n * `outSize` (direction in) - - Output size in bytes\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderInit(
        context: SceJpegEncoderContext,
        inWidth: crate::ctypes::c_int,
        inHeight: crate::ctypes::c_int,
        pixelformat: SceJpegEncoderPixelFormat,
        outBuffer: *mut crate::ctypes::c_void,
        outSize: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder compression ratio\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `ratio` (direction in) - - A value between 0 and 255 (higher = better compression, lower = better speed)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderSetCompressionRatio(
        context: SceJpegEncoderContext,
        ratio: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set header used for output file\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `mode` (direction in) - - One of ::SceJpegEncoderHeaderMode\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderSetHeaderMode(
        context: SceJpegEncoderContext,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder output address\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `outBuffer` (direction in) - - A physically continuous memory block 256 bytes aligned\n * `outSize` (direction in) - - Output buffer size in bytes\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderSetOutputAddr(
        context: SceJpegEncoderContext,
        outBuffer: *mut crate::ctypes::c_void,
        outSize: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder valid region (?)\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `inWidth` (direction in) - - Input width in pixels\n * `inHeight` (direction in) - - Input height in pixels\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceJpegEncoderSetValidRegion(
        context: SceJpegEncoderContext,
        inWidth: crate::ctypes::c_int,
        inHeight: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceAvcodec_stub", kind = "static")]
#[cfg(feature = "SceAvcodec_stub")]
extern "C" {}
#[link(name = "SceAvcodecUser_stub", kind = "static")]
#[cfg(feature = "SceAvcodecUser_stub")]
extern "C" {}
#[link(name = "SceAVConfig_stub", kind = "static")]
#[cfg(feature = "SceAVConfig_stub")]
extern "C" {
    #[doc = "Get the maximum brightness.\n\n # Arguments\n\n* `maxBrightness` (direction out) - - Maximum brightness.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAVConfigGetDisplayMaxBrightness(
        maxBrightness: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the shutter volume.\n\n # Arguments\n\n* `volume` (direction out) - - shutter volume.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAVConfigGetShutterVol(volume: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get the system volume.\n\n # Arguments\n\n* `volume` (direction out) - - System volume.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAVConfigGetSystemVol(volume: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Turns on mute.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAVConfigMuteOn() -> crate::ctypes::c_int;
    #[doc = "Set the screen brightness.\n\n # Arguments\n\n* `brightness` - - Brightness that the screen will be set to (range 21-65536, 0 turns off the screen).\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAVConfigSetDisplayBrightness(
        brightness: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Sets the color space mode on runtime.\n\n # Arguments\n\n* `csm` (direction in) - - see ::SceAVConfigColorSpaceMode()\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - This does not change color_space_mode in the registry."]
    pub fn sceAVConfigSetDisplayColorSpaceMode(csm: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set the system volume.\n\n # Arguments\n\n* `volume` - - volume that the device will be set to (range 0-30).\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAVConfigSetSystemVol(volume: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
#[link(name = "SceAvPlayer_stub", kind = "static")]
#[cfg(feature = "SceAvPlayer_stub")]
extern "C" {
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `filename` (direction in) - - Full path to the file to play\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerAddSource(
        handle: SceAvPlayerHandle,
        filename: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerClose(handle: SceAvPlayerHandle) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\nCurrent time on the video playback in milliseconds."]
    pub fn sceAvPlayerCurrentTime(handle: SceAvPlayerHandle) -> u64;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `info` (direction out) - - Descriptor for the received data\n\n # Returns\n\nSCE_TRUE if new data is available, SCE_FALSE otherwise."]
    pub fn sceAvPlayerGetAudioData(
        handle: SceAvPlayerHandle,
        info: *mut SceAvPlayerFrameInfo,
    ) -> SceBool;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `id` (direction in) - - Stream ID to get info for.\n * `info` (direction out) - - Info retrieved for the requested stream.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerGetStreamInfo(
        handle: SceAvPlayerHandle,
        id: u32,
        info: *mut SceAvPlayerStreamInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `info` (direction out) - - Descriptor for the received data\n\n # Returns\n\nSCE_TRUE if new data is available, SCE_FALSE otherwise."]
    pub fn sceAvPlayerGetVideoData(
        handle: SceAvPlayerHandle,
        info: *mut SceAvPlayerFrameInfo,
    ) -> SceBool;
    #[doc = "# Arguments\n\n* `data` (direction in) - - Init data for the video player\n\n # Returns\n\nThe video player handle on success, < 0 on error."]
    pub fn sceAvPlayerInit(data: *mut SceAvPlayerInitData) -> SceAvPlayerHandle;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\nSCE_TRUE if the video playback is active, SCE_FALSE otherwise."]
    pub fn sceAvPlayerIsActive(handle: SceAvPlayerHandle) -> SceBool;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `offset` (direction in) - - Offset to jump to on the video playback in milliseconds.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerJumpToTime(handle: SceAvPlayerHandle, offset: u64) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerPause(handle: SceAvPlayerHandle) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerResume(handle: SceAvPlayerHandle) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `looping` (direction in) - - A flag indicating whether the video playback should loop\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerSetLooping(
        handle: SceAvPlayerHandle,
        looping: SceBool,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n * `offset` (direction in) - - One of ::SceAvPlayerTrickSpeeds.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerSetTrickSpeed(
        handle: SceAvPlayerHandle,
        speed: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerStart(handle: SceAvPlayerHandle) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `handle` (direction in) - - A player handle created with ::sceAvPlayerInit\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvPlayerStop(handle: SceAvPlayerHandle) -> crate::ctypes::c_int;
}
#[link(name = "SceBacktraceForDriver_stub", kind = "static")]
#[cfg(feature = "SceBacktraceForDriver_stub")]
extern "C" {}
#[link(name = "SceBbmc_stub", kind = "static")]
#[cfg(feature = "SceBbmc_stub")]
extern "C" {}
#[link(name = "SceBgAppUtil_stub", kind = "static")]
#[cfg(feature = "SceBgAppUtil_stub")]
extern "C" {
    #[doc = "Start BG application (eboot2.bin)\n\n # Arguments\n\n* `mode` (direction in) - - must be 1\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceBgAppUtilStartBgApp(mode: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
#[link(name = "SceBtForDriver_stub", kind = "static")]
#[cfg(feature = "SceBtForDriver_stub")]
extern "C" {
    pub fn ksceBtAvrcpReadVolume(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtAvrcpSendButton(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtAvrcpSendVolume(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtAvrcpSetPlayStatus(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtAvrcpSetTitle(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtDeleteRegisteredInfo(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtFreqAudio(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtGetConfiguration() -> crate::ctypes::c_int;
    pub fn ksceBtGetConnectingInfo(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtGetDeviceName(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
        name: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtGetInfoForTest(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtGetLastError() -> crate::ctypes::c_int;
    pub fn ksceBtGetRegisteredInfo(
        device: crate::ctypes::c_int,
        unk: crate::ctypes::c_int,
        info: *mut SceBtRegisteredInfo,
        info_size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtGetStatusForTest(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtGetVidPid(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
        vid_pid: *mut crate::ctypes::c_ushort,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtHfpGetCurrentPhoneNumber(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtHfpRequest(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtHidGetReportDescriptor(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
        buffer: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtHidTransfer(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
        request: *mut SceBtHidRequest,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtPushBip(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtPushOpp(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtReadEvent(
        events: *mut SceBtEvent,
        num_events: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtRecvAudio(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtRecvBip(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtRecvOpp(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtRecvSpp(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtRegisterCallback(
        cb: SceUID,
        unused: crate::ctypes::c_int,
        flags1: crate::ctypes::c_int,
        flags2: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtReplyPinCode(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
        code: *mut crate::ctypes::c_uchar,
        length: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtReplyUserConfirmation(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
        unk: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtSendAudio(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtSendL2capEchoRequestForTest(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtSendSpp(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtSetConfiguration(r0: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceBtSetContentProtection(r0: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceBtSetInquiryResultForTest(arg1: *mut crate::ctypes::c_uchar)
        -> crate::ctypes::c_int;
    pub fn ksceBtSetInquiryScan(r0: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceBtSetL2capEchoResponseBufferForTest(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtSetStatusForTest(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtStartAudio(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtStartConnect(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtStartDisconnect(
        mac0: crate::ctypes::c_uint,
        mac1: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtStartInquiry() -> crate::ctypes::c_int;
    pub fn ksceBtStopAudio(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceBtStopInquiry() -> crate::ctypes::c_int;
    pub fn ksceBtUnregisterCallback(cb: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "SceBt_stub", kind = "static")]
#[cfg(feature = "SceBt_stub")]
extern "C" {}
#[link(name = "SceCameraForDriver_stub", kind = "static")]
#[cfg(feature = "SceCameraForDriver_stub")]
extern "C" {}
#[link(name = "SceCamera_stub", kind = "static")]
#[cfg(feature = "SceCamera_stub")]
extern "C" {
    #[doc = "Close a camera device.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n\n # Returns\n\nSCE_OK, <0 on error."]
    pub fn sceCameraClose(devnum: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get camera anti-flickering mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraAntiFlicker)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetAntiFlicker(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get auto control hold mode. (?)\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetAutoControlHold(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera backlight compensation mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraBacklight)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetBacklight(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera brightness value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLevel` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetBrightness(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera contrast value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLevel` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetContrast(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera device location. (?)\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLocation` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetDeviceLocation(
        devnum: crate::ctypes::c_int,
        pLocation: *mut SceFVector3,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera exposure compensation value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLevel` (direction out) - - Pointer to a variable where to save the result (See ::SceCameraExposureCompensation).\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetEV(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get active camera effects.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetEffect(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get exposure ceiling mode. (?)\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetExposureCeiling(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera gain mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraGain)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetGain(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera ISO speed mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraISO)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetISO(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceCameraGetImageQuality(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get nightmode mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraNightmode)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetNightmode(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceCameraGetNoiseReduction(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera reverse mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraReverse)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetReverse(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera saturation value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLevel` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraSaturation)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetSaturation(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera sharpness value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLevel` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraSharpness)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetSharpness(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceCameraGetSharpnessOff(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera white balance mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pMode` (direction out) - - Pointer to a variable where to save the result. (See ::SceCameraWhiteBalance)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetWhiteBalance(
        devnum: crate::ctypes::c_int,
        pMode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get camera zoom value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pLevel` (direction out) - - Pointer to a variable where to save the result.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraGetZoom(
        devnum: crate::ctypes::c_int,
        pLevel: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Check if camera device is active.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n\n # Returns\n\n1 if camera is active, 0 if inactive , <0 on error."]
    pub fn sceCameraIsActive(devnum: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Open a camera device.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pInfo` (direction in) - - Pointer to an already set ::SceCameraInfo struct.\n\n # Returns\n\nSCE_OK, <0 on error."]
    pub fn sceCameraOpen(
        devnum: crate::ctypes::c_int,
        pInfo: *mut SceCameraInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Read image data from current streaming.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `pRead` (direction in) - - Pointer to an already set ::SceCameraRead.\n\n # Returns\n\nSCE_OK, <0 on error."]
    pub fn sceCameraRead(
        devnum: crate::ctypes::c_int,
        pRead: *mut SceCameraRead,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera exposure anti-flickering mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraAntiFlicker.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetAntiFlicker(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set auto control hold mode. (?)\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - Auto control hold mode value. (?)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetAutoControlHold(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera backlight mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraBacklight.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetBacklight(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera brightness value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `level` (direction in) - - Brightness value.\n\n # Returns\n\nSCE_OK , <0 on error.\n\n > **Note:** Brightness value must be between 0 and 255."]
    pub fn sceCameraSetBrightness(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera contrast value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `level` (direction in) - - Contrast value.\n\n # Returns\n\nSCE_OK , <0 on error.\n\n > **Note:** Contrast value must be between 0 and 255."]
    pub fn sceCameraSetContrast(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera exposure compensation value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `level` (direction in) - - One of ::SceCameraExposureCompensation.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetEV(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Active a camera effect.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraEffect.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetEffect(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set exposure ceiling mode. (?)\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - Exposure ceiling mode value. (?)\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetExposureCeiling(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera gain mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraGain.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetGain(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera ISO speed mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraISO.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetISO(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceCameraSetImageQuality(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera nightmoge mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraNightmode.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetNightmode(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceCameraSetNoiseReduction(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera reverse mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraReverse.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetReverse(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera saturation value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `level` (direction in) - - One of ::SceCameraSaturation.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetSaturation(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera sharpness value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `level` (direction in) - - One of ::SceCameraSharpness.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetSharpness(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceCameraSetSharpnessOff(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera white balance mode.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `mode` (direction in) - - One of ::SceCameraWhiteBalance.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetWhiteBalance(
        devnum: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set camera zoom value.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n * `level` (direction in) - - Camera zoom value.\n\n # Returns\n\nSCE_OK , <0 on error."]
    pub fn sceCameraSetZoom(
        devnum: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Start camera streaming.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n\n # Returns\n\nSCE_OK, <0 on error."]
    pub fn sceCameraStart(devnum: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Stop camera streaming.\n\n # Arguments\n\n* `devnum` (direction in) - - One of ::SceCameraDevice.\n\n # Returns\n\nSCE_OK, <0 on error."]
    pub fn sceCameraStop(devnum: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
#[link(name = "SceClipboard_stub", kind = "static")]
#[cfg(feature = "SceClipboard_stub")]
extern "C" {}
#[link(name = "SceClockgenForDriver_stub", kind = "static")]
#[cfg(feature = "SceClockgenForDriver_stub")]
extern "C" {}
#[link(name = "SceCodecEnginePerf_stub", kind = "static")]
#[cfg(feature = "SceCodecEnginePerf_stub")]
extern "C" {}
#[link(name = "SceCodecEngine_stub", kind = "static")]
#[cfg(feature = "SceCodecEngine_stub")]
extern "C" {}
#[link(name = "SceCodecEngineWrapper_stub", kind = "static")]
#[cfg(feature = "SceCodecEngineWrapper_stub")]
extern "C" {}
#[link(name = "SceCommonDialog_stub", kind = "static")]
#[cfg(feature = "SceCommonDialog_stub")]
extern "C" {
    pub fn sceCommonDialogSetConfigParam(
        configParam: *const SceCommonDialogConfigParam,
    ) -> crate::ctypes::c_int;
    pub fn sceCommonDialogUpdate(
        updateParam: *const SceCommonDialogUpdateParam,
    ) -> crate::ctypes::c_int;
    pub fn sceImeDialogAbort() -> SceInt32;
    pub fn sceImeDialogGetResult(result: *mut SceImeDialogResult) -> SceInt32;
    pub fn sceImeDialogGetStatus() -> SceCommonDialogStatus;
    pub fn sceImeDialogInit(param: *const SceImeDialogParam) -> SceInt32;
    pub fn sceImeDialogTerm() -> SceInt32;
    pub fn sceMsgDialogAbort() -> crate::ctypes::c_int;
    pub fn sceMsgDialogClose() -> crate::ctypes::c_int;
    pub fn sceMsgDialogGetResult(result: *mut SceMsgDialogResult) -> crate::ctypes::c_int;
    pub fn sceMsgDialogGetStatus() -> SceCommonDialogStatus;
    pub fn sceMsgDialogInit(param: *const SceMsgDialogParam) -> crate::ctypes::c_int;
    #[doc = "Increases the rate of the progress bar in the message dialog\n\n # Arguments\n\n* `target` - - Target progress bar\n * `delta` - - Progress rate to increase (%)\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If NULL is provided as FrameBuf pointer, output is blacked out."]
    pub fn sceMsgDialogProgressBarInc(
        target: SceMsgDialogProgressBarTarget,
        delta: SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the string displayed in the progress bar of the message dialog immediately\n\n # Arguments\n\n* `target` - - Target progress bar\n * `barMsg` - - The string displayed in the progress bar\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If NULL is provided as FrameBuf pointer, output is blacked out."]
    pub fn sceMsgDialogProgressBarSetMsg(
        target: SceMsgDialogProgressBarTarget,
        barMsg: *const SceChar8,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the progress rate of the progress bar in the message dialog immediately\n\n # Arguments\n\n* `target` - - Target progress bar\n * `delta` - - Progress rate to increase (%)\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If NULL is provided as FrameBuf pointer, output is blacked out."]
    pub fn sceMsgDialogProgressBarSetValue(
        target: SceMsgDialogProgressBarTarget,
        rate: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceMsgDialogTerm() -> crate::ctypes::c_int;
    pub fn sceNetCheckDialogAbort() -> SceInt32;
    pub fn sceNetCheckDialogGetPS3ConnectInfo(
        info: *mut SceNetCheckDialogPS3ConnectInfo,
    ) -> SceInt32;
    pub fn sceNetCheckDialogGetResult(result: *mut SceNetCheckDialogResult) -> SceInt32;
    pub fn sceNetCheckDialogGetStatus() -> SceCommonDialogStatus;
    pub fn sceNetCheckDialogInit(param: *mut SceNetCheckDialogParam) -> SceInt32;
    pub fn sceNetCheckDialogTerm() -> SceInt32;
}
#[link(name = "SceCompat_stub", kind = "static")]
#[cfg(feature = "SceCompat_stub")]
extern "C" {
    #[doc = "Allocate cdram with hole\n\n # Arguments\n\n* `cdram` (direction out) - - A pointer to a ::SceCompatCdram structure.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatAllocCdramWithHole(cdram: *mut SceCompatCdram) -> crate::ctypes::c_int;
    #[doc = "Get color space setting availability\n\n # Returns\n\n1 if true, 0 if false, < 0 on error."]
    pub fn sceCompatAvailableColorSpaceSetting() -> crate::ctypes::c_int;
    #[doc = "Cache operation\n\n # Arguments\n\n* `mode` (direction in) - - One of ::SceCompatCacheMode\n * `addr` (direction in) - - Address\n * `size` (direction in) - - Size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatCache(
        mode: crate::ctypes::c_int,
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Check if pocket station application is available\n\n # Returns\n\n1 if true, 0 if false, < 0 on error."]
    pub fn sceCompatCheckPocketStation() -> crate::ctypes::c_int;
    #[doc = "Framebuffer init\n\n # Arguments\n\n* `framebuffer` (direction in) - - Pointer to framebuffer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatFrameBufferInit(
        framebuffer: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get current secure tick\n\n # Arguments\n\n* `tick` (direction out) - - A pointer to a ::SceRtcTick structure.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatGetCurrentSecureTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    #[doc = "Get Memory Card device information\n\n # Arguments\n\n* `info` (direction out) - - A pointer to a ::SceIoDevInfo structure.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatGetDevInf(info: *mut SceIoDevInfo) -> crate::ctypes::c_int;
    #[doc = "Get peripheral state\n\n # Arguments\n\n* `mode` (direction in) - - One of ::SceCompatPeripheralMode\n\n # Returns\n\nstate on success, < 0 on error."]
    pub fn sceCompatGetPeripheralState(mode: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get primary head\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatGetPrimaryHead() -> crate::ctypes::c_int;
    #[doc = "Get PSP system software version\n\n # Returns\n\nversion on success, < 0 on error."]
    pub fn sceCompatGetPspSystemSoftwareVersion() -> crate::ctypes::c_int;
    #[doc = "Get compat status\n\n # Returns\n\nstatus on success, < 0 on error."]
    pub fn sceCompatGetStatus() -> crate::ctypes::c_int;
    #[doc = "Get title list\n\n # Arguments\n\n* `buf` (direction out) - - A 100 bytes buffer for the title list\n * `length` (direction in) - - Must be 100\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatGetTitleList(
        buf: *mut crate::ctypes::c_void,
        length: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get update state\n\n # Returns\n\nstate on success, < 0 on error."]
    pub fn sceCompatGetUpdateState() -> crate::ctypes::c_int;
    #[doc = "Init compat\n\n # Arguments\n\n* `unk` (direction in) - - Unknown, pass 0\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatInitEx(unk: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Interrupt code\n\n # Arguments\n\n* `intr_code` (direction in) - - Interrupt code\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatInterrupt(intr_code: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Check if current title is a pocket station game\n\n # Returns\n\n1 if true, 0 if false, < 0 on error."]
    pub fn sceCompatIsPocketStationTitle() -> crate::ctypes::c_int;
    #[doc = "LCDC sync\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatLCDCSync() -> crate::ctypes::c_int;
    #[doc = "Read from shared sram\n\n # Arguments\n\n* `location` (direction in) - - Location\n * `value` (direction out) - - Pointer to a int buffer to hold the value\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatReadShared32(
        location: crate::ctypes::c_int,
        value: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set display config\n\n # Arguments\n\n* `unk0` (direction in) - - Unknown\n * `unk1` (direction in) - - Unknown\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatSetDisplayConfig(
        unk0: crate::ctypes::c_int,
        unk1: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set RIF name\n\n # Arguments\n\n* `rif` (direction in) - - RIF name (max. 36 chars)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatSetRif(rif: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Set suspend semaphores\n\n # Arguments\n\n* `semaid1` (direction in) - - Semaphore id 1\n * `semaid2` (direction in) - - Semaphore id 2\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatSetSuspendSema(semaid1: SceUID, semaid2: SceUID) -> crate::ctypes::c_int;
    #[doc = "Set update state\n\n # Arguments\n\n* `state` (direction in) - - State\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatSetUpdateState(state: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Start compat\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatStart() -> crate::ctypes::c_int;
    #[doc = "Stop compat\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatStop() -> crate::ctypes::c_int;
    #[doc = "Suspend/resume compat\n\n # Arguments\n\n* `unk` (direction in) - - Unknown, pass 1\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatSuspendResume(unk: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Uninit compat\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatUninit() -> crate::ctypes::c_int;
    #[doc = "Wait for command and get request\n\n # Arguments\n\n* `mode` (direction in) - - Mode\n * `id` (direction in) - - ID\n\n # Returns\n\npointer to request in PspEmu RAM on success, < 0 on error."]
    pub fn sceCompatWaitAndGetRequest(
        mode: crate::ctypes::c_int,
        id: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for special request\n\n # Arguments\n\n* `unk` (direction in) - - Unknown, pass 1\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatWaitSpecialRequest(unk: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Write to shared sram\n\n # Arguments\n\n* `location` (direction in) - - Location\n * `value` (direction in) - - Value\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatWriteShared32(
        location: crate::ctypes::c_int,
        value: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Write shared control\n\n # Arguments\n\n* `info` (direction in) - - A pointer to a ::SceCtrlDataPsp structure.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceCompatWriteSharedCtrl(pad_data: *mut SceCtrlDataPsp) -> crate::ctypes::c_int;
}
#[link(name = "SceCoredumpForDriver_stub", kind = "static")]
#[cfg(feature = "SceCoredumpForDriver_stub")]
extern "C" {}
#[link(name = "SceCoredump_stub", kind = "static")]
#[cfg(feature = "SceCoredump_stub")]
extern "C" {}
#[link(name = "SceCpuForDriver_stub", kind = "static")]
#[cfg(feature = "SceCpuForDriver_stub")]
extern "C" {
    #[doc = "Writeback and invalidate a range of L1 dcache and L2\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuDcacheAndL2InvalidateRange(ptr: *const crate::ctypes::c_void, len: SceSize);
    #[doc = "Writeback and invalidate a range of L1 dcache and L2\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length\n\n # Returns\n\nZero on success"]
    pub fn ksceKernelCpuDcacheAndL2WritebackInvalidateRange(
        ptr: *const crate::ctypes::c_void,
        len: SceSize,
    );
    #[doc = "Writeback a range of L1 dcache and L2\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuDcacheAndL2WritebackRange(ptr: *const crate::ctypes::c_void, len: SceSize);
    #[doc = "Invalidate a range of L1 dcache (without L2)\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuDcacheInvalidateRange(ptr: *const crate::ctypes::c_void, len: SceSize);
    #[doc = "Writeback a range of L1 dcache (without L2)\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuDcacheWritebackRange(ptr: *const crate::ctypes::c_void, len: SceSize);
    #[doc = "Disabled interrupts\n\n # Returns\n\nInterrupt masks before disabling"]
    pub fn ksceKernelCpuDisableInterrupts() -> crate::ctypes::c_int;
    #[doc = "Enable interrupts\n\n # Arguments\n\n* `flags` (direction in) - Interrupt masks\n\n # Returns\n\nnone"]
    pub fn ksceKernelCpuEnableInterrupts(flags: crate::ctypes::c_int);
    #[doc = "Returns the CPU ID of the calling processor\n\n # Returns\n\nThe CPU ID"]
    pub fn ksceKernelCpuGetCpuId() -> crate::ctypes::c_int;
    #[doc = "Acquire a RWSpinlock for reading\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to acquire\n\n > **Note:** It is forbidden to write to data protected by the spinlock after acquiring it with this function."]
    pub fn ksceKernelRWSpinlockLowReadLock(lock: *mut SceKernelRWSpinlock);
    #[doc = "Acquire a RWSpinlock for reading and suspend interrupts if necessary.\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to acquire\n\n # Returns\n\nAn opaque value to be used during the call to ::ksceKernelRWSpinlockLowReadUnlockCpuResumeIntr.\n > **Note:** It is forbidden to write to data protected by the spinlock after acquiring it with this function."]
    pub fn ksceKernelRWSpinlockLowReadLockCpuSuspendIntr(
        lock: *mut SceKernelRWSpinlock,
    ) -> SceKernelIntrStatus;
    #[doc = "Unlock a RWSpinlock previously acquired for reading\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to release"]
    pub fn ksceKernelRWSpinlockLowReadUnlock(lock: *mut SceKernelRWSpinlock);
    #[doc = "Release a RWSpinlock previously acquired for reading and resume interrupts if necessary.\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to release\n * `intr_status` (direction in) - Status value obtained from ::ksceKernelRWSpinlockLowReadLockCpuSuspendIntr/::ksceKernelRWSpinlockLowTryReadLockCpuSuspendIntr.\n\n > **Note:** This function resumes interrupts only if they were enabled before the call to ::ksceKernelRWSpinlockLowReadLockCpuSuspendIntr/::ksceKernelRWSpinlockLowTryReadLockCpuSuspendIntr."]
    pub fn ksceKernelRWSpinlockLowReadUnlockCpuResumeIntr(
        lock: *mut SceKernelRWSpinlock,
        intr_status: SceKernelIntrStatus,
    );
    #[doc = "Attempt to acquire a RWSpinlock for reading\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\n* `SCE_OK` - if the spinlock is acquired\n * `<0` - if the spinlock could not be acquired\n > **Note:** It is forbidden to write to data protected by the spinlock after acquiring it with this function."]
    pub fn ksceKernelRWSpinlockLowTryReadLock(
        lock: *mut SceKernelRWSpinlock,
    ) -> crate::ctypes::c_int;
    #[doc = "Attempt to acquire a RWSpinlock for reading and suspend interrupts if necessary\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\n* `>=0` - if the spinlock is acquired - opaque value describing the interrupt state\n * `<0` - if the spinlock could not be acquired\n > **Note:** Interrupts are only suspended if the acquisition of the spinlock succeeds\n > **Note:** It is forbidden to write to data protected by the spinlock after acquiring it with this function."]
    pub fn ksceKernelRWSpinlockLowTryReadLockCpuSuspendIntr(
        lock: *mut SceKernelRWSpinlock,
    ) -> SceKernelIntrStatus;
    #[doc = "Attempt to acquire a RWSpinlock for writing\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\n* `SCE_OK` - if the spinlock is acquired\n * `<0` - if the spinlock could not be acquired"]
    pub fn ksceKernelRWSpinlockLowTryWriteLock(
        lock: *mut SceKernelRWSpinlock,
    ) -> crate::ctypes::c_int;
    #[doc = "Attempt to acquire a RWSpinlock for writing and suspend interrupts if necessary\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\n* `>=0` - if the spinlock is acquired - opaque value describing the interrupt state\n * `<0` - if the spinlock could not be acquired\n > **Note:** Interrupts are only suspended if the acquisition of the spinlock succeeds"]
    pub fn ksceKernelRWSpinlockLowTryWriteLockCpuSuspendIntr(
        lock: *mut SceKernelRWSpinlock,
    ) -> SceKernelIntrStatus;
    #[doc = "Acquire a RWSpinlock for writing\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to acquire"]
    pub fn ksceKernelRWSpinlockLowWriteLock(lock: *mut SceKernelRWSpinlock);
    #[doc = "Acquire a RWSpinlock for writing and suspend interrupts if necessary.\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to acquire\n\n # Returns\n\nAn opaque value to be used during the call to ::ksceKernelRWSpinlockLowWriteUnlockCpuResumeIntr."]
    pub fn ksceKernelRWSpinlockLowWriteLockCpuSuspendIntr(
        lock: *mut SceKernelRWSpinlock,
    ) -> SceKernelIntrStatus;
    #[doc = "Unlock a RWSpinlock previously acquired for writing\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to release"]
    pub fn ksceKernelRWSpinlockLowWriteUnlock(lock: *mut SceKernelRWSpinlock);
    #[doc = "Release a RWSpinlock acquired for writing and resume interrupts if necessary.\n\n # Arguments\n\n* `lock` (direction in) - RWSpinlock to release\n * `intr_status` (direction in) - Status value obtained from ::ksceKernelRWSpinlockLowWriteLockCpuSuspendIntr/::ksceKernelRWSpinlockLowTryWriteLockCpuSuspendIntr.\n\n > **Note:** This function resumes interrupts only if they were enabled before the call to ::ksceKernelSpinlockLowLockCpuSuspendIntr/::ksceKernelRWSpinlockLowTryWriteLockCpuSuspendIntr."]
    pub fn ksceKernelRWSpinlockLowWriteUnlockCpuResumeIntr(
        lock: *mut SceKernelRWSpinlock,
        intr_status: SceKernelIntrStatus,
    );
    #[doc = "Acquire a spinlock\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire"]
    pub fn ksceKernelSpinlockLowLock(lock: *mut SceKernelSpinlock);
    #[doc = "Acquire a spinlock and suspend interrupts if necessary\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\nAn opaque value to be used during the call to ::ksceKernelSpinlockLowUnlockCpuResumeIntr."]
    pub fn ksceKernelSpinlockLowLockCpuSuspendIntr(
        lock: *mut SceKernelSpinlock,
    ) -> SceKernelIntrStatus;
    #[doc = "Attempt to acquire a spinlock\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\n* `SCE_OK` - if the spinlock is acquired\n * `<0` - if the spinlock could not be acquired"]
    pub fn ksceKernelSpinlockLowTryLock(lock: *mut SceKernelSpinlock) -> crate::ctypes::c_int;
    #[doc = "Attempt to acquire a spinlock and suspend interrupts if necessary\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to acquire\n\n # Returns\n\n* `>=0` - if the spinlock is acquired - opaque value describing the interrupt state\n * `<0` - if the spinlock could not be acquired\n > **Note:** Interrupts are only suspended if the acquisition of the spinlock succeeds"]
    pub fn ksceKernelSpinlockLowTryLockCpuSuspendIntr(
        lock: *mut SceKernelSpinlock,
    ) -> SceKernelIntrStatus;
    #[doc = "Release a previously acquired spinlock\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to release"]
    pub fn ksceKernelSpinlockLowUnlock(lock: *mut SceKernelSpinlock);
    #[doc = "Release a previously acquired spinlock and resume interrupts if necessary\n\n # Arguments\n\n* `lock` (direction in) - Spinlock to release\n * `intr_status` (direction in) - Status value obtained from ::ksceKernelSpinlockLowLockCpuSuspendIntr/::ksceKernelSpinlockLowTryLockCpuSuspendIntr.\n\n > **Note:** This function resumes interrupts only if they were enabled before the call to ::ksceKernelSpinlockLowLockCpuSuspendIntr/::ksceKernelSpinlockLowTryLockCpuSuspendIntrForDriver."]
    pub fn ksceKernelSpinlockLowUnlockCpuResumeIntr(
        lock: *mut SceKernelSpinlock,
        intr_status: SceKernelIntrStatus,
    );
}
#[link(name = "SceCpuForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceCpuForKernel_363_stub")]
extern "C" {}
#[cfg(any(feature = "SceCpuForKernel_363_stub", feature = "SceCpuForKernel_stub"))]
extern "C" {
    pub fn ksceKernelCorelockInitialize(ctx: *mut SceCorelockContext);
    pub fn ksceKernelCorelockLock(ctx: *mut SceCorelockContext, core: SceUInt32);
    pub fn ksceKernelCorelockUnlock(ctx: *mut SceCorelockContext);
    #[doc = "Invalidate all the L1 dcache (without L2)"]
    pub fn ksceKernelCpuDcacheInvalidateAll();
    #[doc = "Writeback all the L1 dcache (without L2)"]
    pub fn ksceKernelCpuDcacheWritebackAll();
    #[doc = "Writeback and invalidate all the L1 dcache (without L2)"]
    pub fn ksceKernelCpuDcacheWritebackInvalidateAll();
    #[doc = "Writeback and invalidate a range of L1 dcache (without L2)\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuDcacheWritebackInvalidateRange(
        ptr: *const crate::ctypes::c_void,
        len: SceSize,
    );
    #[doc = "Writeback and invalidate a range of L1 icache and L2\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuIcacheAndL2WritebackInvalidateRange(
        ptr: *const crate::ctypes::c_void,
        len: SceSize,
    );
    #[doc = "Invalidate all the L1 icache (without L2)\n\n # Returns\n\nZero on success"]
    pub fn ksceKernelCpuIcacheInvalidateAll() -> crate::ctypes::c_int;
    #[doc = "Invalidate a range of L1 icache (without L2)\n\n # Arguments\n\n* `ptr` - The pointer\n * `len` (direction in) - The length"]
    pub fn ksceKernelCpuIcacheInvalidateRange(ptr: *const crate::ctypes::c_void, len: SceSize);
}
#[link(name = "SceCpuForKernel_stub", kind = "static")]
#[cfg(feature = "SceCpuForKernel_stub")]
extern "C" {}
#[link(name = "SceCtrlForDriver_stub", kind = "static")]
#[cfg(feature = "SceCtrlForDriver_stub")]
extern "C" {
    #[doc = "Clear rules for button rapid fire\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `idx` (direction in) - - rule index between 0-15\n\n # Returns\n\n0, <0 on error."]
    pub fn ksceCtrlClearRapidFire(
        port: crate::ctypes::c_int,
        idx: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets intercept\n\n # Arguments\n\n* `intercept` (direction out) - Boolean value\n\n # Returns\n\n0, < 0 on error"]
    pub fn ksceCtrlGetButtonIntercept(intercept: *mut crate::ctypes::c_int)
        -> crate::ctypes::c_int;
    #[doc = "Get controller port information.\n\n # Arguments\n\n* `info` (direction out) - - see ::SceCtrlPortInfo\n # Returns\n\n0, <0 on error"]
    pub fn ksceCtrlGetControllerPortInfo(info: *mut SceCtrlPortInfo) -> crate::ctypes::c_int;
    #[doc = "Get ctrl mask for all process\n\n # Arguments\n\n* `mask` (direction out) - - The pointer of SceCtrlButtons type value output\n\n # Returns\n\n0 on success. < 0 on error."]
    pub fn ksceCtrlGetMaskForAll(mask: *mut u32) -> crate::ctypes::c_int;
    #[doc = "Get ctrl mask for non shell process\n\n # Arguments\n\n* `mask` (direction out) - - The pointer of SceCtrlButtons type value output\n\n # Returns\n\n0 on success. < 0 on error."]
    pub fn ksceCtrlGetMaskForNonShell(mask: *mut u32) -> crate::ctypes::c_int;
    #[doc = "Get the current controller mode.\n\n # Arguments\n\n* `pMode` (direction out) - - Return value, see ::SceCtrlPadInputMode.\n\n # Returns\n\nThe current mode, <0 on error."]
    pub fn ksceCtrlGetSamplingMode(pMode: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (polling, negative logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn ksceCtrlPeekBufferNegative(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (polling, positive logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn ksceCtrlPeekBufferPositive(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (blocking, negative logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn ksceCtrlReadBufferNegative(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (blocking, positive logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn ksceCtrlReadBufferPositive(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Register virtual controller driver.\n\n This function always overwrites global settings and not exist unregister method.\n\n # Arguments\n\n* `driver` (direction in) - - See ::SceCtrlVirtualControllerDriver\n\n # Returns\n\n0 on success. <0 on error"]
    pub fn ksceCtrlRegisterVirtualControllerDriver(
        driver: *mut SceCtrlVirtualControllerDriver,
    ) -> crate::ctypes::c_int;
    #[doc = "Emulate values for the analog pad's X- and Y-axis.\n\n # Arguments\n\n* `port` - Use 0\n * `slot` - The slot used to set the custom values. Between 0 - 3. If multiple slots are used,\n their settings are combined.\n * `user_lX` - New emulated value for the left joystick's X-axis (userspace). Between 0 - 0xFF.\n * `user_lY` - New emulate value for the left joystick's Y-axis (userspace). Between 0 - 0xFF.\n * `user_rX` - New emulated value for the right joystick's X-axis (userspace). Between 0 - 0xFF.\n * `user_rY` - New emulate value for the right joystick's Y-axis (userspace). Between 0 - 0xFF.\n * `kernel_lX` - New emulated value for the left joystick's X-axis (kernelspace). Between 0 - 0xFF.\n * `kernel_lY` - New emulate value for the left joystick's Y-axis (kernelspace). Between 0 - 0xFF.\n * `kernel_rX` - New emulated value for the right joystick's X-axis (kernelspace). Between 0 - 0xFF.\n * `kernel_rY` - New emulate value for the right joystick's Y-axis (kernelspace). Between 0 - 0xFF.\n * `uiMake` - Specifies the duration of the emulation. Measured in sampling counts.\n\n # Returns\n\n0 on success."]
    pub fn ksceCtrlSetAnalogEmulation(
        port: crate::ctypes::c_uint,
        slot: crate::ctypes::c_uchar,
        user_lX: crate::ctypes::c_uchar,
        user_lY: crate::ctypes::c_uchar,
        user_rX: crate::ctypes::c_uchar,
        user_rY: crate::ctypes::c_uchar,
        kernel_lX: crate::ctypes::c_uchar,
        kernel_lY: crate::ctypes::c_uchar,
        kernel_rX: crate::ctypes::c_uchar,
        kernel_rY: crate::ctypes::c_uchar,
        uiMake: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Emulate buttons for the digital pad.\n # Arguments\n\n* `port` - Use 0\n * `slot` - The slot used to set the custom values. Between 0 - 3. If multiple slots are used,\n their settings are combined.\n * `userButtons` - Emulated user buttons of ::SceCtrlButtons. You cannot emulate kernel\n buttons and the emulated buttons will only be applied for applications\n running in user mode.\n * `kernelButtons` - Emulated buttons of ::SceCtrlButtons (you can emulate both user and\n kernel buttons). The emulated buttons will only be applied for applications\n running in kernel mode.\n * `uiMake` - Specifies the duration of the emulation. Measured in sampling counts.\n\n # Returns\n\n0 on success."]
    pub fn ksceCtrlSetButtonEmulation(
        port: crate::ctypes::c_uint,
        slot: crate::ctypes::c_uchar,
        userButtons: crate::ctypes::c_uint,
        kernelButtons: crate::ctypes::c_uint,
        uiMake: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Sets intercept\n\n If true, allows the current thread to intercept controls. The use case\n might be, for example, a game plugin that wishes to capture input without\n having the input sent to the game thread.\n # Arguments\n\n* `intercept` (direction in) - Boolean value\n\n # Returns\n\n0, < 0 on error"]
    pub fn ksceCtrlSetButtonIntercept(intercept: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set rules for button rapid fire\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `idx` (direction in) - - rule index between 0-15\n * `pRule` (direction in) - - structure ::SceCtrlRapidFireRule.\n\n # Returns\n\n0, <0 on error."]
    pub fn ksceCtrlSetRapidFire(
        port: crate::ctypes::c_int,
        idx: crate::ctypes::c_int,
        pRule: *const SceCtrlRapidFireRule,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the controller mode.\n\n # Arguments\n\n* `mode` (direction in) - - One of ::SceCtrlPadInputMode.\n\n # Returns\n\nThe previous mode, <0 on error."]
    pub fn ksceCtrlSetSamplingMode(mode: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Update ctrl mask for all process\n\n # Arguments\n\n* `clear_mask` (direction in) - - The SceCtrlButtons type value\n * `set_mask` (direction in) - - The SceCtrlButtons type value\n\n # Returns\n\nalways 0.\n\n note - Some values cannot be clear/set."]
    pub fn ksceCtrlUpdateMaskForAll(
        clear_mask: crate::ctypes::c_int,
        set_mask: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Update ctrl mask for non shell process\n\n # Arguments\n\n* `clear_mask` (direction in) - - The SceCtrlButtons type value\n * `set_mask` (direction in) - - The SceCtrlButtons type value\n\n # Returns\n\nalways 0.\n\n note - Some values cannot be clear/set."]
    pub fn ksceCtrlUpdateMaskForNonShell(
        clear_mask: crate::ctypes::c_int,
        set_mask: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceCtrl_stub", kind = "static")]
#[cfg(feature = "SceCtrl_stub")]
extern "C" {
    #[doc = "Clear rules for button rapid fire\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `idx` (direction in) - - rule index between 0-15\n\n # Returns\n\n0, <0 on error."]
    pub fn sceCtrlClearRapidFire(
        port: crate::ctypes::c_int,
        idx: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get controller battery information.\n\n # Arguments\n\n* `port` (direction in) - - use 1 for the first paired controller, etc.\n * `batt` (direction out) - - battery level, between 0-5, 0xEE charging, 0xEF charged\n\n # Returns\n\n0, <0 on error."]
    pub fn sceCtrlGetBatteryInfo(
        port: crate::ctypes::c_int,
        batt: *mut SceUInt8,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets intercept\n\n # Arguments\n\n* `intercept` (direction out) - Boolean value\n\n # Returns\n\n0, < 0 on error"]
    pub fn sceCtrlGetButtonIntercept(intercept: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get controller port information.\n\n # Arguments\n\n* `info` (direction out) - - see ::SceCtrlPortInfo\n # Returns\n\n0, <0 on error"]
    pub fn sceCtrlGetControllerPortInfo(info: *mut SceCtrlPortInfo) -> crate::ctypes::c_int;
    #[doc = "Get the current controller mode.\n\n # Arguments\n\n* `pMode` (direction out) - - Return value, see ::SceCtrlPadInputMode.\n\n # Returns\n\nThe current mode, <0 on error."]
    pub fn sceCtrlGetSamplingMode(pMode: *mut SceCtrlPadInputMode) -> crate::ctypes::c_int;
    #[doc = "Check if multi controller is supported\n\n # Returns\n\n1 if yes, 0 if no"]
    pub fn sceCtrlIsMultiControllerSupported() -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (polling, negative logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlPeekBufferNegative(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the wireless controller state information (polling, negative logic).\n\n This function will bind L/R trigger value to L1/R1 instead of LTRIGGER/RTRIGGER\n\n # Arguments\n\n* `port` (direction in) - - use 0-5.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlPeekBufferNegative2(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (polling, positive logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlPeekBufferPositive(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the wireless controller state information (polling, positive logic).\n\n This function will bind L/R trigger value to L1/R1 instead of LTRIGGER/RTRIGGER\n\n # Arguments\n\n* `port` (direction in) - - use 0 - 5.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlPeekBufferPositive2(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (polling, positive logic).\n\n This function will return button presses, even if they're intercepted by common dialog/IME.\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlPeekBufferPositiveExt(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the wireless controller state information (polling, positive logic).\n\n This function will bind L/R trigger value to L1/R1 instead of LTRIGGER/RTRIGGER\n This function will return button presses, even if they're intercepted by common dialog/IME.\n\n # Arguments\n\n* `port` (direction in) - - use 0 - 5.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlPeekBufferPositiveExt2(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (blocking, negative logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlReadBufferNegative(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the wireless controller state information (blocking, negative logic).\n\n This function will bind L/R trigger value to L1/R1 instead of LTRIGGER/RTRIGGER\n\n # Arguments\n\n* `port` (direction in) - - use 0-5.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlReadBufferNegative2(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller state information (blocking, positive logic).\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlReadBufferPositive(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the wireless controller state information (blocking, positive logic).\n\n This function will bind L/R trigger value to L1/R1 instead of LTRIGGER/RTRIGGER\n\n # Arguments\n\n* `port` (direction in) - - use 0-5.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlReadBufferPositive2(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the controller extended state information (blocking, positive logic).\n\n This function will return button presses, even if they're intercepted by common dialog/IME.\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlReadBufferPositiveExt(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the wireless controller extended state information (blocking, positive logic).\n\n This function will bind L/R trigger value to L1/R1 instead of LTRIGGER/RTRIGGER\n This function will return button presses, even if they're intercepted by common dialog/IME.\n\n # Arguments\n\n* `port` (direction in) - - use 0-5.\n * `*pad_data` (direction out) - - see ::SceCtrlData.\n * `count` (direction in) - - Buffers count. Up to 64 buffers can be requested.\n\n # Returns\n\nBuffers count, between 1 and 'count'. <0 on error."]
    pub fn sceCtrlReadBufferPositiveExt2(
        port: crate::ctypes::c_int,
        pad_data: *mut SceCtrlData,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Control the actuator (vibrate) on paired controllers.\n\n # Arguments\n\n* `port` (direction in) - - use 1 for the first paired controller, etc.\n * `state` (direction in) - - see ::SceCtrlActuator\n\n # Returns\n\n0, <0 on error."]
    pub fn sceCtrlSetActuator(
        port: crate::ctypes::c_int,
        pState: *const SceCtrlActuator,
    ) -> crate::ctypes::c_int;
    #[doc = "Sets intercept\n\n If true, allows the current thread to intercept controls. The use case\n might be, for example, a game plugin that wishes to capture input without\n having the input sent to the game thread.\n # Arguments\n\n* `intercept` (direction in) - Boolean value\n\n # Returns\n\n0, < 0 on error"]
    pub fn sceCtrlSetButtonIntercept(intercept: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Control the light bar on paired controllers.\n\n # Arguments\n\n* `port` (direction in) - - use 1 for the first paired controller, etc.\n * `r` (direction in) - - red intensity\n * `g` (direction in) - - green intensity\n * `b` (direction in) - - blue intensity\n\n # Returns\n\n0, <0 on error."]
    pub fn sceCtrlSetLightBar(
        port: crate::ctypes::c_int,
        r: SceUInt8,
        g: SceUInt8,
        b: SceUInt8,
    ) -> crate::ctypes::c_int;
    #[doc = "Set rules for button rapid fire\n\n # Arguments\n\n* `port` (direction in) - - use 0.\n * `idx` (direction in) - - rule index between 0-15\n * `pRule` (direction in) - - structure ::SceCtrlRapidFireRule.\n\n # Returns\n\n0, <0 on error."]
    pub fn sceCtrlSetRapidFire(
        port: crate::ctypes::c_int,
        idx: crate::ctypes::c_int,
        pRule: *const SceCtrlRapidFireRule,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the controller mode.\n\n # Arguments\n\n* `mode` (direction in) - - One of ::SceCtrlPadInputMode.\n\n # Returns\n\nThe previous mode, <0 on error."]
    pub fn sceCtrlSetSamplingMode(mode: SceCtrlPadInputMode) -> crate::ctypes::c_int;
    #[doc = "Set the controller extend mode.\n\n # Arguments\n\n* `mode` (direction in) - - One of ::SceCtrlPadInputMode.\n\n # Returns\n\nThe previous mode, <0 on error."]
    pub fn sceCtrlSetSamplingModeExt(mode: SceCtrlPadInputMode) -> crate::ctypes::c_int;
}
#[link(name = "SceDebugForDriver_stub", kind = "static")]
#[cfg(feature = "SceDebugForDriver_stub")]
extern "C" {
    #[doc = "Get event log info\n\n # Arguments\n\n* `buf` (direction out) - - The SceKernelDebugEventLog buffer list\n * `buf_size` (direction in) - - The buf size\n * `read_blocks` (direction out) - - The read event log number\n\n # Returns\n\n< 0 on error."]
    pub fn ksceEventLogGetInfo(
        buf: *mut crate::ctypes::c_void,
        buf_size: SceSize,
        read_blocks: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Assertion. The condition SCE_FALSE to stopped CPU core.\n\n # Arguments\n\n* `condition` (direction in) - - The condition\n * `dbginfo` (direction in) - - The debug info\n * `lr` (direction in) - - The link register\n\n # Returns\n\nnone."]
    pub fn ksceKernelAssert(
        condition: SceBool,
        dbginfo: *const SceKernelDebugInfo,
        lr: *const crate::ctypes::c_void,
    );
    #[doc = "Printf Assertion Level. The condition SCE_FALSE to stopped CPU core.\n\n # Arguments\n\n* `level` (direction in) - - The print level. see:SceKernelAssertLevel\n * `condition` (direction in) - - The condition\n * `dbginfo` (direction in) - - The debug info\n * `lr` (direction in) - - The link register\n\n # Returns\n\nnone."]
    pub fn ksceKernelAssertLevel(
        level: SceUInt32,
        condition: SceBool,
        dbginfo: *const SceKernelDebugInfo,
        lr: *const crate::ctypes::c_void,
    );
    #[doc = "Get current minimum assertion level\n\n # Returns\n\ncurrent minimum assertion level."]
    pub fn ksceKernelGetAssertLevel() -> crate::ctypes::c_int;
    #[doc = "Get tty log info\n\n # Arguments\n\n* `buf` (direction out) - - The tty log buffer\n * `buf_size` (direction in) - - The buf size\n\n # Returns\n\nlog length on success, < 0 on error."]
    pub fn ksceKernelGetTtyInfo(
        buf: *mut crate::ctypes::c_char,
        buf_size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Kernel Panic\n\n # Arguments\n\n* `dbginfo` (direction in) - - The debug info\n * `lr` (direction in) - - The link register"]
    pub fn ksceKernelPanic(
        dbginfo: *const SceKernelDebugInfo,
        lr: *const crate::ctypes::c_void,
    ) -> !;
    #[doc = "Print log\n\n # Arguments\n\n* `fmt` (direction in) - - print fmt\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** - log is pass to ksceDebugRegisterPutcharHandler's handler."]
    pub fn ksceKernelPrintf(fmt: *const crate::ctypes::c_char, ...) -> crate::ctypes::c_int;
    #[doc = "Printf Assertion Level. The condition SCE_FALSE to stopped CPU core.\n\n # Arguments\n\n* `level` (direction in) - - The print level. see:SceKernelAssertLevel\n * `condition` (direction in) - - The condition\n * `dbginfo` (direction in) - - The debug info\n * `lr` (direction in) - - The link register\n * `fmt` (direction in) - - The text fmt\n\n # Returns\n\nnone."]
    pub fn ksceKernelPrintfAssertLevel(
        level: SceUInt32,
        condition: SceBool,
        dbginfo: *const SceKernelDebugInfo,
        lr: *const crate::ctypes::c_void,
        fmt: *const crate::ctypes::c_char,
        ...
    );
    #[doc = "Kernel Printf\n\n # Arguments\n\n* `level` (direction in) - - The printf level. see::SceKernelDebugLevel\n * `fmt` (direction in) - - The text format"]
    pub fn ksceKernelPrintfLevel(
        level: SceUInt32,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    #[doc = "Kernel Printf Level with Info\n\n # Arguments\n\n* `level` (direction in) - - The printf level. see::SceKernelDebugLevel\n * `flags` (direction in) - - The debug info flags\n * `dbginfo` (direction in) - - The debug info\n * `fmt` (direction in) - - The text format"]
    pub fn ksceKernelPrintfLevelWithInfo(
        level: SceUInt32,
        flags: SceUInt32,
        dbginfo: *const SceKernelDebugInfo,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    #[doc = "Kernel Printf Panic\n\n # Arguments\n\n* `dbginfo` (direction in) - - The debug info\n * `lr` (direction in) - - The link register\n * `fmt` (direction in) - - The text format"]
    pub fn ksceKernelPrintfPanic(
        dbginfo: *const SceKernelDebugInfo,
        lr: *const crate::ctypes::c_void,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> !;
    #[doc = "Kernel Printf with Info\n\n # Arguments\n\n* `flags` (direction in) - - ctx print flags, see:SceKernelDebugPrintFlags\n * `dbginfo` (direction in) - - debug info\n * `fmt` (direction in) - - print fmt\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** - main log is pass to ksceDebugRegisterPutcharHandler's handler.\n dbginfo log is pass to ksceDebugSetHandlers's handler."]
    pub fn ksceKernelPrintfWithInfo(
        flags: SceUInt32,
        dbginfo: *const SceKernelDebugInfo,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    #[doc = "Kernel Vprintf\n\n # Arguments\n\n* `fmt` (direction in) - - The text format\n * `arg` (direction in) - - The fmt list"]
    pub fn ksceKernelVprintf(
        fmt: *const crate::ctypes::c_char,
        arg: va_list,
    ) -> crate::ctypes::c_int;
    #[doc = "Kernel Vprintf Level\n\n # Arguments\n\n* `level` (direction in) - - The printf level. see::SceKernelDebugLevel\n * `fmt` (direction in) - - The text format\n * `arg` (direction in) - - The fmt list"]
    pub fn ksceKernelVprintfLevel(
        level: SceUInt32,
        fmt: *const crate::ctypes::c_char,
        arg: va_list,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceDebugForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceDebugForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceDebugForKernel_363_stub",
    feature = "SceDebugForKernel_stub"
))]
extern "C" {
    #[doc = "Set kpanic flag\n\n # Arguments\n\n* `flag` (direction in) - - If pass not zero to flag, kpanic is not stopped and do smc 0x122.\n\n # Returns\n\nprevious flag."]
    pub fn ksceDebugDisableInfoDump(flag: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceDebugGetPutcharHandler() -> *mut crate::ctypes::c_void;
    pub fn ksceDebugPutchar(character: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceDebugRegisterPutcharHandler(
        func: ::core::option::Option<
            unsafe extern "C" fn(
                args: *mut crate::ctypes::c_void,
                c: crate::ctypes::c_char,
            ) -> crate::ctypes::c_int,
        >,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceDebugSetHandlers(
        func: ::core::option::Option<
            unsafe extern "C" fn(
                unk: crate::ctypes::c_int,
                format: *const crate::ctypes::c_char,
                args: va_list,
            ) -> crate::ctypes::c_int,
        >,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceDebugForKernel_stub", kind = "static")]
#[cfg(feature = "SceDebugForKernel_stub")]
extern "C" {
    #[doc = "Get current minimum assertion level\n\n # Arguments\n\n* `level` (direction in) - - new minimum assertion level\n\n # Returns\n\nprevious minimum assertion level."]
    pub fn ksceKernelSetMinimumAssertionLevel(level: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
#[link(name = "SceDebugLedForDriver_stub", kind = "static")]
#[cfg(feature = "SceDebugLedForDriver_stub")]
extern "C" {
    pub fn ksceDebugLedInvokeHandle0(
        a1: crate::ctypes::c_int,
        a2: crate::ctypes::c_int,
        a3: crate::ctypes::c_int,
        a4: crate::ctypes::c_int,
    );
    pub fn ksceDebugLedInvokeHandle1(
        a1: crate::ctypes::c_int,
        a2: crate::ctypes::c_int,
        a3: crate::ctypes::c_int,
        a4: crate::ctypes::c_int,
    );
    pub fn ksceDebugLedRegisterHandle0(
        func: ::core::option::Option<
            unsafe extern "C" fn(
                a1: crate::ctypes::c_int,
                a2: crate::ctypes::c_int,
                a3: crate::ctypes::c_int,
                a4: crate::ctypes::c_int,
            ),
        >,
    );
    pub fn ksceDebugLedRegisterHandle1(
        func: ::core::option::Option<
            unsafe extern "C" fn(
                a1: crate::ctypes::c_int,
                a2: crate::ctypes::c_int,
                a3: crate::ctypes::c_int,
                a4: crate::ctypes::c_int,
            ),
        >,
    );
    pub fn ksceKernelGetGPI() -> SceUInt32;
    pub fn ksceKernelGetGPO() -> SceUInt32;
    pub fn ksceKernelSetGPI(gpi: SceUInt32);
    pub fn ksceKernelSetGPO(gpo: SceUInt32);
}
#[link(name = "SceDeci4pDbgpForDriver_stub", kind = "static")]
#[cfg(feature = "SceDeci4pDbgpForDriver_stub")]
extern "C" {}
#[link(name = "SceDeci4pUserp_stub", kind = "static")]
#[cfg(feature = "SceDeci4pUserp_stub")]
extern "C" {
    pub fn sceKernelDeci4pClose(socketid: SceUID) -> SceInt32;
    pub fn sceKernelDeci4pDisableWatchpoint() -> SceInt32;
    pub fn sceKernelDeci4pEnableWatchpoint() -> SceInt32;
    pub fn sceKernelDeci4pIsProcessAttached() -> SceInt32;
    pub fn sceKernelDeci4pOpen(
        protoname: *const crate::ctypes::c_char,
        protonum: SceUInt32,
        bufsize: SceSize,
    ) -> SceUID;
    pub fn sceKernelDeci4pRead(
        socketid: SceUID,
        buffer: *mut crate::ctypes::c_void,
        size: SceSize,
        reserved: SceUInt32,
    ) -> SceInt32;
    pub fn sceKernelDeci4pRegisterCallback(socketid: SceUID, cbid: SceUID) -> SceInt32;
    pub fn sceKernelDeci4pWrite(
        socketid: SceUID,
        buffer: *const crate::ctypes::c_void,
        size: SceSize,
        reserved: SceUInt32,
    ) -> SceInt32;
}
#[link(name = "SceDipswForDriver_stub", kind = "static")]
#[cfg(feature = "SceDipswForDriver_stub")]
extern "C" {
    #[doc = "Check dipsw bit.\n\n # Arguments\n\n* `bit` (direction in) - - The dipsw bit index\n\n # Returns\n\nzero or one."]
    pub fn ksceKernelCheckDipsw(bit: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Clear dipsw bit.\n\n # Arguments\n\n* `bit` (direction in) - - The dipsw bit index\n\n # Returns\n\nnone."]
    pub fn ksceKernelClearDipsw(bit: crate::ctypes::c_uint);
    #[doc = "Get dipsw info.\n\n # Arguments\n\n* `idx` (direction in) - - The info index\n - 0:CP Time\n - 1:bid & version\n - 2:CP Time\n - 3:ASLR\n - 4:SDK(SCE)\n - 5:SHELL\n - 6:debug control\n - 7:system control\n\n # Returns\n\ndipsw info."]
    pub fn ksceKernelGetDipswInfo(idx: crate::ctypes::c_uint) -> SceUInt32;
    #[doc = "Set dipsw bit.\n\n # Arguments\n\n* `bit` (direction in) - - The dipsw bit index\n\n # Returns\n\nnone."]
    pub fn ksceKernelSetDipsw(bit: crate::ctypes::c_uint);
}
#[link(name = "SceDisplayForDriver_stub", kind = "static")]
#[cfg(feature = "SceDisplayForDriver_stub")]
extern "C" {
    #[doc = "Get current framebuffer parameters\n\n # Arguments\n\n* `pParam` (direction out) - - Pointer to a ::SceDisplayFrameBuf structure\n which will receive framebuffer parameters.\n\n * `sync` (direction in) - - One of ::DisplaySetBufSync\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceDisplayGetFrameBuf(
        pParam: *mut SceDisplayFrameBuf,
        sync: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get maximum framebuffer resolution\n\n # Arguments\n\n* `width` (direction out) - - Maximum width\n * `height` (direction out) - - Maximum height\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceDisplayGetMaximumFrameBufResolution(
        width: *mut crate::ctypes::c_int,
        height: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Primary display index"]
    pub fn ksceDisplayGetPrimaryHead() -> crate::ctypes::c_int;
    #[doc = "Get the configured framebuffer information of a head and its framebuffer index for a PID\n\n # Arguments\n\n* `pid` (direction in) - - PID of the process to get the framebuffer information from.\n It can either be a vallid PID, -1 to use the current configured\n framebuffer for the head and index, or 0 to use the PID of the caller.\n * `head` (direction in) - - Use 0 for OLED/LCD and 1 for HDMI\n * `index` (direction in) - - Can be 0 or 1\n * `info` (direction out) - - Pointer to a ::SceDisplayFrameBufInfo structure\n which will receive the framebuffer information.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceDisplayGetProcFrameBufInternal(
        pid: SceUID,
        head: crate::ctypes::c_int,
        index: crate::ctypes::c_int,
        info: *mut SceDisplayFrameBufInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Number of vertical blank pulses up to now for a display\n\n # Arguments\n\n* `display` (direction in) - - Display index"]
    pub fn ksceDisplayGetVcountInternal(display: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Register callback to be used when the framebuffer changes\n\n # Arguments\n\n* `uid` (direction in) - - Callback UID"]
    pub fn ksceDisplayRegisterFrameBufCallback(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Register callback to be used when the framebuffer changes for a display\n\n # Arguments\n\n* `display` (direction in) - - Display index\n * `uid` (direction in) - - Callback UID"]
    pub fn ksceDisplayRegisterFrameBufCallbackInternal(
        display: crate::ctypes::c_int,
        uid: SceUID,
    ) -> crate::ctypes::c_int;
    #[doc = "Register callback to be used at each vertical blank start\n\n # Arguments\n\n* `uid` (direction in) - - Callback UID"]
    pub fn ksceDisplayRegisterVblankStartCallback(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Register callback to be used at each vertical blank start for a display\n\n # Arguments\n\n* `display` (direction in) - - Display index\n * `uid` (direction in) - - Callback UID"]
    pub fn ksceDisplayRegisterVblankStartCallbackInternal(
        display: crate::ctypes::c_int,
        uid: SceUID,
    ) -> crate::ctypes::c_int;
    #[doc = "Set/Update framebuffer parameters\n\n # Arguments\n\n* `pParam` (direction in) - - Pointer to a ::SceDisplayFrameBuf structure.\n * `sync` (direction in) - - One of ::DisplaySetBufSync\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If NULL is provided as pParam pointer, output is blacked out."]
    pub fn ksceDisplaySetFrameBuf(
        pParam: *const SceDisplayFrameBuf,
        sync: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set/Update framebuffer parameters for display\n\n # Arguments\n\n* `head` (direction in) - - Use 0 for OLED/LCD and 1 for HDMI\n * `index` (direction in) - - Can be 0 or 1\n * `pParam` (direction in) - - Pointer to a ::SceDisplayFrameBuf structure.\n * `sync` (direction in) - - One of ::DisplaySetBufSync\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If NULL is provided as pParam pointer, output is blacked out."]
    pub fn ksceDisplaySetFrameBufInternal(
        head: crate::ctypes::c_int,
        index: crate::ctypes::c_int,
        pParam: *const SceDisplayFrameBuf,
        sync: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Enable/disable color inversion for a display.\n\n # Arguments\n\n* `display` (direction in) - - Display index\n * `enable` (direction in) - - Enable/disable color inversion"]
    pub fn ksceDisplaySetInvertColors(
        display: crate::ctypes::c_int,
        enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set display plane owner\n\n # Arguments\n\n* `head` (direction in) - - Use 0 for OLED/LCD and 1 for HDMI\n * `index` (direction in) - - Can be 0 or 1\n * `pid` (direction in) - - PID of the new owner\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceDisplaySetOwner(
        head: crate::ctypes::c_int,
        index: crate::ctypes::c_int,
        pid: SceUID,
    ) -> crate::ctypes::c_int;
    #[doc = "Unregister callback used at each vertical blank start\n\n # Arguments\n\n* `uid` (direction in) - - Callback UID"]
    pub fn ksceDisplayUnregisterVblankStartCallback(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Unregister callback used at each vertical blank start for a display\n\n # Arguments\n\n* `display` (direction in) - - Display index\n * `uid` (direction in) - - Callback UID"]
    pub fn ksceDisplayUnregisterVblankStartCallbackInternal(
        display: crate::ctypes::c_int,
        uid: SceUID,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start since last update of framebuffer"]
    pub fn ksceDisplayWaitSetFrameBuf() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback since last update of framebuffer"]
    pub fn ksceDisplayWaitSetFrameBufCB() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start after specified number of vertical periods\n since last update of framebuffer.\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn ksceDisplayWaitSetFrameBufMulti(vcount: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback after specified number of vertical periods\n since last update of framebuffer.\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn ksceDisplayWaitSetFrameBufMultiCB(vcount: crate::ctypes::c_uint)
        -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start"]
    pub fn ksceDisplayWaitVblankStart() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback"]
    pub fn ksceDisplayWaitVblankStartCB() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback for display\n\n # Arguments\n\n* `display` (direction in) - - Display index"]
    pub fn ksceDisplayWaitVblankStartCBInternal(
        display: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start for display\n\n # Arguments\n\n* `display` (direction in) - - Display index"]
    pub fn ksceDisplayWaitVblankStartInternal(
        display: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start after specified number of vertical periods\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn ksceDisplayWaitVblankStartMulti(vcount: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback after specified number of vertical periods\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn ksceDisplayWaitVblankStartMultiCB(vcount: crate::ctypes::c_uint)
        -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback after specified number of vertical periods for display\n\n # Arguments\n\n* `display` (direction in) - - Display index\n * `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn ksceDisplayWaitVblankStartMultiCBInternal(
        display: crate::ctypes::c_int,
        vcount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start after specified number of vertical periods for display\n\n # Arguments\n\n* `display` (direction in) - - Display index\n * `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn ksceDisplayWaitVblankStartMultiInternal(
        display: crate::ctypes::c_int,
        vcount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceDisplay_stub", kind = "static")]
#[cfg(feature = "SceDisplay_stub")]
extern "C" {
    #[doc = "Get current framebuffer parameters\n\n # Arguments\n\n* `pParam` (direction out) - - Pointer to a ::SceDisplayFrameBuf structure\n which will receive framebuffer parameters.\n\n * `sync` (direction in) - - One of ::SceDisplaySetBufSync\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceDisplayGetFrameBuf(
        pParam: *mut SceDisplayFrameBuf,
        sync: SceDisplaySetBufSync,
    ) -> crate::ctypes::c_int;
    #[doc = "Get maximum framebuffer resolution\n\n # Arguments\n\n* `width` (direction out) - - Maximum width\n * `height` (direction out) - - Maximum height\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceDisplayGetMaximumFrameBufResolution(
        width: *mut crate::ctypes::c_int,
        height: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Primary display index"]
    pub fn sceDisplayGetPrimaryHead() -> crate::ctypes::c_int;
    #[doc = "Get current number of fps for the current screen mode.\n\n # Arguments\n\n* `pFps` (direction out) - - Pointer to a float variable to store current number of fps.\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - This function returns a theoretical value, this might not be the exact frame rate."]
    pub fn sceDisplayGetRefreshRate(pFps: *mut f32) -> crate::ctypes::c_int;
    #[doc = "Number of vertical blank pulses up to now"]
    pub fn sceDisplayGetVcount() -> crate::ctypes::c_int;
    #[doc = "Number of vertical blank pulses up to now for a display\n\n # Arguments\n\n* `display` (direction in) - - Display index"]
    pub fn sceDisplayGetVcountInternal(display: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Register callback to be used at each vertical blank start\n\n # Arguments\n\n* `uid` (direction in) - - Callback UID"]
    pub fn sceDisplayRegisterVblankStartCallback(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Set/Update framebuffer parameters\n\n # Arguments\n\n* `pParam` (direction in) - - Pointer to a ::SceDisplayFrameBuf structure.\n * `sync` (direction in) - - One of ::SceDisplaySetBufSync\n\n # Returns\n\n0 on success, < 0 on error.\n > **Note:** - If NULL is provided as pParam pointer, output is blacked out."]
    pub fn sceDisplaySetFrameBuf(
        pParam: *const SceDisplayFrameBuf,
        sync: SceDisplaySetBufSync,
    ) -> crate::ctypes::c_int;
    #[doc = "Unregister callback used at each vertical blank start\n\n # Arguments\n\n* `uid` (direction in) - - Callback UID"]
    pub fn sceDisplayUnregisterVblankStartCallback(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start since last update of framebuffer"]
    pub fn sceDisplayWaitSetFrameBuf() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback since last update of framebuffer"]
    pub fn sceDisplayWaitSetFrameBufCB() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start after specified number of vertical periods\n since last update of framebuffer.\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn sceDisplayWaitSetFrameBufMulti(vcount: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback after specified number of vertical periods\n since last update of framebuffer.\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn sceDisplayWaitSetFrameBufMultiCB(vcount: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start"]
    pub fn sceDisplayWaitVblankStart() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback"]
    pub fn sceDisplayWaitVblankStartCB() -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start after specified number of vertical periods\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn sceDisplayWaitVblankStartMulti(vcount: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Wait for vertical blank start with callback after specified number of vertical periods\n\n # Arguments\n\n* `vcount` (direction in) - - Number of vertical periods before waiting for vertical blank start"]
    pub fn sceDisplayWaitVblankStartMultiCB(vcount: crate::ctypes::c_uint) -> crate::ctypes::c_int;
}
#[link(name = "SceDmacmgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceDmacmgrForDriver_stub")]
extern "C" {
    #[doc = "Generic DMA Functions\n/\n/** # /\n/**\n DMA memcpy\n\n # Arguments\n\n* `dst` (direction in) - - Destination\n * `src` (direction in) - - Source\n * `size` (direction in) - - Size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceDmacMemcpy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "DMA memset\n\n # Arguments\n\n* `dst` (direction in) - - Destination\n * `c` (direction in) - - Constant\n * `size` (direction in) - - Size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceDmacMemset(
        dst: *mut crate::ctypes::c_void,
        c: crate::ctypes::c_int,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Allocate a DMA Op handle.\n\n # Arguments\n\n* `name` - - Name of the DMA Op.\n\n # Returns\n\nthe ID of the DMA Op on success, < 0 on error."]
    pub fn ksceKernelDmaOpAlloc(name: *const crate::ctypes::c_char) -> SceKernelDmaOpId;
    #[doc = "Assign a DMA Op to one of the DMA controllers.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n * `dmac` - - The DMA controller to assign it to.\n * `channel` - - The channel of the controller (0 - 15 for DMAC4, 0 otherwise).\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpAssign(
        opid: SceKernelDmaOpId,
        dmac: SceKernelDmacId,
        channel: SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Append a new list of tags to the DMA Op.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n * `pTag` - - The list of DMA tags to append.\n * `flag` - - One of ::SceKernelDmaOpFlag.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpConcatenate(
        opid: SceKernelDmaOpId,
        pTag: *mut SceKernelDmaOpTag,
        flag: SceKernelDmaOpFlag,
    ) -> crate::ctypes::c_int;
    #[doc = "Dequeue a DMA Op.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpDeQueue(opid: SceKernelDmaOpId) -> crate::ctypes::c_int;
    #[doc = "Enqueue a DMA Op.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpEnQueue(opid: SceKernelDmaOpId) -> crate::ctypes::c_int;
    #[doc = "Free a DMA Op handle.\n\n # Arguments\n\n* `opid` - - The DMA Op to free.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpFree(opid: SceKernelDmaOpId) -> crate::ctypes::c_int;
    #[doc = "Cancel a DMA Op.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpQuit(opid: SceKernelDmaOpId) -> crate::ctypes::c_int;
    #[doc = "Set the callback for the completion of the DMA Op.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n * `callback` - - The callback.\n * `pUserData` - - The callback parameter.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpSetCallback(
        opid: SceKernelDmaOpId,
        callback: SceKernelDmaOpCallback,
        pUserData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Setup a DMA Op with a chain of tags\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n * `pTag` - - The list of DMA tags for the op.\n * `pParam` - - The parameters for the DMA Op.\n * `flag` - - One of ::SceKernelDmaOpFlag.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpSetupChain(
        opid: SceKernelDmaOpId,
        pTag: *mut SceKernelDmaOpTag,
        pParam: *mut SceKernelDmaOpChainParam,
        flag: SceKernelDmaOpFlag,
    ) -> crate::ctypes::c_int;
    #[doc = "Setup a DMA Op with a direct set of parameters.\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n * `pParam` - - The parameters for the DMA Op.\n * `flag` - - One of ::SceKernelDmaOpFlag, excluding ::SCE_KERNEL_DMA_OP_COMPLETE_CHAIN.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpSetupDirect(
        opid: SceKernelDmaOpId,
        pParam: *mut SceKernelDmaOpDirectParam,
        flag: SceKernelDmaOpFlag,
    ) -> crate::ctypes::c_int;
    #[doc = "Synchronize with the completion of a DMA Op\n\n # Arguments\n\n* `opid` - - The target DMA Op.\n * `syncMode` - - One of ::SceKernelDmaOpSyncMode\n * `pTimeout` - - Time limit for ::SCE_KERNEL_DMA_OP_SYNC_TIMED_WAIT\n * `ppErrorTag` - - The ::SceKernelDmaOpTag which was running when the DMA Op failed.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelDmaOpSync(
        opid: SceKernelDmaOpId,
        syncMode: SceKernelDmaOpSyncMode,
        pTimeout: *mut SceUInt32,
        ppErrorTag: *mut *mut SceKernelDmaOpTag,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceDriverUser_stub", kind = "static")]
#[cfg(feature = "SceDriverUser_stub")]
extern "C" {}
#[link(name = "SceDsiForDriver_stub", kind = "static")]
#[cfg(feature = "SceDsiForDriver_stub")]
extern "C" {
    pub fn ksceDsiDcsRead(
        head: crate::ctypes::c_int,
        param: crate::ctypes::c_ushort,
        buff: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceDsiDcsShortWrite(
        head: crate::ctypes::c_int,
        param0: crate::ctypes::c_ushort,
        param1: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceDsiDisableHead(head: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceDsiEnableHead(head: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceDsiGenericReadRequest(
        head: crate::ctypes::c_int,
        param: crate::ctypes::c_int,
        buff: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceDsiGenericShortWrite(
        head: crate::ctypes::c_int,
        param0: crate::ctypes::c_int,
        param1: crate::ctypes::c_int,
        param2: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceDsiGetPixelClock(head: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceDsiGetVicResolution(
        vic: crate::ctypes::c_int,
        width: *mut crate::ctypes::c_int,
        height: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceDsiSendBlankingPacket(head: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceDsiSetLanesAndPixelSize(
        head: crate::ctypes::c_int,
        lanes: crate::ctypes::c_int,
        pixelsize: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceDsiSetVic(
        head: crate::ctypes::c_int,
        vic: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceDTrace_stub", kind = "static")]
#[cfg(feature = "SceDTrace_stub")]
extern "C" {}
#[link(name = "SceError_stub", kind = "static")]
#[cfg(feature = "SceError_stub")]
extern "C" {}
#[link(name = "SceExcpmgrForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceExcpmgrForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceExcpmgrForKernel_363_stub",
    feature = "SceExcpmgrForKernel_stub"
))]
extern "C" {
    #[doc = "Get a pointer to SceExcpmgr's internal data\n\n This is only used by exception handlers.\n\n # Returns\n\npointer to SceExcpmgrData structure"]
    pub fn ksceExcpmgrGetData() -> *mut SceExcpmgrData;
    #[doc = "Register an exception handler\n\n `handler` must point to eight bytes of space followed by the handler code.\n The space will be used in the internal linked list structure.\n\n # Arguments\n\n* `kind` (direction in) - The kind of exception\n * `priority` (direction in) - The priority (must be 0 <= priority < 8), 0 highest\n * `handler` - The handler\n\n # Returns\n\nError code or zero on success"]
    pub fn ksceExcpmgrRegisterHandler(
        kind: SceExcpKind,
        priority: crate::ctypes::c_int,
        handler: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceExcpmgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceExcpmgrForKernel_stub")]
extern "C" {}
#[link(name = "SceFace_stub", kind = "static")]
#[cfg(feature = "SceFace_stub")]
extern "C" {}
#[link(name = "SceFiber_stub", kind = "static")]
#[cfg(feature = "SceFiber_stub")]
extern "C" {
    pub fn _sceFiberInitializeImpl(
        fiber: *mut SceFiber,
        name: *mut crate::ctypes::c_char,
        entry: SceFiberEntry,
        argOnInitialize: SceUInt32,
        addrContext: *mut crate::ctypes::c_void,
        sizeContext: SceSize,
        params: *mut SceFiberOptParam,
    ) -> SceInt32;
    pub fn sceFiberFinalize(fiber: *mut SceFiber) -> SceInt32;
    pub fn sceFiberGetInfo(fiber: *mut SceFiber, fiberInfo: *mut SceFiberInfo) -> SceInt32;
    pub fn sceFiberGetSelf(fiber: *mut SceFiber) -> SceInt32;
    pub fn sceFiberOptParamInitialize(optParam: *mut SceFiberOptParam) -> SceInt32;
    pub fn sceFiberReturnToThread(argOnReturn: SceUInt32, argOnRun: *mut SceUInt32) -> SceInt32;
    pub fn sceFiberRun(
        fiber: *mut SceFiber,
        argOnRunTo: SceUInt32,
        argOnRun: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceFiberSwitch(
        fiber: *mut SceFiber,
        argOnRunTo: SceUInt32,
        argOnRun: *mut SceUInt32,
    ) -> SceInt32;
}
#[link(name = "SceFios2KernelForDriver_stub", kind = "static")]
#[cfg(feature = "SceFios2KernelForDriver_stub")]
extern "C" {
    #[doc = "Overlay process file system overlay\n\n # Arguments\n\n* `overlay` (direction in) - - Overlay config pointer\n * `outID` (direction out) - - outID pointer\n\n # Returns\n\nError code or zero on success"]
    pub fn ksceFiosKernelOverlayAdd(
        overlay: *mut SceFiosOverlay,
        outID: *mut SceFiosOverlayID,
    ) -> crate::ctypes::c_int;
    #[doc = "Overlay process file system overlay\n\n # Arguments\n\n* `pid` (direction in) - - Process id\n * `overlay` (direction in) - - Overlay config pointer\n * `outID` (direction out) - - outID pointer\n\n # Returns\n\nError code or zero on success"]
    pub fn ksceFiosKernelOverlayAddForProcess(
        pid: SceUID,
        overlay: *mut SceFiosOverlay,
        outID: *mut SceFiosOverlayID,
    ) -> crate::ctypes::c_int;
    #[doc = "Remove process file system overlay\n\n # Arguments\n\n* `pid` (direction in) - - Process id\n * `id` (direction in) - - Overlay id\n\n # Returns\n\nError code or zero on success"]
    pub fn ksceFiosKernelOverlayRemoveForProcess(
        pid: SceUID,
        id: SceFiosOverlayID,
    ) -> crate::ctypes::c_int;
    #[doc = "Resolve process file system overlay with sync\n\n # Arguments\n\n* `pid` (direction in) - - Process id\n * `resolveFlag` (direction in) - - Some flags\n * `inPath` (direction in) - - Path input\n * `outPath` (direction out) - - Path output\n * `maxPath` (direction in) - - Path output max length\n\n # Returns\n\nError code or zero on success"]
    pub fn ksceFiosKernelOverlayResolveSync(
        pid: SceUID,
        resolveFlag: crate::ctypes::c_int,
        inPath: *const crate::ctypes::c_char,
        outPath: *mut crate::ctypes::c_char,
        maxPath: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceFios2Kernel_stub", kind = "static")]
#[cfg(feature = "SceFios2Kernel_stub")]
extern "C" {
    pub fn _sceFiosKernelOverlayAdd(
        overlay: *const SceFiosKernelOverlay,
        out_id: *mut SceFiosKernelOverlayID,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayAddForProcess(
        target_process: SceUID,
        overlay: *const SceFiosKernelOverlay,
        out_id: *mut SceFiosKernelOverlayID,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayDHChstatSync(
        dh: SceFiosKernelOverlayDH,
        new_stat: *const SceFiosNativeStat,
        cbit: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayDHCloseSync(dh: SceFiosKernelOverlayDH) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayDHOpenSync(
        out_dh: *mut SceFiosKernelOverlayDH,
        path: *const crate::ctypes::c_char,
        from_order: SceUInt8,
        args: *mut SceFiosDHOpenSyncSyscallArgs,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayDHReadSync(
        dh: SceFiosKernelOverlayDH,
        out_entry: *mut SceFiosNativeDirEntry,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayDHStatSync(
        dh: SceFiosKernelOverlayDH,
        out_stat: *mut SceFiosNativeStat,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayDHSyncSync(
        dh: SceFiosKernelOverlayDH,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayGetInfo(
        id: SceFiosKernelOverlayID,
        out_overlay: *mut SceFiosKernelOverlay,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayGetInfoForProcess(
        target_process: SceUID,
        id: SceFiosKernelOverlayID,
        out_overlay: *mut SceFiosKernelOverlay,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayGetList(
        pid: SceUID,
        min_order: SceUInt8,
        max_order: SceUInt8,
        args: *mut SceFiosGetListSyscallArgs,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayGetRecommendedScheduler(
        avail: crate::ctypes::c_int,
        partially_resolved_path: *const crate::ctypes::c_char,
        a3: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayModify(
        id: SceFiosKernelOverlayID,
        new_value: *const SceFiosKernelOverlay,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayModifyForProcess(
        target_process: SceUID,
        id: SceFiosKernelOverlayID,
        new_value: *const SceFiosKernelOverlay,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayRemove(id: SceFiosKernelOverlayID) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayRemoveForProcess(
        target_process: SceUID,
        id: SceFiosKernelOverlayID,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayResolveSync(
        pid: SceUID,
        resolve_flag: crate::ctypes::c_int,
        in_path: *const crate::ctypes::c_char,
        args: *mut SceFiosResolveSyncSyscallArgs,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayResolveWithRangeSync(
        pid: SceUID,
        resolve_flag: crate::ctypes::c_int,
        in_path: *const crate::ctypes::c_char,
        args: *mut SceFiosResolveWithRangeSyncSyscallArgs,
    ) -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayThreadIsDisabled() -> crate::ctypes::c_int;
    pub fn _sceFiosKernelOverlayThreadSetDisabled(disabled: SceInt32) -> crate::ctypes::c_int;
    pub fn sceFiosKernelOverlayAddForProcess02(
        pid: SceUID,
        overlay: *mut SceFiosOverlay,
        outID: *mut SceFiosOverlayID,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceFios2_stub", kind = "static")]
#[cfg(feature = "SceFios2_stub")]
extern "C" {}
#[link(name = "SceGameUpdate_stub", kind = "static")]
#[cfg(feature = "SceGameUpdate_stub")]
extern "C" {}
#[link(name = "SceGpioForDriver_stub", kind = "static")]
#[cfg(feature = "SceGpioForDriver_stub")]
extern "C" {
    pub fn ksceGpioAcquireIntr(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioGetIntrMode(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioGetPortMode(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioPortClear(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioPortRead(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioPortReset(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioPortSet(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioQueryIntr(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioSetIntrMode(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
        intr_mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpioSetPortMode(
        bus: crate::ctypes::c_int,
        port: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceGps_stub", kind = "static")]
#[cfg(feature = "SceGps_stub")]
extern "C" {
    pub fn _sceGpsClose() -> crate::ctypes::c_int;
    pub fn _sceGpsGetData(
        pos: *mut SceGpsPositionData,
        sat: *mut SceGpsSatelliteData,
    ) -> crate::ctypes::c_int;
    pub fn _sceGpsGetDeviceInfo(dev_info: *mut SceGpsDeviceInfo) -> crate::ctypes::c_int;
    pub fn _sceGpsGetState(state: *mut SceGpsStatus) -> crate::ctypes::c_int;
    pub fn _sceGpsIoctl(
        ioctl_command: SceUInt32,
        arg: *mut SceVoid,
        arg_size: SceSize,
        a4: *mut SceSize,
    ) -> crate::ctypes::c_int;
    pub fn _sceGpsIsDevice() -> crate::ctypes::c_int;
    pub fn _sceGpsOpen(cbid: SceUID) -> crate::ctypes::c_int;
    pub fn _sceGpsResumeCallback() -> crate::ctypes::c_int;
    pub fn _sceGpsSelectDevice(device_type: SceUInt32) -> crate::ctypes::c_int;
    pub fn _sceGpsStart(mode: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    pub fn _sceGpsStop() -> crate::ctypes::c_int;
}
#[link(name = "SceGpuEs4ForDriver_stub", kind = "static")]
#[cfg(feature = "SceGpuEs4ForDriver_stub")]
extern "C" {
    pub fn PVRSRVGetMiscInfoKM(info: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
    pub fn ksceGpuGetRegisterDump(
        dst: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpuMmuMapMemory(
        mmuContext: *mut crate::ctypes::c_void,
        vaddr: u32,
        base: *mut crate::ctypes::c_void,
        size: u32,
        flags: u32,
    ) -> crate::ctypes::c_int;
    pub fn ksceGpuMmuUnmapMemory(
        mmuContext: *mut crate::ctypes::c_void,
        vaddr: u32,
        size: u32,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceGpuEs4_stub", kind = "static")]
#[cfg(feature = "SceGpuEs4_stub")]
extern "C" {}
#[link(name = "SceGxm_stub", kind = "static")]
#[cfg(feature = "SceGxm_stub")]
extern "C" {
    pub fn sceGxmBeginCommandList(context: *mut SceGxmContext) -> crate::ctypes::c_int;
    pub fn sceGxmBeginScene(
        context: *mut SceGxmContext,
        flags: crate::ctypes::c_uint,
        renderTarget: *const SceGxmRenderTarget,
        validRegion: *const SceGxmValidRegion,
        vertexSyncObject: *mut SceGxmSyncObject,
        fragmentSyncObject: *mut SceGxmSyncObject,
        colorSurface: *const SceGxmColorSurface,
        depthStencil: *const SceGxmDepthStencilSurface,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceGetClip(
        surface: *const SceGxmColorSurface,
        xMin: *mut crate::ctypes::c_uint,
        yMin: *mut crate::ctypes::c_uint,
        xMax: *mut crate::ctypes::c_uint,
        yMax: *mut crate::ctypes::c_uint,
    );
    pub fn sceGxmColorSurfaceGetData(
        surface: *const SceGxmColorSurface,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceGxmColorSurfaceGetDitherMode(
        surface: *const SceGxmColorSurface,
    ) -> SceGxmColorSurfaceDitherMode;
    pub fn sceGxmColorSurfaceGetFormat(surface: *const SceGxmColorSurface) -> SceGxmColorFormat;
    pub fn sceGxmColorSurfaceGetGammaMode(
        surface: *const SceGxmColorSurface,
    ) -> SceGxmColorSurfaceGammaMode;
    pub fn sceGxmColorSurfaceGetScaleMode(
        surface: *const SceGxmColorSurface,
    ) -> SceGxmColorSurfaceScaleMode;
    pub fn sceGxmColorSurfaceGetStrideInPixels(
        surface: *const SceGxmColorSurface,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmColorSurfaceGetType(surface: *const SceGxmColorSurface) -> SceGxmColorSurfaceType;
    pub fn sceGxmColorSurfaceInit(
        surface: *mut SceGxmColorSurface,
        colorFormat: SceGxmColorFormat,
        surfaceType: SceGxmColorSurfaceType,
        scaleMode: SceGxmColorSurfaceScaleMode,
        outputRegisterSize: SceGxmOutputRegisterSize,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        strideInPixels: crate::ctypes::c_uint,
        data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceInitDisabled(surface: *mut SceGxmColorSurface)
        -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceIsEnabled(surface: *const SceGxmColorSurface) -> SceBool;
    pub fn sceGxmColorSurfaceSetClip(
        surface: *mut SceGxmColorSurface,
        xMin: crate::ctypes::c_uint,
        yMin: crate::ctypes::c_uint,
        xMax: crate::ctypes::c_uint,
        yMax: crate::ctypes::c_uint,
    );
    pub fn sceGxmColorSurfaceSetData(
        surface: *mut SceGxmColorSurface,
        data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceSetDitherMode(
        surface: *mut SceGxmColorSurface,
        ditherMode: SceGxmColorSurfaceDitherMode,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceSetFormat(
        surface: *mut SceGxmColorSurface,
        format: SceGxmColorFormat,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceSetGammaMode(
        surface: *mut SceGxmColorSurface,
        gammaMode: SceGxmColorSurfaceGammaMode,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmColorSurfaceSetScaleMode(
        surface: *mut SceGxmColorSurface,
        scaleMode: SceGxmColorSurfaceScaleMode,
    );
    pub fn sceGxmCreateContext(
        params: *const SceGxmContextParams,
        context: *mut *mut SceGxmContext,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmCreateDeferredContext(
        params: *const SceGxmDeferredContextParams,
        context: *mut *mut SceGxmContext,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmCreateRenderTarget(
        params: *const SceGxmRenderTargetParams,
        renderTarget: *mut *mut SceGxmRenderTarget,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmDepthStencilSurfaceGetBackgroundDepth(
        surface: *const SceGxmDepthStencilSurface,
    ) -> f32;
    pub fn sceGxmDepthStencilSurfaceGetBackgroundStencil(
        surface: *const SceGxmDepthStencilSurface,
    ) -> crate::ctypes::c_uchar;
    pub fn sceGxmDepthStencilSurfaceGetForceLoadMode(
        surface: *const SceGxmDepthStencilSurface,
    ) -> SceGxmDepthStencilForceLoadMode;
    pub fn sceGxmDepthStencilSurfaceGetForceStoreMode(
        surface: *const SceGxmDepthStencilSurface,
    ) -> SceGxmDepthStencilForceStoreMode;
    pub fn sceGxmDepthStencilSurfaceGetFormat(
        surface: *const SceGxmDepthStencilSurface,
    ) -> SceGxmDepthStencilFormat;
    pub fn sceGxmDepthStencilSurfaceGetStrideInSamples(
        surface: *const SceGxmDepthStencilSurface,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmDepthStencilSurfaceInit(
        surface: *mut SceGxmDepthStencilSurface,
        depthStencilFormat: SceGxmDepthStencilFormat,
        surfaceType: SceGxmDepthStencilSurfaceType,
        strideInSamples: crate::ctypes::c_uint,
        depthData: *mut crate::ctypes::c_void,
        stencilData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmDepthStencilSurfaceInitDisabled(
        surface: *mut SceGxmDepthStencilSurface,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmDepthStencilSurfaceIsEnabled(surface: *const SceGxmDepthStencilSurface)
        -> SceBool;
    pub fn sceGxmDepthStencilSurfaceSetBackgroundDepth(
        surface: *mut SceGxmDepthStencilSurface,
        backgroundDepth: f32,
    );
    pub fn sceGxmDepthStencilSurfaceSetBackgroundStencil(
        surface: *mut SceGxmDepthStencilSurface,
        backgroundStencil: crate::ctypes::c_uchar,
    );
    pub fn sceGxmDepthStencilSurfaceSetForceLoadMode(
        surface: *mut SceGxmDepthStencilSurface,
        forceLoad: SceGxmDepthStencilForceLoadMode,
    );
    pub fn sceGxmDepthStencilSurfaceSetForceStoreMode(
        surface: *mut SceGxmDepthStencilSurface,
        forceStore: SceGxmDepthStencilForceStoreMode,
    );
    pub fn sceGxmDestroyContext(context: *mut SceGxmContext) -> crate::ctypes::c_int;
    pub fn sceGxmDestroyDeferredContext(context: *mut SceGxmContext) -> crate::ctypes::c_int;
    pub fn sceGxmDestroyRenderTarget(renderTarget: *mut SceGxmRenderTarget)
        -> crate::ctypes::c_int;
    pub fn sceGxmDisplayQueueAddEntry(
        oldBuffer: *mut SceGxmSyncObject,
        newBuffer: *mut SceGxmSyncObject,
        callbackData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmDisplayQueueFinish() -> crate::ctypes::c_int;
    pub fn sceGxmDraw(
        context: *mut SceGxmContext,
        primType: SceGxmPrimitiveType,
        indexType: SceGxmIndexFormat,
        indexData: *const crate::ctypes::c_void,
        indexCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmDrawInstanced(
        context: *mut SceGxmContext,
        primType: SceGxmPrimitiveType,
        indexType: SceGxmIndexFormat,
        indexData: *const crate::ctypes::c_void,
        indexCount: crate::ctypes::c_uint,
        indexWrap: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmDrawPrecomputed(
        context: *mut SceGxmContext,
        precomputedDraw: *const SceGxmPrecomputedDraw,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmEndCommandList(
        context: *mut SceGxmContext,
        list: *mut SceGxmCommandList,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmEndScene(
        context: *mut SceGxmContext,
        vertexNotification: *const SceGxmNotification,
        fragmentNotification: *const SceGxmNotification,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmExecuteCommandList(
        context: *mut SceGxmContext,
        list: *mut SceGxmCommandList,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmFinish(context: *mut SceGxmContext);
    pub fn sceGxmFragmentProgramGetProgram(
        fragmentProgram: *const SceGxmFragmentProgram,
    ) -> *const SceGxmProgram;
    pub fn sceGxmGetNotificationRegion() -> *mut crate::ctypes::c_uint;
    pub fn sceGxmGetPrecomputedDrawSize(
        vertexProgram: *const SceGxmVertexProgram,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmGetPrecomputedFragmentStateSize(
        fragmentProgram: *const SceGxmFragmentProgram,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmGetPrecomputedVertexStateSize(
        vertexProgram: *const SceGxmVertexProgram,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmGetRenderTargetMemSize(
        params: *const SceGxmRenderTargetParams,
        driverMemSize: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmInitialize(params: *const SceGxmInitializeParams) -> crate::ctypes::c_int;
    pub fn sceGxmMapFragmentUsseMemory(
        base: *mut crate::ctypes::c_void,
        size: SceSize,
        offset: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmMapMemory(
        base: *mut crate::ctypes::c_void,
        size: SceSize,
        attr: SceGxmMemoryAttribFlags,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmMapVertexUsseMemory(
        base: *mut crate::ctypes::c_void,
        size: SceSize,
        offset: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmMidSceneFlush(
        context: *mut SceGxmContext,
        flags: crate::ctypes::c_uint,
        vertexSyncObject: *mut SceGxmSyncObject,
        vertexNotification: *const SceGxmNotification,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmNotificationWait(notification: *const SceGxmNotification) -> crate::ctypes::c_int;
    pub fn sceGxmPadHeartbeat(
        displaySurface: *const SceGxmColorSurface,
        displaySyncObject: *mut SceGxmSyncObject,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPadTriggerGpuPaTrace() -> crate::ctypes::c_int;
    pub fn sceGxmPopUserMarker(context: *mut SceGxmContext) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedDrawInit(
        precomputedDraw: *mut SceGxmPrecomputedDraw,
        vertexProgram: *const SceGxmVertexProgram,
        memBlock: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedDrawSetAllVertexStreams(
        precomputedDraw: *mut SceGxmPrecomputedDraw,
        streamDataArray: *const *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedDrawSetParams(
        precomputedDraw: *mut SceGxmPrecomputedDraw,
        primType: SceGxmPrimitiveType,
        indexType: SceGxmIndexFormat,
        indexData: *const crate::ctypes::c_void,
        indexCount: crate::ctypes::c_uint,
    );
    pub fn sceGxmPrecomputedDrawSetParamsInstanced(
        precomputedDraw: *mut SceGxmPrecomputedDraw,
        primType: SceGxmPrimitiveType,
        indexType: SceGxmIndexFormat,
        indexData: *const crate::ctypes::c_void,
        indexCount: crate::ctypes::c_uint,
        indexWrap: crate::ctypes::c_uint,
    );
    pub fn sceGxmPrecomputedDrawSetVertexStream(
        precomputedDraw: *mut SceGxmPrecomputedDraw,
        streamIndex: crate::ctypes::c_uint,
        streamData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedFragmentStateGetDefaultUniformBuffer(
        precomputedState: *const SceGxmPrecomputedFragmentState,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceGxmPrecomputedFragmentStateInit(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        fragmentProgram: *const SceGxmFragmentProgram,
        memBlock: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedFragmentStateSetAllAuxiliarySurfaces(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        auxSurfaceArray: *const SceGxmAuxiliarySurface,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedFragmentStateSetAllTextures(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        textureArray: *const SceGxmTexture,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedFragmentStateSetAllUniformBuffers(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        bufferDataArray: *const *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedFragmentStateSetDefaultUniformBuffer(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        defaultBuffer: *mut crate::ctypes::c_void,
    );
    pub fn sceGxmPrecomputedFragmentStateSetTexture(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        textureIndex: crate::ctypes::c_uint,
        texture: *const SceGxmTexture,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedFragmentStateSetUniformBuffer(
        precomputedState: *mut SceGxmPrecomputedFragmentState,
        bufferIndex: crate::ctypes::c_uint,
        bufferData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedVertexStateGetDefaultUniformBuffer(
        precomputedState: *const SceGxmPrecomputedVertexState,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceGxmPrecomputedVertexStateInit(
        precomputedState: *mut SceGxmPrecomputedVertexState,
        vertexProgram: *const SceGxmVertexProgram,
        memBlock: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedVertexStateSetAllTextures(
        precomputedState: *mut SceGxmPrecomputedVertexState,
        textures: *const SceGxmTexture,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedVertexStateSetAllUniformBuffers(
        precomputedState: *mut SceGxmPrecomputedVertexState,
        bufferDataArray: *const *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedVertexStateSetDefaultUniformBuffer(
        precomputedState: *mut SceGxmPrecomputedVertexState,
        defaultBuffer: *mut crate::ctypes::c_void,
    );
    pub fn sceGxmPrecomputedVertexStateSetTexture(
        precomputedState: *mut SceGxmPrecomputedVertexState,
        textureIndex: crate::ctypes::c_uint,
        texture: *const SceGxmTexture,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmPrecomputedVertexStateSetUniformBuffer(
        precomputedState: *mut SceGxmPrecomputedVertexState,
        bufferIndex: crate::ctypes::c_uint,
        bufferData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmProgramCheck(program: *const SceGxmProgram) -> crate::ctypes::c_int;
    pub fn sceGxmProgramFindParameterByName(
        program: *const SceGxmProgram,
        name: *const crate::ctypes::c_char,
    ) -> *const SceGxmProgramParameter;
    pub fn sceGxmProgramFindParameterBySemantic(
        program: *const SceGxmProgram,
        semantic: SceGxmParameterSemantic,
        index: crate::ctypes::c_uint,
    ) -> *const SceGxmProgramParameter;
    pub fn sceGxmProgramGetDefaultUniformBufferSize(
        program: *const SceGxmProgram,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramGetParameter(
        program: *const SceGxmProgram,
        index: crate::ctypes::c_uint,
    ) -> *const SceGxmProgramParameter;
    pub fn sceGxmProgramGetParameterCount(program: *const SceGxmProgram) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramGetSize(program: *const SceGxmProgram) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramGetType(program: *const SceGxmProgram) -> SceGxmProgramType;
    pub fn sceGxmProgramIsDepthReplaceUsed(program: *const SceGxmProgram) -> SceBool;
    pub fn sceGxmProgramIsDiscardUsed(program: *const SceGxmProgram) -> SceBool;
    pub fn sceGxmProgramIsSpriteCoordUsed(program: *const SceGxmProgram) -> SceBool;
    pub fn sceGxmProgramParameterGetArraySize(
        parameter: *const SceGxmProgramParameter,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramParameterGetCategory(
        parameter: *const SceGxmProgramParameter,
    ) -> SceGxmParameterCategory;
    pub fn sceGxmProgramParameterGetComponentCount(
        parameter: *const SceGxmProgramParameter,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramParameterGetContainerIndex(
        parameter: *const SceGxmProgramParameter,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramParameterGetIndex(
        program: *const SceGxmProgram,
        parameter: *const SceGxmProgramParameter,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramParameterGetName(
        parameter: *const SceGxmProgramParameter,
    ) -> *const crate::ctypes::c_char;
    pub fn sceGxmProgramParameterGetResourceIndex(
        parameter: *const SceGxmProgramParameter,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramParameterGetSemantic(
        parameter: *const SceGxmProgramParameter,
    ) -> SceGxmParameterSemantic;
    pub fn sceGxmProgramParameterGetSemanticIndex(
        parameter: *const SceGxmProgramParameter,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmProgramParameterGetType(
        parameter: *const SceGxmProgramParameter,
    ) -> SceGxmParameterType;
    pub fn sceGxmProgramParameterIsSamplerCube(parameter: *const SceGxmProgramParameter)
        -> SceBool;
    pub fn sceGxmPushUserMarker(
        context: *mut SceGxmContext,
        tag: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmRenderTargetGetDriverMemBlock(
        renderTarget: *const SceGxmRenderTarget,
        driverMemBlock: *mut SceUID,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmRenderTargetGetHostMem(
        renderTarget: *const SceGxmRenderTarget,
        hostMem: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmReserveFragmentDefaultUniformBuffer(
        context: *mut SceGxmContext,
        uniformBuffer: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmReserveVertexDefaultUniformBuffer(
        context: *mut SceGxmContext,
        uniformBuffer: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetAuxiliarySurface(
        context: *mut SceGxmContext,
        surfaceIndex: crate::ctypes::c_uint,
        surface: *const SceGxmAuxiliarySurface,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetBackDepthBias(
        context: *mut SceGxmContext,
        factor: crate::ctypes::c_int,
        units: crate::ctypes::c_int,
    );
    pub fn sceGxmSetBackDepthFunc(context: *mut SceGxmContext, depthFunc: SceGxmDepthFunc);
    pub fn sceGxmSetBackDepthWriteEnable(context: *mut SceGxmContext, enable: SceGxmDepthWriteMode);
    pub fn sceGxmSetBackFragmentProgramEnable(
        context: *mut SceGxmContext,
        enable: SceGxmFragmentProgramMode,
    );
    pub fn sceGxmSetBackLineFillLastPixelEnable(
        context: *mut SceGxmContext,
        enable: SceGxmLineFillLastPixelMode,
    );
    pub fn sceGxmSetBackPointLineWidth(context: *mut SceGxmContext, width: crate::ctypes::c_uint);
    pub fn sceGxmSetBackPolygonMode(context: *mut SceGxmContext, mode: SceGxmPolygonMode);
    pub fn sceGxmSetBackStencilFunc(
        context: *mut SceGxmContext,
        func: SceGxmStencilFunc,
        stencilFail: SceGxmStencilOp,
        depthFail: SceGxmStencilOp,
        depthPass: SceGxmStencilOp,
        compareMask: crate::ctypes::c_uchar,
        writeMask: crate::ctypes::c_uchar,
    );
    pub fn sceGxmSetBackStencilRef(context: *mut SceGxmContext, sref: crate::ctypes::c_uint);
    pub fn sceGxmSetBackVisibilityTestEnable(
        context: *mut SceGxmContext,
        enable: SceGxmVisibilityTestMode,
    );
    pub fn sceGxmSetBackVisibilityTestIndex(
        context: *mut SceGxmContext,
        index: crate::ctypes::c_uint,
    );
    pub fn sceGxmSetBackVisibilityTestOp(context: *mut SceGxmContext, op: SceGxmVisibilityTestOp);
    pub fn sceGxmSetCullMode(context: *mut SceGxmContext, mode: SceGxmCullMode);
    pub fn sceGxmSetDefaultRegionClipAndViewport(
        context: *mut SceGxmContext,
        xMax: crate::ctypes::c_uint,
        yMax: crate::ctypes::c_uint,
    );
    pub fn sceGxmSetFragmentDefaultUniformBuffer(
        context: *mut SceGxmContext,
        uniformBuffer: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetFragmentProgram(
        context: *mut SceGxmContext,
        fragmentProgram: *const SceGxmFragmentProgram,
    );
    pub fn sceGxmSetFragmentTexture(
        context: *mut SceGxmContext,
        textureIndex: crate::ctypes::c_uint,
        texture: *const SceGxmTexture,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetFragmentUniformBuffer(
        context: *mut SceGxmContext,
        bufferIndex: crate::ctypes::c_uint,
        bufferData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetFrontDepthBias(
        context: *mut SceGxmContext,
        factor: crate::ctypes::c_int,
        units: crate::ctypes::c_int,
    );
    pub fn sceGxmSetFrontDepthFunc(context: *mut SceGxmContext, depthFunc: SceGxmDepthFunc);
    pub fn sceGxmSetFrontDepthWriteEnable(
        context: *mut SceGxmContext,
        enable: SceGxmDepthWriteMode,
    );
    pub fn sceGxmSetFrontFragmentProgramEnable(
        context: *mut SceGxmContext,
        enable: SceGxmFragmentProgramMode,
    );
    pub fn sceGxmSetFrontLineFillLastPixelEnable(
        context: *mut SceGxmContext,
        enable: SceGxmLineFillLastPixelMode,
    );
    pub fn sceGxmSetFrontPointLineWidth(context: *mut SceGxmContext, width: crate::ctypes::c_uint);
    pub fn sceGxmSetFrontPolygonMode(context: *mut SceGxmContext, mode: SceGxmPolygonMode);
    pub fn sceGxmSetFrontStencilFunc(
        context: *mut SceGxmContext,
        func: SceGxmStencilFunc,
        stencilFail: SceGxmStencilOp,
        depthFail: SceGxmStencilOp,
        depthPass: SceGxmStencilOp,
        compareMask: crate::ctypes::c_uchar,
        writeMask: crate::ctypes::c_uchar,
    );
    pub fn sceGxmSetFrontStencilRef(context: *mut SceGxmContext, sref: crate::ctypes::c_uint);
    pub fn sceGxmSetFrontVisibilityTestEnable(
        context: *mut SceGxmContext,
        enable: SceGxmVisibilityTestMode,
    );
    pub fn sceGxmSetFrontVisibilityTestIndex(
        context: *mut SceGxmContext,
        index: crate::ctypes::c_uint,
    );
    pub fn sceGxmSetFrontVisibilityTestOp(context: *mut SceGxmContext, op: SceGxmVisibilityTestOp);
    pub fn sceGxmSetPrecomputedFragmentState(
        context: *mut SceGxmContext,
        precomputedState: *const SceGxmPrecomputedFragmentState,
    );
    pub fn sceGxmSetPrecomputedVertexState(
        context: *mut SceGxmContext,
        precomputedState: *const SceGxmPrecomputedVertexState,
    );
    pub fn sceGxmSetRegionClip(
        context: *mut SceGxmContext,
        mode: SceGxmRegionClipMode,
        xMin: crate::ctypes::c_uint,
        yMin: crate::ctypes::c_uint,
        xMax: crate::ctypes::c_uint,
        yMax: crate::ctypes::c_uint,
    );
    pub fn sceGxmSetTwoSidedEnable(context: *mut SceGxmContext, enable: SceGxmTwoSidedMode);
    pub fn sceGxmSetUniformDataF(
        uniformBuffer: *mut crate::ctypes::c_void,
        parameter: *const SceGxmProgramParameter,
        componentOffset: crate::ctypes::c_uint,
        componentCount: crate::ctypes::c_uint,
        sourceData: *const f32,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetUserMarker(
        context: *mut SceGxmContext,
        tag: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetValidationEnable(context: *mut SceGxmContext, enable: SceBool);
    pub fn sceGxmSetVertexDefaultUniformBuffer(
        context: *mut SceGxmContext,
        uniformBuffer: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetVertexProgram(
        context: *mut SceGxmContext,
        vertexProgram: *const SceGxmVertexProgram,
    );
    pub fn sceGxmSetVertexStream(
        context: *mut SceGxmContext,
        streamIndex: crate::ctypes::c_uint,
        streamData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetVertexTexture(
        context: *mut SceGxmContext,
        textureIndex: crate::ctypes::c_uint,
        texture: *const SceGxmTexture,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetVertexUniformBuffer(
        context: *mut SceGxmContext,
        bufferIndex: crate::ctypes::c_uint,
        bufferData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetViewport(
        context: *mut SceGxmContext,
        xOffset: f32,
        xScale: f32,
        yOffset: f32,
        yScale: f32,
        zOffset: f32,
        zScale: f32,
    );
    pub fn sceGxmSetViewportEnable(context: *mut SceGxmContext, enable: SceGxmViewportMode);
    pub fn sceGxmSetVisibilityBuffer(
        context: *mut SceGxmContext,
        bufferBase: *mut crate::ctypes::c_void,
        stridePerCore: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSetWBufferEnable(context: *mut SceGxmContext, enable: SceGxmWBufferMode);
    pub fn sceGxmSetWClampEnable(context: *mut SceGxmContext, enable: SceGxmWClampMode);
    pub fn sceGxmSetWClampValue(context: *mut SceGxmContext, clampValue: f32);
    pub fn sceGxmSetYuvProfile(
        context: *mut SceGxmContext,
        index: crate::ctypes::c_uint,
        profile: SceGxmYuvProfile,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherAddRefFragmentProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        fragmentProgram: *mut SceGxmFragmentProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherAddRefVertexProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        vertexProgram: *mut SceGxmVertexProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherCreate(
        params: *const SceGxmShaderPatcherParams,
        shaderPatcher: *mut *mut SceGxmShaderPatcher,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherCreateFragmentProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        programId: SceGxmShaderPatcherId,
        outputFormat: SceGxmOutputRegisterFormat,
        multisampleMode: SceGxmMultisampleMode,
        blendInfo: *const SceGxmBlendInfo,
        vertexProgram: *const SceGxmProgram,
        fragmentProgram: *mut *mut SceGxmFragmentProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherCreateMaskUpdateFragmentProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        fragmentProgram: *mut *mut SceGxmFragmentProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherCreateVertexProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        programId: SceGxmShaderPatcherId,
        attributes: *const SceGxmVertexAttribute,
        attributeCount: crate::ctypes::c_uint,
        streams: *const SceGxmVertexStream,
        streamCount: crate::ctypes::c_uint,
        vertexProgram: *mut *mut SceGxmVertexProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherDestroy(
        shaderPatcher: *mut SceGxmShaderPatcher,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherForceUnregisterProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        programId: SceGxmShaderPatcherId,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherGetBufferMemAllocated(
        shaderPatcher: *const SceGxmShaderPatcher,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmShaderPatcherGetFragmentProgramRefCount(
        shaderPatcher: *mut SceGxmShaderPatcher,
        fragmentProgram: *mut SceGxmFragmentProgram,
        count: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherGetFragmentUsseMemAllocated(
        shaderPatcher: *const SceGxmShaderPatcher,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmShaderPatcherGetHostMemAllocated(
        shaderPatcher: *const SceGxmShaderPatcher,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmShaderPatcherGetProgramFromId(
        programId: SceGxmShaderPatcherId,
    ) -> *const SceGxmProgram;
    pub fn sceGxmShaderPatcherGetUserData(
        shaderPatcher: *mut SceGxmShaderPatcher,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceGxmShaderPatcherGetVertexProgramRefCount(
        shaderPatcher: *mut SceGxmShaderPatcher,
        fragmentProgram: *mut SceGxmVertexProgram,
        count: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherGetVertexUsseMemAllocated(
        shaderPatcher: *const SceGxmShaderPatcher,
    ) -> crate::ctypes::c_uint;
    pub fn sceGxmShaderPatcherRegisterProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        programHeader: *const SceGxmProgram,
        programId: *mut SceGxmShaderPatcherId,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherReleaseFragmentProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        fragmentProgram: *mut SceGxmFragmentProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherReleaseVertexProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        vertexProgram: *mut SceGxmVertexProgram,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherSetAuxiliarySurface(
        shaderPatcher: *mut SceGxmShaderPatcher,
        auxSurfaceIndex: crate::ctypes::c_uint,
        auxSurface: *const SceGxmAuxiliarySurface,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherSetUserData(
        shaderPatcher: *mut SceGxmShaderPatcher,
        userData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmShaderPatcherUnregisterProgram(
        shaderPatcher: *mut SceGxmShaderPatcher,
        programId: SceGxmShaderPatcherId,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmSyncObjectCreate(syncObject: *mut *mut SceGxmSyncObject) -> crate::ctypes::c_int;
    pub fn sceGxmSyncObjectDestroy(syncObject: *mut SceGxmSyncObject) -> crate::ctypes::c_int;
    pub fn sceGxmTerminate() -> crate::ctypes::c_int;
    pub fn sceGxmTextureGetData(texture: *const SceGxmTexture) -> *mut crate::ctypes::c_void;
    pub fn sceGxmTextureGetFormat(texture: *const SceGxmTexture) -> SceGxmTextureFormat;
    pub fn sceGxmTextureGetGammaMode(texture: *const SceGxmTexture) -> SceGxmTextureGammaMode;
    pub fn sceGxmTextureGetHeight(texture: *const SceGxmTexture) -> crate::ctypes::c_uint;
    pub fn sceGxmTextureGetLodBias(texture: *const SceGxmTexture) -> crate::ctypes::c_uint;
    pub fn sceGxmTextureGetMagFilter(texture: *const SceGxmTexture) -> SceGxmTextureFilter;
    pub fn sceGxmTextureGetMinFilter(texture: *const SceGxmTexture) -> SceGxmTextureFilter;
    pub fn sceGxmTextureGetMipFilter(texture: *const SceGxmTexture) -> SceGxmTextureMipFilter;
    pub fn sceGxmTextureGetMipmapCount(texture: *const SceGxmTexture) -> crate::ctypes::c_uint;
    pub fn sceGxmTextureGetPalette(texture: *const SceGxmTexture) -> *mut crate::ctypes::c_void;
    pub fn sceGxmTextureGetStride(texture: *const SceGxmTexture) -> crate::ctypes::c_uint;
    pub fn sceGxmTextureGetType(texture: *const SceGxmTexture) -> SceGxmTextureType;
    pub fn sceGxmTextureGetUAddrMode(texture: *const SceGxmTexture) -> SceGxmTextureAddrMode;
    pub fn sceGxmTextureGetVAddrMode(texture: *const SceGxmTexture) -> SceGxmTextureAddrMode;
    pub fn sceGxmTextureGetWidth(texture: *const SceGxmTexture) -> crate::ctypes::c_uint;
    pub fn sceGxmTextureInitCube(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
        texFormat: SceGxmTextureFormat,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        mipCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureInitLinear(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
        texFormat: SceGxmTextureFormat,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        mipCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureInitLinearStrided(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
        texFormat: SceGxmTextureFormat,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        byteStride: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureInitSwizzled(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
        texFormat: SceGxmTextureFormat,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        mipCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureInitSwizzledArbitrary(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
        texFormat: SceGxmTextureFormat,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        mipCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureInitTiled(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
        texFormat: SceGxmTextureFormat,
        width: crate::ctypes::c_uint,
        height: crate::ctypes::c_uint,
        mipCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetData(
        texture: *mut SceGxmTexture,
        data: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetFormat(
        texture: *mut SceGxmTexture,
        texFormat: SceGxmTextureFormat,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetGammaMode(
        texture: *mut SceGxmTexture,
        gammaMode: SceGxmTextureGammaMode,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetHeight(
        texture: *mut SceGxmTexture,
        height: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetLodBias(
        texture: *mut SceGxmTexture,
        bias: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetMagFilter(
        texture: *mut SceGxmTexture,
        magFilter: SceGxmTextureFilter,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetMinFilter(
        texture: *mut SceGxmTexture,
        minFilter: SceGxmTextureFilter,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetMipFilter(
        texture: *mut SceGxmTexture,
        mipFilter: SceGxmTextureMipFilter,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetMipmapCount(
        texture: *mut SceGxmTexture,
        mipCount: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetPalette(
        texture: *mut SceGxmTexture,
        paletteData: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetStride(
        texture: *mut SceGxmTexture,
        byteStride: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetUAddrMode(
        texture: *mut SceGxmTexture,
        addrMode: SceGxmTextureAddrMode,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetVAddrMode(
        texture: *mut SceGxmTexture,
        addrMode: SceGxmTextureAddrMode,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureSetWidth(
        texture: *mut SceGxmTexture,
        width: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTextureValidate(texture: *const SceGxmTexture) -> crate::ctypes::c_int;
    pub fn sceGxmTransferCopy(
        width: u32,
        height: u32,
        colorKeyValue: u32,
        colorKeyMask: u32,
        colorKeyMode: SceGxmTransferColorKeyMode,
        srcFormat: SceGxmTransferFormat,
        srcType: SceGxmTransferType,
        srcAddress: *const crate::ctypes::c_void,
        srcX: u32,
        srcY: u32,
        srcStride: i32,
        destFormat: SceGxmTransferFormat,
        destType: SceGxmTransferType,
        destAddress: *mut crate::ctypes::c_void,
        destX: u32,
        destY: u32,
        destStride: i32,
        syncObject: *mut SceGxmSyncObject,
        syncFlags: u32,
        notification: *const SceGxmNotification,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTransferDownscale(
        srcFormat: SceGxmTransferFormat,
        srcAddress: *const crate::ctypes::c_void,
        srcX: crate::ctypes::c_uint,
        srcY: crate::ctypes::c_uint,
        srcWidth: crate::ctypes::c_uint,
        srcHeight: crate::ctypes::c_uint,
        srcStride: crate::ctypes::c_int,
        destFormat: SceGxmTransferFormat,
        destAddress: *mut crate::ctypes::c_void,
        destX: crate::ctypes::c_uint,
        destY: crate::ctypes::c_uint,
        destStride: crate::ctypes::c_int,
        syncObject: *mut SceGxmSyncObject,
        syncFlags: crate::ctypes::c_uint,
        notification: *const SceGxmNotification,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTransferFill(
        color: u32,
        destFormat: SceGxmTransferFormat,
        destAddress: *mut crate::ctypes::c_void,
        destX: u32,
        destY: u32,
        destWidth: u32,
        destHeight: u32,
        destStride: i32,
        syncObject: *mut SceGxmSyncObject,
        syncFlags: u32,
        notification: *const SceGxmNotification,
    ) -> crate::ctypes::c_int;
    pub fn sceGxmTransferFinish() -> crate::ctypes::c_int;
    pub fn sceGxmUnmapFragmentUsseMemory(base: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
    pub fn sceGxmUnmapMemory(base: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
    pub fn sceGxmUnmapVertexUsseMemory(base: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
    pub fn sceGxmVertexProgramGetProgram(
        vertexProgram: *const SceGxmVertexProgram,
    ) -> *const SceGxmProgram;
    pub fn sceGxmVshInitialize(params: *const SceGxmInitializeParams) -> crate::ctypes::c_int;
}
#[link(name = "SceHandwriting_stub", kind = "static")]
#[cfg(feature = "SceHandwriting_stub")]
extern "C" {}
#[link(name = "SceHidForDriver_stub", kind = "static")]
#[cfg(feature = "SceHidForDriver_stub")]
extern "C" {}
#[link(name = "SceHid_stub", kind = "static")]
#[cfg(feature = "SceHid_stub")]
extern "C" {
    #[doc = "Enumerate hid keyboards.\n\n # Arguments\n\n* `handle` (direction out) - Buffer to receive keyboard hid handles.\n * `count` (direction in) - Number of keyboards to enumerate"]
    pub fn sceHidKeyboardEnumerate(
        handle: *mut crate::ctypes::c_int,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get hid keyboard reports (non-blocking).\n\n # Arguments\n\n* `handle` (direction in) - Hid handle.\n * `reports` (direction in) - Buffer to receive reports.\n * `nReports` (direction in) - Number of reports to receive."]
    pub fn sceHidKeyboardPeek(
        handle: SceUInt32,
        reports: *mut *mut SceHidKeyboardReport,
        nReports: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get hid keyboard reports (blocking).\n\n # Arguments\n\n* `handle` (direction in) - Hid handle.\n * `reports` (direction in) - Buffer to receive reports.\n * `nReports` (direction in) - Number of reports to receive."]
    pub fn sceHidKeyboardRead(
        handle: SceUInt32,
        reports: *mut *mut SceHidKeyboardReport,
        nReports: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Enumerate hid mice.\n\n # Arguments\n\n* `handle` (direction out) - Buffer to receive mouse hid handles.\n * `count` (direction in) - Number of mice to enumerate"]
    pub fn sceHidMouseEnumerate(
        handle: *mut crate::ctypes::c_int,
        count: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get hid mouse reports.\n\n # Arguments\n\n* `handle` (direction in) - Hid handle.\n * `reports` (direction in) - Buffer to receive reports.\n * `nReports` (direction in) - Number of reports to receive."]
    pub fn sceHidMouseRead(
        handle: SceUInt32,
        reports: *mut *mut SceHidMouseReport,
        nReports: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceHttp_stub", kind = "static")]
#[cfg(feature = "SceHttp_stub")]
extern "C" {
    pub fn sceHttpAbortRequest(reqId: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceHttpAddCookie(
        url: *const crate::ctypes::c_char,
        cookie: *const crate::ctypes::c_char,
        cookieLength: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpAddRequestHeader(
        id: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
        value: *const crate::ctypes::c_char,
        mode: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpCreateConnection(
        tmplId: crate::ctypes::c_int,
        serverName: *const crate::ctypes::c_char,
        scheme: *const crate::ctypes::c_char,
        port: crate::ctypes::c_ushort,
        enableKeepalive: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpCreateConnectionWithURL(
        tmplId: crate::ctypes::c_int,
        url: *const crate::ctypes::c_char,
        enableKeepalive: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpCreateRequest(
        connId: crate::ctypes::c_int,
        method: crate::ctypes::c_int,
        path: *const crate::ctypes::c_char,
        contentLength: crate::ctypes::c_ulonglong,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpCreateRequestWithURL(
        connId: crate::ctypes::c_int,
        method: crate::ctypes::c_int,
        url: *const crate::ctypes::c_char,
        contentLength: crate::ctypes::c_ulonglong,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpCreateTemplate(
        userAgent: *const crate::ctypes::c_char,
        httpVer: crate::ctypes::c_int,
        autoProxyConf: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpDeleteConnection(connId: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceHttpDeleteRequest(reqId: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceHttpDeleteTemplate(tmplId: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceHttpGetAllResponseHeaders(
        reqId: crate::ctypes::c_int,
        header: *mut *mut crate::ctypes::c_char,
        headerSize: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetAuthEnabled(
        id: crate::ctypes::c_int,
        enable: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetAutoRedirect(
        id: crate::ctypes::c_int,
        enable: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetCookie(
        url: *const crate::ctypes::c_char,
        cookie: *mut crate::ctypes::c_char,
        cookieLength: *mut crate::ctypes::c_uint,
        prepare: crate::ctypes::c_uint,
        secure: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetCookieEnabled(
        id: crate::ctypes::c_int,
        enable: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetMemoryPoolStats(
        currentStat: *mut SceHttpMemoryPoolStats,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetResponseContentLength(
        reqId: crate::ctypes::c_int,
        contentLength: *mut crate::ctypes::c_ulonglong,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpGetStatusCode(
        reqId: crate::ctypes::c_int,
        statusCode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpInit(poolSize: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    pub fn sceHttpParseResponseHeader(
        header: *const crate::ctypes::c_char,
        headerLen: crate::ctypes::c_uint,
        fieldStr: *const crate::ctypes::c_char,
        fieldValue: *mut *const crate::ctypes::c_char,
        valueLen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpParseStatusLine(
        statusLine: *const crate::ctypes::c_char,
        lineLen: crate::ctypes::c_uint,
        httpMajorVer: *mut crate::ctypes::c_int,
        httpMinorVer: *mut crate::ctypes::c_int,
        responseCode: *mut crate::ctypes::c_int,
        reasonPhrase: *mut *const crate::ctypes::c_char,
        phraseLen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpReadData(
        reqId: crate::ctypes::c_int,
        data: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpRemoveRequestHeader(
        id: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSendRequest(
        reqId: crate::ctypes::c_int,
        postData: *const crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetAuthEnabled(
        id: crate::ctypes::c_int,
        enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetAuthInfoCallback(
        id: crate::ctypes::c_int,
        cbfunc: SceHttpAuthInfoCallback,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetAutoRedirect(
        id: crate::ctypes::c_int,
        enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetConnectTimeOut(
        id: crate::ctypes::c_int,
        usec: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetCookieEnabled(
        id: crate::ctypes::c_int,
        enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetCookieRecvCallback(
        id: crate::ctypes::c_int,
        cbfunc: SceHttpCookieRecvCallback,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetCookieSendCallback(
        id: crate::ctypes::c_int,
        cbfunc: SceHttpCookieSendCallback,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetRecvTimeOut(
        id: crate::ctypes::c_int,
        usec: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetRedirectCallback(
        id: crate::ctypes::c_int,
        cbfunc: SceHttpRedirectCallback,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetRequestContentLength(
        id: crate::ctypes::c_int,
        contentLength: crate::ctypes::c_ulonglong,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetResolveRetry(
        id: crate::ctypes::c_int,
        retry: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetResolveTimeOut(
        id: crate::ctypes::c_int,
        usec: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetResponseHeaderMaxSize(
        id: crate::ctypes::c_int,
        headerSize: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpSetSendTimeOut(
        id: crate::ctypes::c_int,
        usec: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpTerm() -> crate::ctypes::c_int;
    pub fn sceHttpUriBuild(
        out: *mut crate::ctypes::c_char,
        require: *mut crate::ctypes::c_uint,
        prepare: crate::ctypes::c_uint,
        srcElement: *const SceHttpUriElement,
        option: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpUriEscape(
        out: *mut crate::ctypes::c_char,
        require: *mut crate::ctypes::c_uint,
        prepare: crate::ctypes::c_uint,
        in_: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpUriMerge(
        mergedUrl: *mut crate::ctypes::c_char,
        url: *const crate::ctypes::c_char,
        relativeUrl: *const crate::ctypes::c_char,
        require: *mut crate::ctypes::c_uint,
        prepare: crate::ctypes::c_uint,
        option: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpUriParse(
        out: *mut SceHttpUriElement,
        srcUrl: *const crate::ctypes::c_char,
        pool: *mut crate::ctypes::c_void,
        require: *mut crate::ctypes::c_uint,
        prepare: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpUriSweepPath(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        srcSize: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpUriUnescape(
        out: *mut crate::ctypes::c_char,
        require: *mut crate::ctypes::c_uint,
        prepare: crate::ctypes::c_uint,
        in_: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpsDisableOption(sslFlags: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    pub fn sceHttpsEnableOption(sslFlags: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    pub fn sceHttpsFreeCaList(caList: *mut SceHttpsCaList) -> crate::ctypes::c_int;
    pub fn sceHttpsGetCaList(caList: *mut SceHttpsCaList) -> crate::ctypes::c_int;
    pub fn sceHttpsGetSslError(
        id: crate::ctypes::c_int,
        errNum: *mut crate::ctypes::c_int,
        detail: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Register RootCA certificate for HTTPS authentication\n\n # Arguments\n\n* `caCertNum` (direction in) - - Number of elements of the list referncing to RootCA certificate\n * `caList` (direction in) - - List referencing to RootCA certificate\n * `cert` (direction in) - - Client certificate\n * `privKey` (direction in) - - Private key\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** <b>SCE_SYSMODULE_HTTPS</b> module must be loaded with ::sceSysmoduleLoadModule to use this function."]
    pub fn sceHttpsLoadCert(
        caCertNum: crate::ctypes::c_int,
        caList: *mut *const SceHttpsData,
        cert: *const SceHttpsData,
        privKey: *const SceHttpsData,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpsSetSslCallback(
        id: crate::ctypes::c_int,
        cbfunc: SceHttpsCallback,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceHttpsUnloadCert() -> crate::ctypes::c_int;
}
#[link(name = "SceI2cForDriver_stub", kind = "static")]
#[cfg(feature = "SceI2cForDriver_stub")]
extern "C" {
    pub fn ksceI2cInit(bus: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceI2cReset(bus: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceI2cSetDebugHandlers(
        bus: crate::ctypes::c_int,
        debug_handlers: *mut SceI2cDebugHandlers,
    ) -> crate::ctypes::c_int;
    pub fn ksceI2cTransferRead(
        bus: crate::ctypes::c_int,
        addr: crate::ctypes::c_uint,
        buffer: *mut crate::ctypes::c_uchar,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceI2cTransferWrite(
        bus: crate::ctypes::c_int,
        addr: crate::ctypes::c_uint,
        buffer: *const crate::ctypes::c_uchar,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceI2cTransferWriteRead(
        bus: crate::ctypes::c_int,
        write_addr: crate::ctypes::c_uint,
        write_buffer: *mut crate::ctypes::c_uchar,
        write_size: crate::ctypes::c_int,
        read_addr: crate::ctypes::c_uint,
        read_buffer: *mut crate::ctypes::c_uchar,
        read_size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceIdStorageForDriver_stub", kind = "static")]
#[cfg(feature = "SceIdStorageForDriver_stub")]
extern "C" {
    #[doc = "# Arguments\n\n* `leafnum` (direction in) - - The read target leaf number\n * `buf` (direction out) - - The leaf data buffer pointer, size is 512 byte\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceIdStorageReadLeaf(
        leafnum: SceSize,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `leafnum` (direction in) - - The write target leaf number\n * `buf` (direction in) - - The leaf data buffer pointer, size is 512 byte\n\n # Returns\n\n0 on success, < 0 on error.\n\n note - Writing to leaf requires manufacturing mode."]
    pub fn ksceIdStorageWriteLeaf(
        leafnum: SceSize,
        buf: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceIftuForDriver_stub", kind = "static")]
#[cfg(feature = "SceIftuForDriver_stub")]
extern "C" {
    pub fn ksceIftuCsc(
        dst: *mut SceIftuFrameBuf,
        src: *mut SceIftuPlaneState,
        params: *mut SceIftuConvParams,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceIme_stub", kind = "static")]
#[cfg(feature = "SceIme_stub")]
extern "C" {
    pub fn sceImeClose() -> SceInt32;
    pub fn sceImeOpen(param: *const SceImeParam) -> SceInt32;
    pub fn sceImeSetCaret(caret: *const SceImeCaret) -> SceInt32;
    pub fn sceImeSetPreeditGeometry(preedit: *const SceImePreeditGeometry) -> SceInt32;
    pub fn sceImeSetText(text: *const SceWChar16, length: SceUInt32) -> SceInt32;
    pub fn sceImeUpdate() -> SceInt32;
}
#[link(name = "SceIncomingDialog_stub", kind = "static")]
#[cfg(feature = "SceIncomingDialog_stub")]
extern "C" {
    #[doc = "Close incoming dialog."]
    pub fn sceIncomingDialogClose() -> SceInt32;
    #[doc = "Finish incoming dialog library"]
    pub fn sceIncomingDialogFinish() -> SceInt32;
    #[doc = "Returns current status of incoming dialog."]
    pub fn sceIncomingDialogGetStatus() -> SceInt32;
    #[doc = "Initialize incoming dialog library, init_type must be 1."]
    pub fn sceIncomingDialogInitialize(init_type: crate::ctypes::c_int) -> SceInt32;
    #[doc = "Open incoming dialog."]
    pub fn sceIncomingDialogOpen(dialogParam: *mut SceIncomingDialogParam) -> SceInt32;
    #[doc = "Force exit to LiveArea and show dialog window"]
    pub fn sceIncomingDialogSwitchToDialog() -> SceInt32;
}
#[link(name = "SceIntrmgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceIntrmgrForDriver_stub")]
extern "C" {
    pub fn ksceKernelClearIntrPending(intr_code: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceKernelDisableIntr(intr_code: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceKernelDisableSubIntr(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelEnableIntr(intr_code: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceKernelEnableSubIntr(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetIntrPriority(
        intr_code: crate::ctypes::c_int,
        priority: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetIntrTarget(
        intr_code: crate::ctypes::c_int,
        cpu_target_list: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelIsIntrAllowedInCurrentContext(
        intr_code: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelIsIntrPending(intr_code: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceKernelRegisterIntrHandler(
        intr_code: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
        interrupt_type: crate::ctypes::c_int,
        handler: SceKernelIntrHandler,
        user_ctx: *mut crate::ctypes::c_void,
        priority: crate::ctypes::c_int,
        target_cpu: crate::ctypes::c_int,
        opt: *mut SceKernelIntrOptParam,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelRegisterSubIntrHandler(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
        handler: SceKernelSubIntrHandler,
        register_arg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelReleaseIntrHandler(intr_code: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceKernelReleaseSubIntrHandler(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelResumeIntr(
        intr_code: crate::ctypes::c_int,
        enabled: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelSetIntrPriority(
        intr_code: crate::ctypes::c_int,
        priority: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelSetIntrTarget(
        intr_code: crate::ctypes::c_int,
        cpu_target_list: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelSuspendIntr(
        intr_code: crate::ctypes::c_int,
        enabled: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelTriggerSGI(
        intr_code: crate::ctypes::c_int,
        target_list_filter: crate::ctypes::c_uint,
        cpu_target_list: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelTriggerSubIntr(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
        subintr_arg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceIntrmgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceIntrmgrForKernel_stub")]
extern "C" {}
#[link(name = "SceIofilemgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceIofilemgrForDriver_stub")]
extern "C" {
    #[doc = "Change the status of a file.\n\n # Arguments\n\n* `file` - - The path to the file.\n * `stat` - - A pointer to a ::SceIoStat structure.\n * `bits` - - Bitmask defining which bits to change.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoChstat(
        file: *const crate::ctypes::c_char,
        stat: *mut SceIoStat,
        bits: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Change the status of a file descriptor.\n\n # Arguments\n\n* `fd` - - The file descriptor.\n * `stat` - - A pointer to an io_stat_t structure.\n * `bits` - - Bitmask defining which bits to change.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoChstatByFd(
        fd: SceUID,
        stat: *mut SceIoStat,
        bits: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Delete a descriptor\n\n ```c\n ksceIoClose(fd);\n ```\n\n # Arguments\n\n* `fd` - - File descriptor to close\n # Returns\n\n< 0 on error"]
    pub fn ksceIoClose(fd: SceUID) -> crate::ctypes::c_int;
    #[doc = "Close an opened directory file descriptor\n\n # Arguments\n\n* `fd` - - Already opened file descriptor (using ::ksceIoDopen)\n # Returns\n\n< 0 on error"]
    pub fn ksceIoDclose(fd: SceUID) -> crate::ctypes::c_int;
    #[doc = "Send a devctl command to a device.\n\n # Example: Sending a simple command to a device\n ```c\n SceIoDevInfo info;\n ksceIoDevctl(\"ux0:\", 0x3001, NULL, 0, &info, sizeof(SceIoDevInfo));\n ```\n\n # Arguments\n\n* `dev` - - String for the device to send the devctl to (e.g. \"ux0:\")\n * `cmd` - - The command to send to the device\n * `indata` - - A data block to send to the device, if NULL sends no data\n * `inlen` - - Length of indata, if 0 sends no data\n * `outdata` - - A data block to receive the result of a command, if NULL receives no data\n * `outlen` - - Length of outdata, if 0 receives no data\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceIoDevctl(
        dev: *const crate::ctypes::c_char,
        cmd: crate::ctypes::c_uint,
        indata: *mut crate::ctypes::c_void,
        inlen: crate::ctypes::c_int,
        outdata: *mut crate::ctypes::c_void,
        outlen: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Open a directory\n\n # Example:\n ```c\n int dfd;\n dfd = ksceIoDopen(\"device:/\");\n if(dfd >= 0)\n { Do something with the file descriptor }\n ```\n # Arguments\n\n* `dirname` - - The directory to open for reading.\n # Returns\n\nIf >= 0 then a valid file descriptor, otherwise a Sony error code."]
    pub fn ksceIoDopen(dirname: *const crate::ctypes::c_char) -> SceUID;
    #[doc = "Reads an entry from an opened file descriptor.\n\n # Arguments\n\n* `fd` - - Already opened file descriptor (using ::ksceIoDopen)\n * `dir` - - Pointer to an ::SceIoDirent structure to hold the file information\n\n # Returns\n\nRead status\n - 0 - No more directory entries left\n - > 0 - More directory entries to go\n - < 0 - Error"]
    pub fn ksceIoDread(fd: SceUID, dir: *mut SceIoDirent) -> crate::ctypes::c_int;
    #[doc = "Get file info\n\n # Arguments\n\n* `fd` (direction in) - - file descriptor\n * `pid` (direction in) - - process id\n * `info` (direction out) - - fd info output\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoGetFileInfo(
        fd: SceUID,
        pid: SceUID,
        info: *mut SceIofileInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get global file descriptor\n\n # Arguments\n\n* `vis_level` (direction in) - - unknown, set 5\n * `dst` (direction out) - - fd list output\n * `max_size` (direction in) - - dst array count\n * `res_size` (direction out) - - result array count output\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoGetGUIDFdListForDebugger(
        vis_level: crate::ctypes::c_int,
        dst: *mut SceIoFdInfo,
        max_size: SceSize,
        res_size: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get process file descriptor\n\n # Arguments\n\n* `vis_level` (direction in) - - unknown, set 5\n * `dst` (direction out) - - fd list output\n * `max_size` (direction in) - - dst array count\n * `res_size` (direction out) - - result array count output\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoGetPUIDFdListForDebugger(
        vis_level: crate::ctypes::c_int,
        dst: *mut SceIoFdInfo,
        max_size: SceSize,
        res_size: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get Remote Kernel Process Local Storage Data\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n * `dst` (direction out) - - The pointer of RemoteKPLS output buffer. size is 0x1C.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoGetRemoteKPLSData(
        pid: SceUID,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the status of a file.\n\n # Arguments\n\n* `file` - - The path to the file.\n * `stat` - - A pointer to a ::SceIoStat structure.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoGetstat(
        file: *const crate::ctypes::c_char,
        stat: *mut SceIoStat,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the status of a file descriptor.\n\n # Arguments\n\n* `fd` - - The file descriptor.\n * `stat` - - A pointer to a ::SceIoStat structure.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoGetstatByFd(fd: SceUID, stat: *mut SceIoStat) -> crate::ctypes::c_int;
    #[doc = "Reposition read/write file descriptor offset\n\n # Example:\n ```c\n pos = ksceIoLseek(fd, -10, SCE_SEEK_END);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor with which to seek\n * `offset` - - Relative offset from the start position given by whence\n * `whence` - - One of ::SceIoSeekMode.\n\n # Returns\n\nThe position in the file after the seek."]
    pub fn ksceIoLseek(fd: SceUID, offset: SceOff, whence: crate::ctypes::c_int) -> SceOff;
    #[doc = "Make a directory file\n\n # Arguments\n\n* `dir` - - The path to the directory\n * `mode` - - Access mode (One or more ::SceIoAccessMode).\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn ksceIoMkdir(dir: *const crate::ctypes::c_char, mode: SceMode) -> crate::ctypes::c_int;
    #[doc = "Mounts a device\n\n # Arguments\n\n* `id` (direction in) - Device to mount\n * `path` (direction in) - Where to mount to\n * `permission` (direction in) - Permission flags\n * `a4` - Unknown, set to 0\n * `a5` - Unknown, set to 0\n * `a6` - Unknown, set to 0\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoMount(
        id: crate::ctypes::c_int,
        path: *const crate::ctypes::c_char,
        permission: crate::ctypes::c_int,
        a4: crate::ctypes::c_int,
        a5: crate::ctypes::c_int,
        a6: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Open or create a file for reading or writing\n\n # Example1: Open a file for reading\n ```c\n if(!(fd = ksceIoOpen(\"device:/path/to/file\", SCE_O_RDONLY, 0777)) {\n // error\n }\n ```\n # Example2: Open a file for writing, creating it if it doesn't exist\n ```c\n if(!(fd = ksceIoOpen(\"device:/path/to/file\", SCE_O_WRONLY|SCE_O_CREAT, 0777)) {\n // error\n }\n ```\n\n # Arguments\n\n* `file` - - Pointer to a string holding the name of the file to open\n * `flags` - - Libc styled flags that are or'ed together\n * `mode` - - File access mode (One or more ::SceIoMode).\n # Returns\n\nA non-negative integer is a valid fd, anything else an error"]
    pub fn ksceIoOpen(
        file: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
        mode: SceMode,
    ) -> SceUID;
    #[doc = "Read input at offset\n\n # Example:\n ```c\n bytes_read = ksceIoPread(fd, data, 100, 0x1000);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to read from\n * `data` - - Pointer to the buffer where the read data will be placed\n * `size` - - Size of the read in bytes\n * `offset` - - Offset to read\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoPread(
        fd: SceUID,
        data: *mut crate::ctypes::c_void,
        size: SceSize,
        offset: SceOff,
    ) -> crate::ctypes::c_int;
    #[doc = "Write output at offset\n\n # Example:\n ```c\n bytes_written = ksceIoPwrite(fd, data, 100, 0x1000);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to write to\n * `data` - - Pointer to the data to write\n * `size` - - Size of data to write\n * `offset` - - Offset to write\n\n # Returns\n\nThe number of bytes written"]
    pub fn ksceIoPwrite(
        fd: SceUID,
        data: *const crate::ctypes::c_void,
        size: SceSize,
        offset: SceOff,
    ) -> crate::ctypes::c_int;
    #[doc = "Read input\n\n # Example:\n ```c\n bytes_read = ksceIoRead(fd, data, 100);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to read from\n * `data` - - Pointer to the buffer where the read data will be placed\n * `size` - - Size of the read in bytes\n\n # Returns\n\nThe number of bytes read"]
    pub fn ksceIoRead(
        fd: SceUID,
        data: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Remove directory entry\n\n # Arguments\n\n* `file` - - Path to the file to remove\n # Returns\n\n< 0 on error"]
    pub fn ksceIoRemove(file: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Change the name of a file\n\n # Arguments\n\n* `oldname` - - The old filename\n * `newname` - - The new filename\n # Returns\n\n< 0 on error."]
    pub fn ksceIoRename(
        oldname: *const crate::ctypes::c_char,
        newname: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Remove a directory file\n\n # Arguments\n\n* `path` - - Removes a directory file pointed by the string path\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn ksceIoRmdir(path: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Synchronize the file data on the device.\n\n # Arguments\n\n* `device` - - The device to synchronize (e.g. msfat0:)\n * `unk` - - Unknown"]
    pub fn ksceIoSync(
        device: *const crate::ctypes::c_char,
        unk: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Synchronize the file data for one file\n\n # Arguments\n\n* `fd` - - Opened file descriptor to sync\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoSyncByFd(fd: SceUID) -> crate::ctypes::c_int;
    #[doc = "Unmounts a device\n\n # Arguments\n\n* `id` (direction in) - Device to unmount\n * `a2` (direction in) - Unknown, set to 0\n * `a3` (direction in) - Unknown, set to 0\n * `a4` (direction in) - Unknown, set to 0\n\n # Returns\n\n< 0 on error."]
    pub fn ksceIoUmount(
        id: crate::ctypes::c_int,
        a2: crate::ctypes::c_int,
        a3: crate::ctypes::c_int,
        a4: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Write output\n\n # Example:\n ```c\n bytes_written = ksceIoWrite(fd, data, 100);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to write to\n * `data` - - Pointer to the data to write\n * `size` - - Size of data to write\n\n # Returns\n\nThe number of bytes written"]
    pub fn ksceIoWrite(
        fd: SceUID,
        data: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceIofilemgr_stub", kind = "static")]
#[cfg(feature = "SceIofilemgr_stub")]
extern "C" {
    #[doc = "Cancel an asynchronous operation on a file descriptor.\n\n # Arguments\n\n* `fd` - - The file descriptor to perform cancel on.\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoCancel(fd: SceUID) -> crate::ctypes::c_int;
    #[doc = "Delete a descriptor\n\n ```c\n sceIoClose(fd);\n ```\n\n # Arguments\n\n* `fd` - - File descriptor to close\n # Returns\n\n< 0 on error"]
    pub fn sceIoClose(fd: SceUID) -> crate::ctypes::c_int;
    #[doc = "Close an opened directory file descriptor\n\n # Arguments\n\n* `fd` - - Already opened file descriptor (using ::sceIoDopen)\n # Returns\n\n< 0 on error"]
    pub fn sceIoDclose(fd: SceUID) -> crate::ctypes::c_int;
    pub fn sceIoGetPriority(fd: SceUID) -> crate::ctypes::c_int;
    pub fn sceIoGetProcessDefaultPriority() -> crate::ctypes::c_int;
    pub fn sceIoGetThreadDefaultPriority() -> crate::ctypes::c_int;
    #[doc = "Reposition read/write file descriptor offset (32bit mode)\n\n # Example:\n ```c\n pos = sceIoLseek32(fd, -10, SCE_SEEK_END);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor with which to seek\n * `offset` - - Relative offset from the start position given by whence\n * `whence` - - One of ::SceIoSeekMode.\n\n # Returns\n\nThe position in the file after the seek."]
    pub fn sceIoLseek32(
        fd: SceUID,
        offset: crate::ctypes::c_long,
        whence: crate::ctypes::c_int,
    ) -> crate::ctypes::c_long;
    #[doc = "Read input\n\n # Example:\n ```c\n bytes_read = sceIoRead(fd, data, 100);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to read from\n * `buf` - - Pointer to the buffer where the read data will be placed\n * `nbyte` - - Size of the read in bytes\n\n # Returns\n\nThe number of bytes read"]
    pub fn sceIoRead(fd: SceUID, buf: *mut crate::ctypes::c_void, nbyte: SceSize) -> SceSSize;
    pub fn sceIoSetPriority(fd: SceUID, priority: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceIoSetProcessDefaultPriority(priority: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceIoSetThreadDefaultPriority(priority: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Synchronize the file data for one file\n\n # Arguments\n\n* `fd` - - Opened file descriptor to sync\n * `flag` - - unknown\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoSyncByFd(fd: SceUID, flag: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Write output\n\n # Example:\n ```c\n bytes_written = sceIoWrite(fd, data, 100);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to write to\n * `buf` - - Pointer to the data to write\n * `nbyte` - - Size of data to write\n\n # Returns\n\nThe number of bytes written"]
    pub fn sceIoWrite(fd: SceUID, buf: *const crate::ctypes::c_void, nbyte: SceSize) -> SceSSize;
}
#[link(name = "SceJpegArm_stub", kind = "static")]
#[cfg(feature = "SceJpegArm_stub")]
extern "C" {
    pub fn sceJpegArmDecodeMJpeg(
        pJpeg: *const SceUInt8,
        isize_: SceSize,
        decodeMode: SceInt,
        pRGBA: *mut crate::ctypes::c_void,
        osize: SceSize,
        pCoefBuffer: *mut crate::ctypes::c_void,
        coefBufferSize: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sceJpegArmDecodeMJpegYCbCr(
        pJpeg: *const SceUInt8,
        isize_: SceSize,
        decodeMode: SceInt,
        pYCbCr: *mut SceUInt8,
        osize: SceSize,
        pCoefBuffer: *mut crate::ctypes::c_void,
        coefBufferSize: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sceJpegArmGetOutputInfo(
        pJpeg: *const SceUInt8,
        isize_: SceSize,
        decodeMode: SceInt,
        outputFormat: SceInt,
        pOutputInfo: *mut SceJpegOutputInfo,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceJpegEncArm_stub", kind = "static")]
#[cfg(feature = "SceJpegEncArm_stub")]
extern "C" {
    #[doc = "Execute a JPEG encode.\n\n # Arguments\n\n* `context` (direction in) - - An already initialized ::SceJpegArmEncoderContext.\n * `inBuffer` (direction in) - - An 8 byte aligned memory block of color data.\n\n # Returns\n\nEncoded JPEG size on success, < 0 on error."]
    pub fn sceJpegArmEncoderEncode(
        context: SceJpegArmEncoderContext,
        inBuffer: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Terminate a JPEG encoder.\n\n # Arguments\n\n* `context` (direction in) - - An already initialized ::SceJpegArmEncoderContext.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegArmEncoderEnd(context: SceJpegArmEncoderContext) -> crate::ctypes::c_int;
    #[doc = "Get required size of context memory.\n\n # Returns\n\nRequired size of allocated memory."]
    pub fn sceJpegArmEncoderGetContextSize() -> SceSize;
    #[doc = "Initialize a JPEG encoder.\n\n # Arguments\n\n* `context` (direction in) - - An allocated encoder context of appropriate size.\n * `inWidth` (direction in) - - Input width in pixels.\n * `inHeight` (direction in) - - Input height in pixels.\n * `pixelformat` (direction in) - - One of ::SceJpegArmEncoderPixelFormat.\n * `outBuffer` (direction in) - - A sufficiently sized 8 byte aligned output buffer.\n * `outSize` (direction in) - - Output buffer size in bytes.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegArmEncoderInit(
        context: SceJpegArmEncoderContext,
        inWidth: SceUInt16,
        inHeight: SceUInt16,
        pixelformat: SceJpegArmEncoderPixelFormat,
        outBuffer: *mut crate::ctypes::c_void,
        outSize: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the encoder compression ratio.\n\n # Arguments\n\n* `context` (direction in) - - An already initialized ::SceJpegArmEncoderContext.\n * `ratio` (direction in) - - A value between 1 and 255 (higher = better compression, lower = better speed).\n\n See SCE_JPEGENCARM_DEFAULT_COMP_RATIO for the default compression ratio.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegArmEncoderSetCompressionRatio(
        context: SceJpegArmEncoderContext,
        ratio: SceUInt8,
    ) -> crate::ctypes::c_int;
    #[doc = "Set header used for output file.\n\n # Arguments\n\n* `context` (direction in) - - An already initialized ::SceJpegArmEncoderContext.\n * `mode` (direction in) - - One of ::SceJpegArmEncoderHeaderMode.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegArmEncoderSetHeaderMode(
        context: SceJpegArmEncoderContext,
        mode: SceJpegArmEncoderHeaderMode,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder output address.\n\n # Arguments\n\n* `context` (direction in) - - An already initialized ::SceJpegArmEncoderContext.\n * `outBuffer` (direction in) - - A sufficiently sized 8 byte aligned output buffer.\n * `outSize` (direction in) - - Output buffer size in bytes.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegArmEncoderSetOutputAddr(
        context: SceJpegArmEncoderContext,
        outBuffer: *mut crate::ctypes::c_void,
        outSize: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the region of the image to be encoded as JPEG. The encoded region starts\n from (0,0), which is the top left of the image, and expands outward by regionWidth and regionHeight.\n\n # Arguments\n\n* `context` (direction in) - - An already initialized ::SceJpegArmEncoderContext.\n * `regionWidth` (direction in) - - Width of the region in pixels.\n * `regionHeight` (direction in) - - Height of the region in pixels.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegArmEncoderSetValidRegion(
        context: SceJpegArmEncoderContext,
        regionWidth: SceUInt16,
        regionHeight: SceUInt16,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceJpegEnc_stub", kind = "static")]
#[cfg(feature = "SceJpegEnc_stub")]
extern "C" {
    #[doc = "Execute a color conversion from ARGB to YCbCr\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `outBuffer` (direction in) - - A physical continuous memory block 256 bytes aligned\n * `inBuffer` (direction in) - - A pointer to a valid ARGB buffer\n * `inPitch` (direction in) - - Input pitch value in pixels\n * `inPixelFormat` (direction in) - - A valid ::SceJpegEncoderPixelFormat set of values\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderCsc(
        context: SceJpegEncoderContext,
        outBuffer: *mut crate::ctypes::c_void,
        inBuffer: *const crate::ctypes::c_void,
        inPitch: crate::ctypes::c_int,
        inPixelFormat: SceJpegEncoderPixelFormat,
    ) -> crate::ctypes::c_int;
    #[doc = "Execute a jpeg encode\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `inBuffer` (direction in) - - A physically continuous memory block 256 bytes aligned\n\n # Returns\n\nencoded jpeg size on success, < 0 on error."]
    pub fn sceJpegEncoderEncode(
        context: SceJpegEncoderContext,
        inBuffer: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Terminate a jpeg encoder\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderEnd(context: SceJpegEncoderContext) -> crate::ctypes::c_int;
    #[doc = "Return required free size to allocate a jpeg encoder\n\n # Returns\n\nRequired free memory size in bytes, < 0 on error."]
    pub fn sceJpegEncoderGetContextSize() -> crate::ctypes::c_int;
    #[doc = "Initialize a jpeg encoder\n\n # Arguments\n\n* `context` (direction in) - - A pointer to a big enough allocated memory block\n * `inWidth` (direction in) - - Input width in pixels\n * `inHeight` (direction in) - - Input height in pixels\n * `pixelformat` (direction in) - - A valid ::SceJpegEncoderPixelFormat set of values\n * `outBuffer` (direction in) - - A physically continuous memory block 256 bytes aligned\n * `outSize` (direction in) - - Output size in bytes\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderInit(
        context: SceJpegEncoderContext,
        inWidth: crate::ctypes::c_int,
        inHeight: crate::ctypes::c_int,
        pixelformat: SceJpegEncoderPixelFormat,
        outBuffer: *mut crate::ctypes::c_void,
        outSize: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Initialize a jpeg encoder with param\n\n # Arguments\n\n* `initParam` (direction in) - - A pointer to the initialization parameters\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderInitWithParam(
        context: SceJpegEncoderContext,
        initParam: *const SceJpegEncoderInitParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder compression ratio\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `ratio` (direction in) - - A value between 0 and 255 (higher = better compression, lower = better speed)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderSetCompressionRatio(
        context: SceJpegEncoderContext,
        ratio: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set header used for output file\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `mode` (direction in) - - One of ::SceJpegEncoderHeaderMode\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderSetHeaderMode(
        context: SceJpegEncoderContext,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder output address\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `outBuffer` (direction in) - - A physically continuous memory block 256 bytes aligned\n * `outSize` (direction in) - - Output buffer size in bytes\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderSetOutputAddr(
        context: SceJpegEncoderContext,
        outBuffer: *mut crate::ctypes::c_void,
        outSize: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set encoder valid region (?)\n\n # Arguments\n\n* `context` (direction in) - - A pointer to an already initialized ::SceJpegEncoderContext\n * `inWidth` (direction in) - - Input width in pixels\n * `inHeight` (direction in) - - Input height in pixels\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceJpegEncoderSetValidRegion(
        context: SceJpegEncoderContext,
        inWidth: crate::ctypes::c_int,
        inHeight: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceJpeg_stub", kind = "static")]
#[cfg(feature = "SceJpeg_stub")]
extern "C" {
    pub fn sceJpegDecodeMJpegYCbCr(
        jpegData: *const SceUInt8,
        jpegSize: SceSize,
        mode: SceInt32,
        output: *mut SceUInt8,
        outputSize: SceSize,
        buffer: *mut crate::ctypes::c_void,
        bufferSize: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sceJpegFinishMJpeg() -> crate::ctypes::c_int;
    pub fn sceJpegGetOutputInfo(
        jpegData: *const SceUInt8,
        jpegSize: SceSize,
        format: SceInt32,
        mode: SceInt32,
        output: *mut SceJpegOutputInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceJpegInitMJpeg(decoderCount: SceInt32) -> crate::ctypes::c_int;
    pub fn sceJpegInitMJpegWithParam(params: *const SceJpegMJpegInitParam) -> crate::ctypes::c_int;
    pub fn sceJpegMJpegCsc(
        rgba: *mut SceUInt8,
        yuv: *const SceUInt8,
        yuvSize: SceSize,
        imageWidth: SceInt32,
        format: SceInt32,
        sampling: SceInt32,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceKernelBootimage_stub", kind = "static")]
#[cfg(feature = "SceKernelBootimage_stub")]
extern "C" {}
#[link(name = "SceKernelDmacMgr_stub", kind = "static")]
#[cfg(feature = "SceKernelDmacMgr_stub")]
extern "C" {
    #[doc = "DMA memcpy\n\n # Arguments\n\n* `dst` (direction in) - - Destination\n * `src` (direction in) - - Source\n * `size` (direction in) - - Size\n\n # Returns\n\n< 0 on error."]
    pub fn sceDmacMemcpy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "DMA memset\n\n # Arguments\n\n* `dst` (direction in) - - Destination\n * `ch` (direction in) - - The character\n * `size` (direction in) - - Size\n\n # Returns\n\n< 0 on error."]
    pub fn sceDmacMemset(
        dst: *mut crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        size: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceKernelModulemgr_stub", kind = "static")]
#[cfg(feature = "SceKernelModulemgr_stub")]
extern "C" {
    pub fn _sceKernelCloseModule(
        modid: SceUID,
        args: SceSize,
        argp: *const crate::ctypes::c_void,
        flags: SceUInt32,
    ) -> SceUID;
    pub fn _sceKernelLoadModule(
        module_filename: *const crate::ctypes::c_char,
        flags: SceUInt32,
        option: *const SceKernelLoadModuleOption,
    ) -> SceUID;
    pub fn _sceKernelLoadStartModule(
        module_filename: *const crate::ctypes::c_char,
        args: SceSize,
        argp: *const crate::ctypes::c_void,
        flags: SceUInt32,
    ) -> SceUID;
    pub fn _sceKernelOpenModule(
        module_filename: *const crate::ctypes::c_char,
        args: SceSize,
        argp: *const crate::ctypes::c_void,
        flags: SceUInt32,
    ) -> SceUID;
    pub fn _sceKernelStopModule(
        uid: SceUID,
        args: SceSize,
        argp: *const crate::ctypes::c_void,
        flags: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn _sceKernelStopUnloadModule(
        uid: SceUID,
        args: SceSize,
        argp: *const crate::ctypes::c_void,
        flags: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn _sceKernelUnloadModule(
        uid: SceUID,
        flags: SceUInt32,
        option: *const SceKernelUnloadModuleOption,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelGetAllowedSdkVersionOnSystem() -> SceUInt32;
    pub fn sceKernelGetLibraryInfoByNID(
        modid: SceUID,
        libnid: SceNID,
        info: *mut SceKernelLibraryInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelGetModuleIdByAddr(addr: *mut crate::ctypes::c_void) -> SceUID;
    pub fn sceKernelGetModuleInfo(
        uid: SceUID,
        info: *mut SceKernelModuleInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelGetModuleList(
        type_: SceUInt8,
        uids: *mut SceUID,
        num: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets system firmware information.\n\n # Arguments\n\n* `version` (direction out) - - System sw version.\n\n > **Note:** - If you spoofed the firmware version it will return the spoofed firmware."]
    pub fn sceKernelGetSystemSwVersion(
        version: *mut SceKernelSystemSwVersion,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelIsCalledFromSysModule(lr: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
}
#[link(name = "SceKernelSuspendForDriver_stub", kind = "static")]
#[cfg(feature = "SceKernelSuspendForDriver_stub")]
extern "C" {
    #[doc = "Cancel specified idle timers to prevent entering in power save processing.\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceKernelPowerTickType\n\n # Returns\n\n0"]
    pub fn ksceKernelPowerTick(type_: SceKernelPowerTickType) -> crate::ctypes::c_int;
    #[doc = "Register system event handler\n\n # Arguments\n\n* `name` (direction in) - - Name of handler\n * `handler` (direction in) - - The handler\n * `args` (direction in) - - Handler arguments\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelRegisterSysEventHandler(
        name: *const crate::ctypes::c_char,
        handler: SceSysEventHandler,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceKernelThreadMgr_stub", kind = "static")]
#[cfg(feature = "SceKernelThreadMgr_stub")]
extern "C" {
    #[doc = "Cancel a callback ?\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelCancelCallback(cb: SceUID) -> crate::ctypes::c_int;
    #[doc = "Set the cpu affinity mask of a thread.\n\n # Arguments\n\n* `thid` - - UID of the thread to retrieve affinity mask for.\n * `mask` - - New cpu affinity mask.\n\n # Returns\n\n0 if successful, otherwise the error code."]
    pub fn sceKernelChangeThreadCpuAffinityMask(
        thid: SceUID,
        mask: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Change the threads current priority.\n\n # Arguments\n\n* `thid` - - The ID of the thread (from ::sceKernelCreateThread or ::sceKernelGetThreadId)\n * `priority` - - The new priority (the lower the number the higher the priority)\n\n # Example:\n ```c\n int thid = sceKernelGetThreadId();\n // Change priority of current thread to 16\n sceKernelChangeThreadPriority(thid, 16);\n ```\n\n # Returns\n\n0 if successful, otherwise the error code."]
    pub fn sceKernelChangeThreadPriority(
        thid: SceUID,
        priority: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Check callback ?\n\n # Returns\n\nSomething or another"]
    pub fn sceKernelCheckCallback() -> crate::ctypes::c_int;
    #[doc = "Clear a event flag bit pattern\n\n # Arguments\n\n* `evid` - - The event id returned by ::sceKernelCreateEventFlag\n * `bits` - - The bits to clean\n\n # Returns\n\n< 0 on Error"]
    pub fn sceKernelClearEventFlag(
        evid: SceUID,
        bits: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Close a condition variable\n\n # Arguments\n\n* `condition` - variableid - The condition variable id returned from ::sceKernelCreateCond\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelCloseCond(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Close a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelCloseMutex(mutexid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Close a rwlock\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelCloseRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
    pub fn sceKernelCloseSema(semaid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Create callback\n\n # Example:\n ```c\n int cbid;\n cbid = sceKernelCreateCallback(\"Exit Callback\", 0, exit_cb, NULL);\n ```\n\n # Arguments\n\n* `name` - - A textual name for the callback\n * `attr` - - ?\n * `func` - - A pointer to a function that will be called as the callback\n * `userData` - - User defined data to be passed to the callback.\n\n # Returns\n\n>= 0 A callback id which can be used in subsequent functions, < 0 an error."]
    pub fn sceKernelCreateCallback(
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        func: SceKernelCallbackFunction,
        userData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Delay the current thread by a specified number of microseconds\n\n # Arguments\n\n* `delay` - - Delay in microseconds.\n\n # Example:\n ```c\n sceKernelDelayThread(1000000); // Delay for a second\n ```"]
    pub fn sceKernelDelayThread(delay: SceUInt) -> crate::ctypes::c_int;
    #[doc = "Delay the current thread by a specified number of microseconds and handle any callbacks.\n\n # Arguments\n\n* `delay` - - Delay in microseconds.\n\n # Example:\n ```c\n sceKernelDelayThread(1000000); // Delay for a second\n ```"]
    pub fn sceKernelDelayThreadCB(delay: SceUInt) -> crate::ctypes::c_int;
    #[doc = "Delete a callback\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelDeleteCallback(cb: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a condition variable\n\n # Arguments\n\n* `condition` - variableid - The condition variable id returned from ::sceKernelCreateCond\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelDeleteCond(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Delete an event flag\n\n # Arguments\n\n* `evid` - - The event id returned by ::sceKernelCreateEventFlag.\n\n # Returns\n\n< 0 On error"]
    pub fn sceKernelDeleteEventFlag(evid: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Delete a message pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelDeleteMsgPipe(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelDeleteMutex(mutexid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a rwlock\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelDeleteRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a semaphore\n\n # Arguments\n\n* `semaid` - - The semaid returned from a previous create call.\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelDeleteSema(semaid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Delate a thread\n\n # Arguments\n\n* `thid` - - UID of the thread to be deleted.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelDeleteThread(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Exit a thread and delete itself.\n\n # Arguments\n\n* `status` - - Exit status"]
    pub fn sceKernelExitDeleteThread(status: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Exit a thread\n\n # Arguments\n\n* `status` - - Exit status."]
    pub fn sceKernelExitThread(status: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get the callback count\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n\n # Returns\n\nThe callback count, < 0 on error"]
    pub fn sceKernelGetCallbackCount(cb: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get the process ID of in the running thread.\n\n # Returns\n\nprocess ID of in the running thread"]
    pub fn sceKernelGetProcessId() -> SceUID;
    #[doc = "Get the system time (wide version)\n\n # Returns\n\nThe system time"]
    pub fn sceKernelGetSystemTimeWide() -> SceInt64;
    #[doc = "Retrive the cpu affinity mask of a thread.\n\n # Arguments\n\n* `thid` - - UID of the thread to retrieve affinity mask for.\n\n # Returns\n\ncurrent affinity mask if >= 0, otherwise the error code."]
    pub fn sceKernelGetThreadCpuAffinityMask(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get the free stack size for a thread.\n\n # Arguments\n\n* `thid` - - The thread ID\n\n # Returns\n\nThe free size."]
    pub fn sceKernelGetThreadStackFreeSize(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "sceKernelGetThreadTLSAddr gets an address to a 4 bytes area of TLS memory for the specified thread\n # Arguments\n\n* `thid` - - The UID of the thread to access TLS\n * `key` - - the TLS keyslot index\n # Returns\n\npointer to TLS memory"]
    pub fn sceKernelGetThreadTLSAddr(
        thid: SceUID,
        key: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Get the type of a Threadmgr uid\n\n # Arguments\n\n* `uid` - - The uid to get the type from\n\n # Returns\n\nThe type, < 0 on error"]
    pub fn sceKernelGetThreadmgrUIDClass(uid: SceUID) -> SceKernelIdListType;
    #[doc = "Notify a callback\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n * `arg2` - - Passed as arg2 into the callback function\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelNotifyCallback(cb: SceUID, arg2: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Open a condition variable\n\n # Arguments\n\n* `name` - - The name of the condition variable to open\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelOpenCond(name: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Open a mutex\n\n # Arguments\n\n* `name` - - The name of the mutex to open\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceKernelOpenMutex(name: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Open a rwlock\n\n # Arguments\n\n* `name` - - The name of the rwlock to open\n # Returns\n\nRWLock id on success, < 0 on error"]
    pub fn sceKernelOpenRWLock(name: *const crate::ctypes::c_char) -> SceUID;
    pub fn sceKernelOpenSema(name: *const crate::ctypes::c_char) -> SceUID;
    #[doc = "Poll a semaphore.\n\n # Arguments\n\n* `semaid` - - UID of the semaphore to poll.\n * `signal` - - The value to test for.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelPollSema(semaid: SceUID, signal: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Send a signal to the thread specified by thid. Note that it can send a signal to the current thread as well.\n\n # Arguments\n\n* `thid` - - the id of the thread to send a signal to\n # Returns\n\n0 on success\n SCE_KERNEL_ERROR_ALREADY_SENT if the last signal was not consumed by sceKernelWaitSignal"]
    pub fn sceKernelSendSignal(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Set an event flag bit pattern.\n\n # Arguments\n\n* `evid` - - The event id returned by ::sceKernelCreateEventFlag.\n * `bits` - - The bit pattern to set.\n\n # Returns\n\n< 0 On error"]
    pub fn sceKernelSetEventFlag(evid: SceUID, bits: crate::ctypes::c_uint)
        -> crate::ctypes::c_int;
    #[doc = "Signals a condition variable\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::sceKernelCreateCond\n # Returns\n\n< 0 On error."]
    pub fn sceKernelSignalCond(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Signals a condition variable to all threads waiting for it\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::sceKernelCreateCond\n # Returns\n\n< 0 On error."]
    pub fn sceKernelSignalCondAll(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Signals a condition variable to a specific thread waiting for it\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::sceKernelCreateCond\n * `threadId` - - The thread id returned from ::sceKernelCreateThread\n # Returns\n\n< 0 On error."]
    pub fn sceKernelSignalCondTo(condId: SceUID, threadId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Send a signal to a semaphore\n\n # Example:\n ```c\n // Signal the sema\n sceKernelSignalSema(semaid, 1);\n ```\n\n # Arguments\n\n* `semaid` - - The sema id returned from ::sceKernelCreateSema\n * `signal` - - The amount to signal the sema (i.e. if 2 then increment the sema by 2)\n\n # Returns\n\n< 0 On error."]
    pub fn sceKernelSignalSema(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Try to lock a mutex (non-blocking)\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n * `lockCount` - - The value to increment to the lock count of the mutex\n # Returns\n\n< 0 On error."]
    pub fn sceKernelTryLockMutex(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Try to lock a rwlock with read access (non-blocking)\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelTryLockReadRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Try to lock a rwlock with write access (non-blocking)\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelTryLockWriteRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Try to unlock a mutex (non-blocking)\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n * `unlockCount` - - The value to decrement to the lock count of the mutex\n # Returns\n\n< 0 On error."]
    pub fn sceKernelUnlockMutex(
        mutexid: SceUID,
        unlockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Try to unlock a rwlock with read access (non-blocking)\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelUnlockReadRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Try to unlock a rwlock with write access (non-blocking)\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelUnlockWriteRWLock(rwlock_id: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "SceKernelUtilsForDriver_stub", kind = "static")]
#[cfg(feature = "SceKernelUtilsForDriver_stub")]
extern "C" {
    pub fn ksceAesDecrypt1(
        ctx: *mut SceAesContext,
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceAesDecrypt2(
        ctx: *mut SceAesContext,
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceAesEncrypt1(
        ctx: *mut SceAesContext,
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceAesEncrypt2(
        ctx: *mut SceAesContext,
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `ctx` (direction out) - - out key data, etc...\n * `blocksize` (direction in) - - 128 or 192 or 256\n * `keysize` (direction in) - - 128 or 192 or 256\n * `key` (direction in) - - key data\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceAesInit1(
        ctx: *mut SceAesContext,
        blocksize: SceSize,
        keysize: SceSize,
        key: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceAesInit2(
        ctx: *mut SceAesContext,
        blocksize: SceSize,
        keysize: SceSize,
        key: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceAesInit3(
        ctx: *mut SceAesContext,
        blocksize: SceSize,
        keysize: SceSize,
        key: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `dst` (direction out) - - dst buf\n * `dst_size` (direction in) - - dst buf size\n * `src` (direction in) - - Deflate compressed data\n * `next` (direction out) - - next data\n\n # Returns\n\ndecompressed size on success, < 0 on error."]
    pub fn ksceDeflateDecompress(
        dst: *mut crate::ctypes::c_void,
        dst_size: SceSize,
        src: *const crate::ctypes::c_void,
        next: *mut *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceDeflateDecompressPartial(
        dst: *mut crate::ctypes::c_void,
        dst_size: SceSize,
        src: *const crate::ctypes::c_void,
        next: *mut *const crate::ctypes::c_void,
        cbInfo: *mut SceDeflatePartialInputParam,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `dst` (direction out) - - dst buf\n * `dst_size` (direction in) - - dst buf size\n * `src` (direction in) - - Gzip compressed data\n * `crc32` (direction out) - - crc32 when decompressed\n\n # Returns\n\ndecompressed size on success, < 0 on error."]
    pub fn ksceGzipDecompress(
        dst: *mut crate::ctypes::c_void,
        dst_size: SceSize,
        src: *const crate::ctypes::c_void,
        crc32: *mut u32,
    ) -> crate::ctypes::c_int;
    #[doc = "Get comment string address\n\n # Arguments\n\n* `src` (direction in) - - Gzip compressed data\n\n # Returns\n\nstring address on success, NULL on error."]
    pub fn ksceGzipGetComment(src: *const crate::ctypes::c_void) -> *const crate::ctypes::c_char;
    #[doc = "Get compressed data start address\n\n # Arguments\n\n* `src` (direction in) - - Gzip compressed data\n\n # Returns\n\ncompressed data address on success, NULL on error."]
    pub fn ksceGzipGetCompressedData(
        src: *const crate::ctypes::c_void,
    ) -> *const crate::ctypes::c_void;
    #[doc = "Get filename etc. in Gzip data\n\n # Arguments\n\n* `src` (direction in) - - Gzip compressed data\n * `extra` (direction out) - - Get information on extra-field\n * `name` (direction out) - - Get filename information\n * `comment` (direction out) - - Get comment information\n * `crc` (direction out) - - Get CRC16 information\n * `data` (direction out) - - Get compressed data start address\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceGzipGetInfo(
        src: *const crate::ctypes::c_void,
        extra: *mut *const crate::ctypes::c_void,
        name: *mut *const crate::ctypes::c_char,
        comment: *mut *const crate::ctypes::c_char,
        crc: *mut crate::ctypes::c_ushort,
        data: *mut *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get filename string address\n\n # Arguments\n\n* `src` (direction in) - - Gzip compressed data\n\n # Returns\n\nstring address on success, NULL on error."]
    pub fn ksceGzipGetName(src: *const crate::ctypes::c_void) -> *const crate::ctypes::c_char;
    #[doc = "Check magic of Gzip header\n\n # Arguments\n\n* `src` (direction in) - - Gzip compressed data\n\n # Returns\n\n1 on success, 0 is not Gzip data."]
    pub fn ksceGzipIsValid(src: *const crate::ctypes::c_void) -> crate::ctypes::c_int;
    pub fn ksceHmacSha1Digest(
        key: *const crate::ctypes::c_void,
        key_len: SceSize,
        plain: *const crate::ctypes::c_void,
        len: SceSize,
        digest: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceHmacSha224Digest(
        key: *const crate::ctypes::c_void,
        key_len: SceSize,
        plain: *const crate::ctypes::c_void,
        len: SceSize,
        digest: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceHmacSha256Digest(
        key: *const crate::ctypes::c_void,
        key_len: SceSize,
        plain: *const crate::ctypes::c_void,
        len: SceSize,
        digest: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha1BlockInit(ctx: *mut SceSha1Context) -> crate::ctypes::c_int;
    pub fn ksceSha1BlockResult(
        ctx: *mut SceSha1Context,
        result: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha1BlockUpdate(
        ctx: *mut SceSha1Context,
        plain: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha1Digest(
        plain: *const crate::ctypes::c_void,
        len: SceSize,
        digest: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha224BlockInit(ctx: *mut SceSha224Context) -> crate::ctypes::c_int;
    pub fn ksceSha224BlockResult(
        ctx: *mut SceSha224Context,
        result: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha224BlockUpdate(
        ctx: *mut SceSha224Context,
        plain: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha224Digest(
        plain: *const crate::ctypes::c_void,
        len: SceSize,
        digest: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha256BlockInit(ctx: *mut SceSha256Context) -> crate::ctypes::c_int;
    pub fn ksceSha256BlockResult(
        ctx: *mut SceSha256Context,
        result: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha256BlockUpdate(
        ctx: *mut SceSha256Context,
        plain: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSha256Digest(
        plain: *const crate::ctypes::c_void,
        len: SceSize,
        digest: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `dst` (direction out) - - dst buf\n * `dst_size` (direction in) - - dst buf size\n * `src` (direction in) - - Zlib compressed data\n * `adler32` (direction out) - - adler32 when decompressed\n\n # Returns\n\ndecompressed size on success, < 0 on error."]
    pub fn ksceZlibDecompress(
        dst: *mut crate::ctypes::c_void,
        dst_size: SceSize,
        src: *const crate::ctypes::c_void,
        adler32: *mut u32,
    ) -> crate::ctypes::c_int;
    #[doc = "Get compressed data start address\n\n # Arguments\n\n* `src` (direction in) - - Gzip compressed data\n\n # Returns\n\ncompressed data address on success, NULL on error."]
    pub fn ksceZlibGetCompressedData(
        src: *const crate::ctypes::c_void,
    ) -> *const crate::ctypes::c_void;
    #[doc = "Get filename etc. in Zlib data\n\n # Arguments\n\n* `src` (direction in) - - Zlib compressed data\n * `cmf` (direction out) - - Get CMF (Compression Method and flags)\n * `flg` (direction out) - - Get FLG (FLaGs)\n * `dictid` (direction out) - - Get DictId\n * `data` (direction out) - - Get compressed data start address\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceZlibGetInfo(
        src: *const crate::ctypes::c_void,
        cmf: *mut crate::ctypes::c_uchar,
        flg: *mut crate::ctypes::c_uchar,
        dictid: *mut crate::ctypes::c_uint,
        data: *mut *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceLcdForDriver_stub", kind = "static")]
#[cfg(feature = "SceLcdForDriver_stub")]
extern "C" {}
#[link(name = "SceLedForDriver_stub", kind = "static")]
#[cfg(feature = "SceLedForDriver_stub")]
extern "C" {}
#[link(name = "SceLibc_stub", kind = "static")]
#[cfg(feature = "SceLibc_stub")]
extern "C" {}
#[cfg(any(feature = "SceLibc_stub", feature = "SceSysclibForDriver_stub"))]
extern "C" {
    #[doc = "Search character from memory\n\n # Arguments\n\n* `src` (direction in) - - The memory source\n * `ch` (direction in) - - The character\n * `len` (direction in) - - The search length\n\n # Returns\n\nIf found character, return it position. else NULL."]
    pub fn memchr(
        src: *const crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        n: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Memory comparison\n\n # Arguments\n\n* `s1` (direction in) - - The memory source1\n * `s2` (direction in) - - The memory source2\n * `len` (direction in) - - The cmp length\n\n # Returns\n\nIf same memory contents, zero. else not zero."]
    pub fn memcmp(
        s1: *const crate::ctypes::c_void,
        s2: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Copy memory1 to memory2\n\n # Arguments\n\n* `dst` (direction in) - - The output buffer pointer\n * `src` (direction in) - - The input buffer pointer\n * `len` (direction in) - - The copy length\n\n # Returns\n\ndst."]
    pub fn memcpy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Move memory to memory\n\n # Arguments\n\n* `dst` (direction in) - - The buffer pointer\n * `src` (direction in) - - The buffer pointer\n * `len` (direction in) - - The move length\n\n # Returns\n\ndst."]
    pub fn memmove(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Set character to memory\n\n # Arguments\n\n* `dst` (direction in) - - The output buffer pointer\n * `ch` (direction in) - - The character\n * `len` (direction in) - - The character set length\n\n # Returns\n\ndst."]
    pub fn memset(
        dst: *mut crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    pub fn snprintf(
        dst: *mut crate::ctypes::c_char,
        max: crate::ctypes::c_uint,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    #[doc = "Search character from string\n\n # Arguments\n\n* `src` (direction in) - - The string source\n * `ch` (direction in) - - The character\n\n # Returns\n\nIf found character, return it position. else NULL."]
    pub fn strchr(
        src: *const crate::ctypes::c_char,
        ch: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_char;
    #[doc = "Strings comparison\n\n # Arguments\n\n* `s1` (direction in) - - The string source1\n * `s2` (direction in) - - The string source2\n\n # Returns\n\nIf same string contents, zero. else not zero."]
    pub fn strcmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Get string length\n\n # Arguments\n\n* `s` (direction in) - - The string pointer\n\n # Returns\n\nString length."]
    pub fn strlen(s: *const crate::ctypes::c_char) -> crate::ctypes::c_uint;
    #[doc = "Strings comparison with length limit\n\n # Arguments\n\n* `s1` (direction in) - - The string source1\n * `s2` (direction in) - - The string source2\n * `n` (direction in) - - The max length\n\n # Returns\n\nIf same string contents, zero. else not zero."]
    pub fn strncmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
        n: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Copy string with length limit\n\n # Arguments\n\n* `dst` (direction in) - - The output buffer pointer\n * `src` (direction in) - - The input buffer pointer\n * `n` (direction in) - - The max copy length\n\n # Returns\n\nIf same string contents, zero. else not zero."]
    pub fn strncpy(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        n: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_char;
    #[doc = "Search string from string\n\n # Arguments\n\n* `s1` (direction in) - - The string source1\n * `s2` (direction in) - - The string source2\n\n # Returns\n\nIf found string, return it position. else NULL."]
    pub fn strstr(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
    ) -> *mut crate::ctypes::c_char;
    pub fn strtol(
        str_: *const crate::ctypes::c_char,
        endptr: *mut *mut crate::ctypes::c_char,
        base: crate::ctypes::c_int,
    ) -> crate::ctypes::c_long;
    pub fn strtoll(
        str_: *const crate::ctypes::c_char,
        endptr: *mut *mut crate::ctypes::c_char,
        base: crate::ctypes::c_int,
    ) -> crate::ctypes::c_longlong;
    pub fn strtoul(
        str_: *const crate::ctypes::c_char,
        endptr: *mut *mut crate::ctypes::c_char,
        base: crate::ctypes::c_int,
    ) -> crate::ctypes::c_ulong;
    pub fn tolower(ch: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn toupper(ch: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn vsnprintf(
        dst: *mut crate::ctypes::c_char,
        max: crate::ctypes::c_uint,
        fmt: *const crate::ctypes::c_char,
        arg: u32,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceLibDbg_stub", kind = "static")]
#[cfg(feature = "SceLibDbg_stub")]
extern "C" {
    #[doc = "Handler for assertion logging in this library. The complete formatted\n output must not exceed 511 characters, so it is advised your message\n does not exceed ~256 characters. The output will be truncated if it\n does exceed 511 characters.\n\n # Arguments\n\n* `file` (direction in) - - Name of the file where the call was made.\n * `line` (direction in) - - Line number where the call was made.\n * `unk` (direction in) - - Unknown, never used internally.\n * `component` (direction in) - - Name of the component where the call was made. Optional field.\n * `msg` (direction in) - - printf formatted message.\n\n # Returns\n\nWill return the unk parameter."]
    pub fn sceDbgAssertionHandler(
        file: *const crate::ctypes::c_char,
        line: crate::ctypes::c_int,
        unk: crate::ctypes::c_int,
        component: *const crate::ctypes::c_char,
        msg: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    #[doc = "Handler for logging in this library. The complete formatted\n output must not exceed 511 characters, so it is advised\n that your message does not exceed ~300 characters. The output\n will be truncated if it does exceed 511 characters. A line break\n is automatically appended.\n\n # Arguments\n\n* `file` (direction in) - - Name of the file where the call was made.\n * `line` (direction in) - - Line number where the call was made.\n * `logLevel` (direction in) - - One of ::SceDbgLogLevel.\n * `component` (direction in) - - Name of the component where the call was made. Optional field.\n * `msg` (direction in) - - printf formatted message.\n\n # Returns\n\n0 on success, <0 on truncation of message."]
    pub fn sceDbgLoggingHandler(
        file: *const crate::ctypes::c_char,
        line: crate::ctypes::c_int,
        logLevel: SceDbgLogLevel,
        component: *const crate::ctypes::c_char,
        msg: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    #[doc = "Set whether or not to enter a breakpoint upon logging an error.\n Disabled by default.\n\n # Arguments\n\n* `breakOnError` (direction in) - - Enter the breakpoint?"]
    pub fn sceDbgSetBreakOnErrorState(breakOnError: SceBool);
    #[doc = "Set whether or not to enter a breakpoint upon logging a warning.\n Disabled by default.\n\n # Arguments\n\n* `breakOnWarning` (direction in) - - Enter the breakpoint?"]
    pub fn sceDbgSetBreakOnWarningState(breakOnWarning: SceBool);
    #[doc = "Set the minimum logging level. Any attempts to log at a level lower\n than this will not be outputted."]
    pub fn sceDbgSetMinimumLogLevel(level: SceDbgLogLevel);
}
#[link(name = "SceLibG729_stub", kind = "static")]
#[cfg(feature = "SceLibG729_stub")]
extern "C" {}
#[link(name = "SceLibJson_stub", kind = "static")]
#[cfg(feature = "SceLibJson_stub")]
extern "C" {}
#[link(name = "SceLibKernel_stub", kind = "static")]
#[cfg(feature = "SceLibKernel_stub")]
extern "C" {
    #[doc = "Run bkpt #0x88 and end the process in state -1\n\n # Returns\n\nnone"]
    pub fn sceClibAbort();
    pub fn sceClibLookCtypeTable(ch: crate::ctypes::c_char) -> crate::ctypes::c_char;
    pub fn sceClibMemchr(
        src: *const crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMemcmp(
        s1: *const crate::ctypes::c_void,
        s2: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sceClibMemcpy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMemcpy_safe(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMemmove(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMemset(
        dst: *mut crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMspaceCalloc(
        mspace: SceClibMspace,
        num: SceSize,
        size: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMspaceCreate(
        memblock: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> SceClibMspace;
    pub fn sceClibMspaceDestroy(mspace: SceClibMspace);
    pub fn sceClibMspaceFree(mspace: SceClibMspace, ptr: *mut crate::ctypes::c_void);
    pub fn sceClibMspaceIsHeapEmpty(mspace: SceClibMspace) -> SceBool;
    pub fn sceClibMspaceMalloc(mspace: SceClibMspace, size: SceSize) -> *mut crate::ctypes::c_void;
    pub fn sceClibMspaceMallocStats(mspace: SceClibMspace, stats: *mut SceClibMspaceStats);
    pub fn sceClibMspaceMallocStatsFast(mspace: SceClibMspace, stats: *mut SceClibMspaceStats);
    pub fn sceClibMspaceMallocUsableSize(ptr: *mut crate::ctypes::c_void) -> SceSize;
    pub fn sceClibMspaceMemalign(
        mspace: SceClibMspace,
        alignment: SceSize,
        size: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMspaceRealloc(
        mspace: SceClibMspace,
        ptr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibMspaceReallocalign(
        mspace: SceClibMspace,
        ptr: *mut crate::ctypes::c_void,
        size: SceSize,
        alignment: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sceClibPrintf(fmt: *const crate::ctypes::c_char, ...) -> crate::ctypes::c_int;
    pub fn sceClibSnprintf(
        dst: *mut crate::ctypes::c_char,
        dst_max_size: SceSize,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    pub fn sceClibStrchr(
        s: *const crate::ctypes::c_char,
        ch: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_char;
    pub fn sceClibStrcmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceClibStrncasecmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sceClibStrncat(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> *mut crate::ctypes::c_char;
    pub fn sceClibStrncmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sceClibStrncpy(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> *mut crate::ctypes::c_char;
    pub fn sceClibStrnlen(s1: *const crate::ctypes::c_char, max_len: SceSize) -> SceSize;
    pub fn sceClibStrrchr(
        src: *const crate::ctypes::c_char,
        ch: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_char;
    pub fn sceClibStrstr(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
    ) -> *mut crate::ctypes::c_char;
    pub fn sceClibTolower(ch: crate::ctypes::c_char) -> crate::ctypes::c_int;
    pub fn sceClibToupper(ch: crate::ctypes::c_char) -> crate::ctypes::c_int;
    pub fn sceClibVsnprintf(
        dst: *mut crate::ctypes::c_char,
        dst_max_size: SceSize,
        fmt: *const crate::ctypes::c_char,
        args: va_list,
    ) -> crate::ctypes::c_int;
    #[doc = "Change the status of a file.\n\n # Arguments\n\n* `file` - - The path to the file.\n * `stat` - - A pointer to a ::SceIoStat structure.\n * `bits` - - Bitmask defining which bits to change.\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoChstat(
        file: *const crate::ctypes::c_char,
        stat: *mut SceIoStat,
        bits: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Change the status of a file descriptor.\n\n # Arguments\n\n* `fd` - - The file descriptor.\n * `stat` - - A pointer to an io_stat_t structure.\n * `bits` - - Bitmask defining which bits to change.\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoChstatByFd(
        fd: SceUID,
        buf: *const SceIoStat,
        cbit: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Send a devctl command to a device.\n\n # Example: Sending a simple command to a device\n ```c\n SceIoDevInfo info;\n sceIoDevctl(\"ux0:\", 0x3001, NULL, 0, &info, sizeof(SceIoDevInfo));\n ```\n\n # Arguments\n\n* `dev` - - String for the device to send the devctl to (e.g. \"ux0:\")\n * `cmd` - - The command to send to the device\n * `indata` - - A data block to send to the device, if NULL sends no data\n * `inlen` - - Length of indata, if 0 sends no data\n * `outdata` - - A data block to receive the result of a command, if NULL receives no data\n * `outlen` - - Length of outdata, if 0 receives no data\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceIoDevctl(
        dev: *const crate::ctypes::c_char,
        cmd: crate::ctypes::c_uint,
        indata: *mut crate::ctypes::c_void,
        inlen: crate::ctypes::c_int,
        outdata: *mut crate::ctypes::c_void,
        outlen: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Open a directory\n\n # Example:\n ```c\n int dfd;\n dfd = sceIoDopen(\"device:/\");\n if(dfd >= 0)\n { Do something with the file descriptor }\n ```\n # Arguments\n\n* `dirname` - - The directory to open for reading.\n # Returns\n\nIf >= 0 then a valid file descriptor, otherwise a Sony error code."]
    pub fn sceIoDopen(dirname: *const crate::ctypes::c_char) -> SceUID;
    #[doc = "Reads an entry from an opened file descriptor.\n\n # Arguments\n\n* `fd` - - Already opened file descriptor (using ::sceIoDopen)\n * `dir` - - Pointer to a ::SceIoDirent structure to hold the file information\n\n # Returns\n\nRead status\n - 0 - No more directory entries left\n - > 0 - More directory entries to go\n - < 0 - Error"]
    pub fn sceIoDread(fd: SceUID, dir: *mut SceIoDirent) -> crate::ctypes::c_int;
    #[doc = "Get the status of a file.\n\n # Arguments\n\n* `file` - - The path to the file.\n * `stat` - - A pointer to a ::SceIoStat structure.\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoGetstat(
        file: *const crate::ctypes::c_char,
        stat: *mut SceIoStat,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the status of a file descriptor.\n\n # Arguments\n\n* `fd` - - The file descriptor.\n * `stat` - - A pointer to a ::SceIoStat structure.\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoGetstatByFd(fd: SceUID, stat: *mut SceIoStat) -> crate::ctypes::c_int;
    #[doc = "Perform an ioctl on a device.\n\n # Arguments\n\n* `fd` - - Opened file descriptor to ioctl to\n * `cmd` - - The command to send to the device\n * `indata` - - A data block to send to the device, if NULL sends no data\n * `inlen` - - Length of indata, if 0 sends no data\n * `outdata` - - A data block to receive the result of a command, if NULL receives no data\n * `outlen` - - Length of outdata, if 0 receives no data\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceIoIoctl(
        fd: SceUID,
        cmd: crate::ctypes::c_uint,
        indata: *mut crate::ctypes::c_void,
        inlen: crate::ctypes::c_int,
        outdata: *mut crate::ctypes::c_void,
        outlen: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Perform an ioctl on a device. (asynchronous)\n\n # Arguments\n\n* `fd` - - Opened file descriptor to ioctl to\n * `cmd` - - The command to send to the device\n * `indata` - - A data block to send to the device, if NULL sends no data\n * `inlen` - - Length of indata, if 0 sends no data\n * `outdata` - - A data block to receive the result of a command, if NULL receives no data\n * `outlen` - - Length of outdata, if 0 receives no data\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceIoIoctlAsync(
        fd: SceUID,
        cmd: crate::ctypes::c_uint,
        indata: *mut crate::ctypes::c_void,
        inlen: crate::ctypes::c_int,
        outdata: *mut crate::ctypes::c_void,
        outlen: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Reposition read/write file descriptor offset\n\n # Example:\n ```c\n pos = sceIoLseek(fd, -10, SCE_SEEK_END);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor with which to seek\n * `offset` - - Relative offset from the start position given by whence\n * `whence` - - One of ::SceIoSeekMode.\n\n # Returns\n\nThe position in the file after the seek."]
    pub fn sceIoLseek(fd: SceUID, offset: SceOff, whence: crate::ctypes::c_int) -> SceOff;
    #[doc = "Make a directory file\n\n # Arguments\n\n* `dir` - - The path to the directory\n * `mode` - - Access mode (One or more ::SceIoAccessMode).\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceIoMkdir(dir: *const crate::ctypes::c_char, mode: SceMode) -> crate::ctypes::c_int;
    #[doc = "Open or create a file for reading or writing\n\n # Example1: Open a file for reading\n ```c\n if((fd = sceIoOpen(\"device:/path/to/file\", SCE_O_RDONLY, 0777) < 0) {\n // error code in fd, for example no open filehandle left (0x80010018)\n }\n ```\n # Example2: Open a file for writing, creating it if it doesn't exist\n ```c\n if((fd = sceIoOpen(\"device:/path/to/file\", SCE_O_WRONLY|SCE_O_CREAT, 0777) < 0) {\n // error code in fd, for example no open filehandle left (0x80010018)\n }\n ```\n\n # Arguments\n\n* `file` - - Pointer to a string holding the name of the file to open.\n * `flags` - - Libc styled flags that are or'ed together (One or more ::SceIoMode).\n * `mode` - - One or more ::SceIoAccessMode flags or'ed together. Can also use Unix absolute permissions.\n # Returns\n\n> 0 is a valid file handle, < 0 on error."]
    pub fn sceIoOpen(
        file: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
        mode: SceMode,
    ) -> SceUID;
    #[doc = "Read input at offset\n\n # Example:\n ```c\n bytes_read = sceIoPread(fd, data, 100, 0x1000);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to read from\n * `data` - - Pointer to the buffer where the read data will be placed\n * `size` - - Size of the read in bytes\n * `offset` - - Offset to read\n\n # Returns\n\n< 0 on error."]
    pub fn sceIoPread(
        fd: SceUID,
        data: *mut crate::ctypes::c_void,
        size: SceSize,
        offset: SceOff,
    ) -> crate::ctypes::c_int;
    #[doc = "Write output at offset\n\n # Example:\n ```c\n bytes_written = sceIoPwrite(fd, data, 100, 0x1000);\n ```\n\n # Arguments\n\n* `fd` - - Opened file descriptor to write to\n * `data` - - Pointer to the data to write\n * `size` - - Size of data to write\n * `offset` - - Offset to write\n\n # Returns\n\nThe number of bytes written"]
    pub fn sceIoPwrite(
        fd: SceUID,
        data: *const crate::ctypes::c_void,
        size: SceSize,
        offset: SceOff,
    ) -> crate::ctypes::c_int;
    #[doc = "Remove directory entry\n\n # Arguments\n\n* `file` - - Path to the file to remove\n # Returns\n\n< 0 on error"]
    pub fn sceIoRemove(file: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Change the name of a file\n\n # Arguments\n\n* `oldname` - - The old filename\n * `newname` - - The new filename\n # Returns\n\n< 0 on error."]
    pub fn sceIoRename(
        oldname: *const crate::ctypes::c_char,
        newname: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Remove a directory file\n\n # Arguments\n\n* `path` - - Removes a directory file pointed by the string path\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn sceIoRmdir(path: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Synchronize the file data on the device.\n\n # Arguments\n\n* `device` - - The device to synchronize (e.g. msfat0:)\n * `unk` - - Unknown"]
    pub fn sceIoSync(
        device: *const crate::ctypes::c_char,
        unk: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelAtomicAddAndGet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicAddAndGet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicAddAndGet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicAddAndGet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicAddUnless16(
        store: *mut SceInt16,
        value: SceInt16,
        cmpv: SceInt16,
    ) -> SceBool;
    pub fn sceKernelAtomicAddUnless32(
        store: *mut SceInt32,
        value: SceInt32,
        cmpv: SceInt32,
    ) -> SceBool;
    pub fn sceKernelAtomicAddUnless64(
        store: *mut SceInt64,
        value: SceInt64,
        cmpv: SceInt64,
    ) -> SceBool;
    pub fn sceKernelAtomicAddUnless8(store: *mut SceInt8, value: SceInt8, cmpv: SceInt8)
        -> SceBool;
    pub fn sceKernelAtomicAndAndGet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicAndAndGet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicAndAndGet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicAndAndGet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicClearAndGet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicClearAndGet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicClearAndGet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicClearAndGet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicClearMask16(store: *mut SceInt16, value: SceInt16);
    pub fn sceKernelAtomicClearMask32(store: *mut SceInt32, value: SceInt32);
    pub fn sceKernelAtomicClearMask64(store: *mut SceInt64, value: SceInt64);
    pub fn sceKernelAtomicClearMask8(store: *mut SceInt8, value: SceInt8);
    pub fn sceKernelAtomicCompareAndSet16(
        store: *mut SceInt16,
        value: SceInt16,
        new_value: SceInt16,
    ) -> SceInt16;
    pub fn sceKernelAtomicCompareAndSet32(
        store: *mut SceInt32,
        value: SceInt32,
        new_value: SceInt32,
    ) -> SceInt32;
    pub fn sceKernelAtomicCompareAndSet64(
        store: *mut SceInt64,
        value: SceInt64,
        new_value: SceInt64,
    ) -> SceInt64;
    pub fn sceKernelAtomicCompareAndSet8(
        store: *mut SceInt8,
        value: SceInt8,
        new_value: SceInt8,
    ) -> SceInt8;
    pub fn sceKernelAtomicDecIfPositive16(store: *mut SceInt16) -> SceInt16;
    pub fn sceKernelAtomicDecIfPositive32(store: *mut SceInt32) -> SceInt32;
    pub fn sceKernelAtomicDecIfPositive64(store: *mut SceInt64) -> SceInt64;
    pub fn sceKernelAtomicDecIfPositive8(store: *mut SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndAdd16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndAdd32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndAdd64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndAdd8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndAnd16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndAnd32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndAnd64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndAnd8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndClear16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndClear32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndClear64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndClear8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndOr16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndOr32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndOr64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndOr8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndSet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndSet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndSet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndSet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndSub16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndSub32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndSub64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndSub8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicGetAndXor16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicGetAndXor32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicGetAndXor64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicGetAndXor8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicOrAndGet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicOrAndGet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicOrAndGet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicOrAndGet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicSet16(store: *mut SceInt16, value: SceInt16);
    pub fn sceKernelAtomicSet32(store: *mut SceInt32, value: SceInt32);
    pub fn sceKernelAtomicSet64(store: *mut SceInt64, value: SceInt64);
    pub fn sceKernelAtomicSet8(store: *mut SceInt8, value: SceInt8);
    pub fn sceKernelAtomicSubAndGet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicSubAndGet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicSubAndGet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicSubAndGet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    pub fn sceKernelAtomicXorAndGet16(store: *mut SceInt16, value: SceInt16) -> SceInt16;
    pub fn sceKernelAtomicXorAndGet32(store: *mut SceInt32, value: SceInt32) -> SceInt32;
    pub fn sceKernelAtomicXorAndGet64(store: *mut SceInt64, value: SceInt64) -> SceInt64;
    pub fn sceKernelAtomicXorAndGet8(store: *mut SceInt8, value: SceInt8) -> SceInt8;
    #[doc = "Cancel a message pipe\n\n # Arguments\n\n* `uid` - - UID of the pipe to cancel\n * `psend` - - Receive number of sending threads, NULL is valid\n * `precv` - - Receive number of receiving threads, NULL is valid\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelCancelMsgPipe(
        uid: SceUID,
        psend: *mut crate::ctypes::c_int,
        precv: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Cancels a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n * `newCount` - - The new lock count of the mutex\n * `numWaitThreads` - - Number of threads waiting for the mutex\n # Returns\n\n< 0 On error."]
    pub fn sceKernelCancelMutex(
        mutexid: SceUID,
        newCount: crate::ctypes::c_int,
        numWaitThreads: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Cancels a semaphore\n\n # Arguments\n\n* `semaid` - - The sema id returned from ::sceKernelCreateSema\n * `setCount` - - The new lock count of the semaphore\n * `numWaitThreads` - - Number of threads waiting for the semaphore\n # Returns\n\n< 0 On error."]
    pub fn sceKernelCancelSema(
        semaid: SceUID,
        setCount: crate::ctypes::c_int,
        numWaitThreads: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Modify the attributes of the current thread.\n\n # Arguments\n\n* `clearAttr` - - The thread attributes to clear. One of ::SceThreadAttributes.\n * `setAttr` - - The thread attributes to set. One of ::SceThreadAttributes.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelChangeCurrentThreadAttr(
        clearAttr: SceUInt,
        setAttr: SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Check the thread stack?\n\n # Returns\n\nUnknown."]
    pub fn sceKernelCheckThreadStack() -> crate::ctypes::c_int;
    #[doc = "Creates a new condition variable\n\n # Example:\n ```c\n SceUID condId;\n condId = sceKernelCreateCond(\"MyCond\", 0, mutexId, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the condition variable\n * `attr` - - Condition variable attribute flags (normally set to 0)\n * `mutexId` - - Mutex to be related to the condition variable\n * `option` - - Condition variable options (normally set to 0)\n # Returns\n\nA condition variable id"]
    pub fn sceKernelCreateCond(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        mutexId: SceUID,
        option: *const SceKernelCondOptParam,
    ) -> SceUID;
    #[doc = "Create an event flag.\n\n # Arguments\n\n* `name` - - The name of the event flag.\n * `attr` - - Attributes from ::SceEventFlagAttributes\n * `bits` - - Initial bit pattern.\n * `opt` - - Options, set to NULL\n # Returns\n\n< 0 on error. >= 0 event flag id.\n\n # Example:\n ```c\n int evid;\n evid = sceKernelCreateEventFlag(\"wait_event\", 0, 0, NULL);\n ```"]
    pub fn sceKernelCreateEventFlag(
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_int,
        bits: crate::ctypes::c_int,
        opt: *mut SceKernelEventFlagOptParam,
    ) -> SceUID;
    pub fn sceKernelCreateLwCond(
        pWork: *mut SceKernelLwCondWork,
        pName: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        pLwMutex: *mut SceKernelLwMutexWork,
        pOptParam: *const SceKernelLwCondOptParam,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelCreateLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        pName: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        initCount: crate::ctypes::c_int,
        pOptParam: *const SceKernelLwMutexOptParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Create a message pipe\n\n # Arguments\n\n* `name` - - Name of the pipe\n * `type` - - The type of memory attribute to use internally (set to 0x40)\n * `attr` - - Set to 12\n * `bufSize` - - The size of the internal buffer in multiples of 0x1000 (4KB)\n * `opt` - - Message pipe options (set to NULL)\n\n # Returns\n\nThe UID of the created pipe, < 0 on error"]
    pub fn sceKernelCreateMsgPipe(
        name: *const crate::ctypes::c_char,
        type_: crate::ctypes::c_int,
        attr: crate::ctypes::c_int,
        bufSize: crate::ctypes::c_uint,
        opt: *mut crate::ctypes::c_void,
    ) -> SceUID;
    #[doc = "Creates a new mutex\n\n # Example:\n ```c\n int mutexid;\n mutexid = sceKernelCreateMutex(\"MyMutex\", 0, 1, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the mutex\n * `attr` - - Mutex attribute flags (normally set to 0)\n * `initCount` - - Mutex initial value\n * `option` - - Mutex options (normally set to 0)\n # Returns\n\nA mutex id"]
    pub fn sceKernelCreateMutex(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        initCount: crate::ctypes::c_int,
        option: *mut SceKernelMutexOptParam,
    ) -> SceUID;
    #[doc = "Creates a new rwlock\n\n # Example:\n ```c\n int rwlock_id;\n rwlock_id = sceKernelCreateRWLock(\"MyRWLock\", 0, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the rwlock\n * `attr` - - RWLock attribute flags (normally set to 0)\n * `option` - - RWLock options (normally set to NULL)\n # Returns\n\nRWLock id on success, < 0 on error"]
    pub fn sceKernelCreateRWLock(
        name: *const crate::ctypes::c_char,
        attr: SceUInt32,
        opt_param: *const SceKernelRWLockOptParam,
    ) -> SceUID;
    #[doc = "Creates a new semaphore\n\n # Example:\n ```c\n int semaid;\n semaid = sceKernelCreateSema(\"MySema\", 0, 1, 1, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the sema\n * `attr` - - Sema attribute flags (normally set to 0)\n * `initVal` - - Sema initial value\n * `maxVal` - - Sema maximum value\n * `option` - - Sema options (normally set to 0)\n # Returns\n\nA semaphore id"]
    pub fn sceKernelCreateSema(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        initVal: crate::ctypes::c_int,
        maxVal: crate::ctypes::c_int,
        option: *mut SceKernelSemaOptParam,
    ) -> SceUID;
    #[doc = "Create a thread\n\n # Example:\n ```c\n SceUID thid;\n thid = sceKernelCreateThread(\"my_thread\", threadFunc, 0x10000100, 0x10000, 0, 0, NULL);\n ```\n\n # Arguments\n\n* `name` - - An arbitrary thread name.\n * `entry` - - The thread function to run when started.\n * `initPriority` - - The initial priority of the thread. Less if higher priority.\n * `stackSize` - - The size of the initial stack.\n * `attr` - - The thread attributes, zero or more of ::SceThreadAttributes.\n * `cpuAffinityMask` - - The CPU affinity mask\n A thread can run only on the cores specified in the CPU affinity mask.\n The CPU affinity mask can be specified by the logical sum of the following macros:\n - SCE_KERNEL_CPU_MASK_USER_0\n - SCE_KERNEL_CPU_MASK_USER_1\n - SCE_KERNEL_CPU_MASK_USER_2\n - SCE_KERNEL_CPU_MASK_SYSTEM (system-reserved core)\n The following macro are also available to represent all available in userland CPU cores:\n - SCE_KERNEL_CPU_MASK_USER_ALL\n The following macro are also available to inherit affinity mask of the calling process:\n - SCE_KERNEL_THREAD_CPU_AFFINITY_MASK_DEFAULT\n * `option` - - Additional options specified by ::SceKernelThreadOptParam.\n\n # Returns\n\nUID of the created thread, or an error code."]
    pub fn sceKernelCreateThread(
        name: *const crate::ctypes::c_char,
        entry: SceKernelThreadEntry,
        initPriority: crate::ctypes::c_int,
        stackSize: SceSize,
        attr: SceUInt,
        cpuAffinityMask: crate::ctypes::c_int,
        option: *const SceKernelThreadOptParam,
    ) -> SceUID;
    pub fn sceKernelDeleteLwCond(pWork: *mut SceKernelLwCondWork) -> crate::ctypes::c_int;
    pub fn sceKernelDeleteLwMutex(pWork: *mut SceKernelLwMutexWork) -> crate::ctypes::c_int;
    #[doc = "Exit current Process with specified return code\n\n # Arguments\n\n* `res` (direction in) - - Exit code to return\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceKernelExitProcess(res: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Gets the status of a specified callback.\n\n # Arguments\n\n* `cb` - - The UID of the callback to retrieve info for.\n * `status` - - Pointer to a status structure. The size parameter should be\n initialised before calling.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelGetCallbackInfo(
        cb: SceUID,
        infop: *mut SceKernelCallbackInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the status of an event flag.\n\n # Arguments\n\n* `event` - - The UID of the event.\n * `status` - - A pointer to a ::SceKernelEventFlagInfo structure.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelGetEventFlagInfo(
        event: SceUID,
        info: *mut SceKernelEventFlagInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the status of a Message Pipe\n\n # Arguments\n\n* `uid` - - The uid of the Message Pipe\n * `info` - - Pointer to a ::SceKernelMppInfo structure\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelGetMsgPipeInfo(
        uid: SceUID,
        info: *mut SceKernelMppInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Retrieve information about a mutex.\n\n # Arguments\n\n* `mutexid` - - UID of the mutex to retrieve info for.\n * `info` - - Pointer to a ::SceKernelMutexInfo struct to receive the info.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelGetMutexInfo(
        mutexid: SceUID,
        info: *mut SceKernelMutexInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelGetOpenPsId(id: *mut SceKernelOpenPsId) -> crate::ctypes::c_int;
    #[doc = "Get the process time of the current process.\n\n # Arguments\n\n* `type` (direction out) - - Pointer to a ::SceKernelSysClock structure which will receive the process time.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceKernelGetProcessTime(pSysClock: *mut SceKernelSysClock) -> crate::ctypes::c_int;
    #[doc = "Get the lower 32 bits part of process time of the current process.\n\n # Returns\n\nprocess time of the current process"]
    pub fn sceKernelGetProcessTimeLow() -> SceUInt32;
    #[doc = "Get the process time of the current process.\n\n # Returns\n\nprocess time of the current process"]
    pub fn sceKernelGetProcessTimeWide() -> SceUInt64;
    #[doc = "Retrieve information about a rwlock.\n\n # Arguments\n\n* `rwlock_id` - - UID of the rwlock to retrieve info for.\n * `info` - - Pointer to a ::SceKernelRWLockInfo struct to receive the info.\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelGetRWLockInfo(
        rwlock_id: SceUID,
        info: *mut SceKernelRWLockInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Fills the output buffer with random data.\n\n # Arguments\n\n* `output` (direction out) - - Output buffer\n * `size` (direction in) - - Size of the output buffer, 64 bytes maximum\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceKernelGetRandomNumber(
        output: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Retrieve information about a semaphore.\n\n # Arguments\n\n* `semaid` - - UID of the semaphore to retrieve info for.\n * `info` - - Pointer to a ::SceKernelSemaInfo struct to receive the info.\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelGetSemaInfo(
        semaid: SceUID,
        info: *mut SceKernelSemaInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the system information\n\n # Arguments\n\n* `info` - - Pointer to a ::SceKernelSystemInfo structure\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelGetSystemInfo(info: *mut SceKernelSystemInfo) -> crate::ctypes::c_int;
    #[doc = "sceKernelGetTLSAddr get pointer to TLS key area for current thread\n # Arguments\n\n* `key` - - the TLS keyslot index\n # Returns\n\npointer to TLS key value"]
    pub fn sceKernelGetTLSAddr(key: crate::ctypes::c_int) -> *mut crate::ctypes::c_void;
    #[doc = "Get the current priority of the thread you are in.\n\n # Returns\n\nThe current thread priority"]
    pub fn sceKernelGetThreadCurrentPriority() -> crate::ctypes::c_int;
    #[doc = "Get the exit status of a thread.\n\n # Arguments\n\n* `thid` (direction in) - - The UID of the thread to check.\n * `status` (direction out) - - Status out pointer\n # Returns\n\nThe exit status"]
    pub fn sceKernelGetThreadExitStatus(
        thid: SceUID,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the current thread Id\n\n # Returns\n\nThe thread id of the calling thread."]
    pub fn sceKernelGetThreadId() -> crate::ctypes::c_int;
    #[doc = "Get the status information for the specified thread.\n\n # Arguments\n\n* `thid` - - Id of the thread to get status\n * `info` - - Pointer to the info structure to receive the data.\n Note: The structures size field should be set to\n sizeof(SceKernelThreadInfo) before calling this function.\n\n # Example:\n ```c\n SceKernelThreadInfo status;\n status.size = sizeof(SceKernelThreadInfo);\n if(sceKernelGetThreadInfo(thid, &status) == 0)\n { Do something... }\n ```\n # Returns\n\n0 if successful, otherwise the error code."]
    pub fn sceKernelGetThreadInfo(
        thid: SceUID,
        info: *mut SceKernelThreadInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Retrive the runtime status of a thread.\n\n # Arguments\n\n* `thid` - - UID of the thread to retrieve status.\n * `status` - - Pointer to a ::SceKernelThreadRunStatus struct to receive the runtime status.\n\n # Returns\n\n0 if successful, otherwise the error code."]
    pub fn sceKernelGetThreadRunStatus(
        thid: SceUID,
        status: *mut SceKernelThreadRunStatus,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelLoadModule(
        path: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
    ) -> SceUID;
    pub fn sceKernelLoadStartModule(
        path: *const crate::ctypes::c_char,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
        status: *mut crate::ctypes::c_int,
    ) -> SceUID;
    pub fn sceKernelLockLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        lockCount: crate::ctypes::c_int,
        pTimeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n * `lockCount` - - The value to increment to the lock count of the mutex\n * `timeout` - - Timeout in microseconds (assumed)\n # Returns\n\n< 0 On error."]
    pub fn sceKernelLockMutex(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a mutex and handle callbacks if necessary.\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::sceKernelCreateMutex\n * `lockCount` - - The value to increment to the lock count of the mutex\n * `timeout` - - Timeout in microseconds (assumed)\n # Returns\n\n< 0 On error."]
    pub fn sceKernelLockMutexCB(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a rwlock with read access\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n * `timeout` - - Timeout in microseconds, use NULL to disable it\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelLockReadRWLock(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a rwlock with read access and handle callbacks\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n * `timeout` - - Timeout in microseconds, use NULL to disable it\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelLockReadRWLockCB(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a rwlock with write access\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n * `timeout` - - Timeout in microseconds, use NULL to disable it\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelLockWriteRWLock(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a rwlock with write access and handle callbacks\n\n # Arguments\n\n* `rwlock_id` - - The rwlock id returned from ::sceKernelCreateRWLock\n * `timeout` - - Timeout in microseconds, use NULL to disable it\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelLockWriteRWLockCB(
        rwlock_id: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Poll an event flag for a given bit pattern.\n\n # Arguments\n\n* `evid` - - The event id returned by ::sceKernelCreateEventFlag.\n * `bits` - - The bit pattern to poll for.\n * `wait` - - Wait type, one or more of ::SceEventFlagWaitTypes or'ed together\n * `outBits` - - The bit pattern that was matched.\n # Returns\n\n< 0 On error"]
    pub fn sceKernelPollEventFlag(
        evid: crate::ctypes::c_int,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Receive a message from a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - async vs sync? use 0 for sync\n * `unk2` - - Unknown - use NULL\n * `timeout` - - Timeout for receive in us. use NULL to wait indefinitely\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelReceiveMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Receive a message from a pipe (with callback)\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - async vs sync? use 0 for sync\n * `unk2` - - Unknown - use NULL\n * `timeout` - - Timeout for receive in us. use NULL to wait indefinitely\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelReceiveMsgPipeCB(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Send a message to a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - async vs sync? use 0 for sync\n * `unk2` - - Unknown - use NULL\n * `timeout` - - Timeout for send in us. use NULL to wait indefinitely\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelSendMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Send a message to a pipe (with callback)\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - async vs sync? use 0 for sync\n * `unk2` - - Unknown - use NULL\n * `timeout` - - Timeout for send in us. use NULL to wait indefinitely\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelSendMsgPipeCB(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelSignalLwCond(pWork: *mut SceKernelLwCondWork) -> crate::ctypes::c_int;
    pub fn sceKernelSignalLwCondAll(pWork: *mut SceKernelLwCondWork) -> crate::ctypes::c_int;
    pub fn sceKernelSignalLwCondTo(
        pWork: *mut SceKernelLwCondWork,
        threadId: SceUID,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelStartModule(
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut crate::ctypes::c_void,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Start a created thread\n\n # Arguments\n\n* `thid` - - Thread id from ::sceKernelCreateThread\n * `arglen` - - Length of the data pointed to by argp, in bytes\n * `argp` - - Pointer to the arguments."]
    pub fn sceKernelStartThread(
        thid: SceUID,
        arglen: SceSize,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelStopModule(
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut crate::ctypes::c_void,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelStopUnloadModule(
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelTryLockLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        lockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Receive a message from a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - use 0\n * `unk2` - - Unknown - use NULL\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelTryReceiveMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Try to send a message to a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - use 0\n * `unk2` - - Unknown - use NULL\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceKernelTrySendMsgPipe(
        uid: SceUID,
        message: *mut crate::ctypes::c_void,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelUnloadModule(
        modid: SceUID,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelUnlockLwMutex(
        pWork: *mut SceKernelLwMutexWork,
        unlockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Waits for a signal of a condition variable\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::sceKernelCreateCond\n * `timeout` - - Timeout in microseconds (assumed)\n # Returns\n\n< 0 On error."]
    pub fn sceKernelWaitCond(
        condId: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Waits for a signal of a condition variable (with callbacks)\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::sceKernelCreateCond\n * `timeout` - - Timeout in microseconds (assumed)\n # Returns\n\n< 0 On error."]
    pub fn sceKernelWaitCondCB(
        condId: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for an event flag for a given bit pattern.\n\n # Arguments\n\n* `evid` - - The event id returned by ::sceKernelCreateEventFlag.\n * `bits` - - The bit pattern to poll for.\n * `wait` - - Wait type, one or more of ::SceEventFlagWaitTypes or'ed together\n * `outBits` - - The bit pattern that was matched.\n * `timeout` - - Timeout in microseconds\n # Returns\n\n< 0 On error"]
    pub fn sceKernelWaitEventFlag(
        evid: crate::ctypes::c_int,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for an event flag for a given bit pattern with callback.\n\n # Arguments\n\n* `evid` - - The event id returned by ::sceKernelCreateEventFlag.\n * `bits` - - The bit pattern to poll for.\n * `wait` - - Wait type, one or more of ::SceEventFlagWaitTypes or'ed together\n * `outBits` - - The bit pattern that was matched.\n * `timeout` - - Timeout in microseconds\n # Returns\n\n< 0 On error"]
    pub fn sceKernelWaitEventFlagCB(
        evid: crate::ctypes::c_int,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelWaitLwCond(
        pWork: *mut SceKernelLwCondWork,
        pTimeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a semaphore\n\n # Example:\n ```c\n sceKernelWaitSema(semaid, 1, 0);\n ```\n\n # Arguments\n\n* `semaid` - - The sema id returned from ::sceKernelCreateSema\n * `signal` - - The value to wait for (i.e. if 1 then wait till reaches a signal state of 1)\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelWaitSema(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a semaphore and handle callbacks if necessary.\n\n # Example:\n ```c\n sceKernelWaitSemaCB(semaid, 1, 0);\n ```\n\n # Arguments\n\n* `semaid` - - The sema id returned from ::sceKernelCreateSema\n * `signal` - - The value to wait for (i.e. if 1 then wait till reaches a signal state of 1)\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelWaitSemaCB(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Sleep current thread and wait for a signal. After it receives a signal, the thread wakes up.\n\n This is like a semphore with limit 1.\n If signal was sent before and not consumed before, the function will immediately return.\n # Arguments\n\n* `unk0` - unknown parameter. 0 can be used.\n * `delay` - the delay before wating for a signal\n * `timeout` - the timeout if it's null, it waits indefinitely.\n # Returns\n\n0 on success"]
    pub fn sceKernelWaitSignal(
        unk0: SceUInt32,
        delay: SceUInt32,
        timeout: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait until a thread has ended.\n\n # Arguments\n\n* `thid` - - Id of the thread to wait for.\n * `stat` - - Exit status.\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelWaitThreadEnd(
        thid: SceUID,
        stat: *mut crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait until a thread has ended and handle callbacks if necessary.\n\n # Arguments\n\n* `thid` - - Id of the thread to wait for.\n * `stat` - - Exit status.\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn sceKernelWaitThreadEndCB(
        thid: SceUID,
        stat: *mut crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    pub fn sceSblACMgrIsGameProgram(result: *mut SceBool) -> SceInt32;
}
#[cfg(any(feature = "SceLibKernel_stub", feature = "SceSysclibForDriver_stub"))]
extern "C" {
    pub fn __stack_chk_fail() -> !;
}
#[link(name = "SceLibMonoBridge_stub", kind = "static")]
#[cfg(feature = "SceLibMonoBridge_stub")]
extern "C" {
    pub fn pss_code_mem_alloc(arg1: *mut SceSize) -> *mut crate::ctypes::c_void;
    pub fn pss_code_mem_flush_icache(arg1: *const crate::ctypes::c_void, arg2: SceSize);
    pub fn pss_code_mem_lock();
    pub fn pss_code_mem_unlock();
    pub fn pss_crypto_close(handle: *mut ScePssCryptoHandle) -> crate::ctypes::c_int;
    pub fn pss_crypto_open(
        handle: *mut ScePssCryptoHandle,
        path: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn pss_crypto_read(
        handle: *mut ScePssCryptoHandle,
        mode: *mut crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_char;
}
#[link(name = "SceLibMono_stub", kind = "static")]
#[cfg(feature = "SceLibMono_stub")]
extern "C" {}
#[link(name = "SceLibMp4Recorder_stub", kind = "static")]
#[cfg(feature = "SceLibMp4Recorder_stub")]
extern "C" {}
#[link(name = "SceLibMtp_stub", kind = "static")]
#[cfg(feature = "SceLibMtp_stub")]
extern "C" {}
#[link(name = "SceLibXml_stub", kind = "static")]
#[cfg(feature = "SceLibXml_stub")]
extern "C" {}
#[link(name = "SceLiveArea_stub", kind = "static")]
#[cfg(feature = "SceLiveArea_stub")]
extern "C" {}
#[link(name = "SceLocationExtension_stub", kind = "static")]
#[cfg(feature = "SceLocationExtension_stub")]
extern "C" {}
#[link(name = "SceLocation_stub", kind = "static")]
#[cfg(feature = "SceLocation_stub")]
extern "C" {
    #[doc = "Cancel location information acquisition operation"]
    pub fn sceLocationCancelGetLocation(handle: SceLocationHandle) -> SceInt32;
    #[doc = "Close library"]
    pub fn sceLocationClose(handle: SceLocationHandle) -> SceInt32;
    #[doc = "Allow acquisition of location information"]
    pub fn sceLocationConfirm(handle: SceLocationHandle) -> SceInt32;
    #[doc = "Abort location information acquisition permission dialog"]
    pub fn sceLocationConfirmAbort(handle: SceLocationHandle) -> SceInt32;
    #[doc = "Get result of location information acquisition permission dialog"]
    pub fn sceLocationConfirmGetResult(
        handle: SceLocationHandle,
        result: *mut SceLocationDialogResult,
    ) -> SceInt32;
    #[doc = "Get status of location information acquisition permission dialog"]
    pub fn sceLocationConfirmGetStatus(
        handle: SceLocationHandle,
        status: *mut SceLocationDialogStatus,
    ) -> SceInt32;
    #[doc = "Get direction information"]
    pub fn sceLocationGetHeading(
        handle: SceLocationHandle,
        headingInfo: *mut SceLocationHeadingInfo,
    ) -> SceInt32;
    #[doc = "Get location information"]
    pub fn sceLocationGetLocation(
        handle: SceLocationHandle,
        locationInfo: *mut SceLocationLocationInfo,
    ) -> SceInt32;
    #[doc = "Get location measurement method"]
    pub fn sceLocationGetMethod(
        handle: SceLocationHandle,
        locateMethod: *mut SceLocationLocationMethod,
        headingMethod: *mut SceLocationHeadingMethod,
    ) -> SceInt32;
    #[doc = "Get location information acquisition permission/refusal information"]
    pub fn sceLocationGetPermission(
        handle: SceLocationHandle,
        info: *mut SceLocationPermissionInfo,
    ) -> SceInt32;
    #[doc = "Functions */\n/** Library start"]
    pub fn sceLocationOpen(
        handle: *mut SceLocationHandle,
        locateMethod: SceLocationLocationMethod,
        headingMethod: SceLocationHeadingMethod,
    ) -> SceInt32;
    #[doc = "Reopen library"]
    pub fn sceLocationReopen(
        handle: SceLocationHandle,
        locateMethod: SceLocationLocationMethod,
        headingMethod: SceLocationHeadingMethod,
    ) -> SceInt32;
    #[doc = "Get location information acquisition permission information"]
    pub fn sceLocationSetGpsEmulationFile(filename: *mut crate::ctypes::c_uchar) -> SceInt32;
    #[doc = "Start continuous acquisition of direction information"]
    pub fn sceLocationStartHeadingCallback(
        handle: SceLocationHandle,
        difference: SceUInt32,
        callback: SceLocationHeadingInfoCallback,
        userdata: *mut crate::ctypes::c_void,
    ) -> SceInt32;
    #[doc = "Start continuous acquisition of location information"]
    pub fn sceLocationStartLocationCallback(
        handle: SceLocationHandle,
        distance: SceUInt32,
        callback: SceLocationLocationInfoCallback,
        userdata: *mut crate::ctypes::c_void,
    ) -> SceInt32;
    #[doc = "Stop continuous acquisition of direction information"]
    pub fn sceLocationStopHeadingCallback(handle: SceLocationHandle) -> SceInt32;
    #[doc = "Stop continuous acquisition of location information"]
    pub fn sceLocationStopLocationCallback(handle: SceLocationHandle) -> SceInt32;
}
#[link(name = "SceLsdb_stub", kind = "static")]
#[cfg(feature = "SceLsdb_stub")]
extern "C" {}
#[link(name = "SceModulemgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceModulemgrForDriver_stub")]
extern "C" {
    #[doc = "Get fw info\n\n # Arguments\n\n* `data` (direction out) - - fw info output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetSystemSwVersion(data: *mut SceKernelFwInfo) -> crate::ctypes::c_int;
    #[doc = "load module (kernel only)\n\n # Arguments\n\n* `path` (direction in) - - module path\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelLoadModule(
        path: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
    ) -> SceUID;
    #[doc = "load and start module (kernel only)\n\n # Arguments\n\n* `path` (direction in) - - module path\n * `args` (direction in) - - module start args\n * `argp` (direction in) - - module start argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_start res, SCE_KERNEL_START_SUCCESS etc...\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelLoadStartModule(
        path: *const crate::ctypes::c_char,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
        status: *mut crate::ctypes::c_int,
    ) -> SceUID;
    #[doc = "load and start module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `path` (direction in) - - module path\n * `args` (direction in) - - module start args\n * `argp` (direction in) - - module start argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_start res, SCE_KERNEL_START_SUCCESS etc...\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelLoadStartModuleForPid(
        pid: SceUID,
        path: *const crate::ctypes::c_char,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
        status: *mut crate::ctypes::c_int,
    ) -> SceUID;
    #[doc = "load and start module as shared module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `path` (direction in) - - module path\n * `args` (direction in) - - module start args\n * `argp` (direction in) - - module start argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_start res, SCE_KERNEL_START_SUCCESS etc...\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelLoadStartSharedModuleForPid(
        pid: SceUID,
        path: *const crate::ctypes::c_char,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
        status: *mut crate::ctypes::c_int,
    ) -> SceUID;
    #[doc = "search kernel module by module name\n\n # Arguments\n\n* `module_name` (direction in) - - target module name\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelSearchModuleByName(module_name: *const crate::ctypes::c_char) -> SceUID;
    #[doc = "start module (kernel only)\n\n # Arguments\n\n* `modid` (direction in) - - target module id\n * `args` (direction in) - - module start args\n * `argp` (direction in) - - module start argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_start res, SCE_KERNEL_START_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStartModule(
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "stop module (kernel only)\n\n # Arguments\n\n* `modid` (direction in) - - target module id\n * `args` (direction in) - - module stop args\n * `argp` (direction in) - - module stop argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_stop res, SCE_KERNEL_STOP_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStopModule(
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "stop and unload module (kernel only)\n\n # Arguments\n\n* `modid` (direction in) - - target module id\n * `args` (direction in) - - module stop args\n * `argp` (direction in) - - module stop argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_stop res, SCE_KERNEL_STOP_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStopUnloadModule(
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "stop and unload module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target module id\n * `args` (direction in) - - module stop args\n * `argp` (direction in) - - module stop argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_stop res, SCE_KERNEL_STOP_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStopUnloadModuleForPid(
        pid: SceUID,
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "stop and unload module as shared module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target module id\n * `args` (direction in) - - module stop args\n * `argp` (direction in) - - module stop argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_stop res, SCE_KERNEL_STOP_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStopUnloadSharedModuleForPid(
        pid: SceUID,
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "unload module (kernel only)\n\n # Arguments\n\n* `modid` (direction in) - - target module id\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelUnloadModule(
        modid: SceUID,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceModulemgrForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceModulemgrForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceModulemgrForKernel_363_stub",
    feature = "SceModulemgrForKernel_stub"
))]
extern "C" {
    #[doc = "Get module info\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target module id\n * `info` (direction out) - - info output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModuleInfo(
        pid: SceUID,
        modid: SceUID,
        info: *mut SceKernelModuleInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get module id list\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `flags1` (direction in) - - unknown, use 0x7FFFFFFF\n * `flags2` (direction in) - - unknown, use 1\n * `modids` (direction out) - - info output pointer\n * `num` (direction in, out) - - in:list max num, out:get modid num\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModuleList(
        pid: SceUID,
        flags1: crate::ctypes::c_int,
        flags2: crate::ctypes::c_int,
        modids: *mut SceUID,
        num: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "load module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `path` (direction in) - - module path\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelLoadModuleForPid(
        pid: SceUID,
        path: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
    ) -> SceUID;
    #[doc = "mount bootfs (load bootfs module)\n\n # Arguments\n\n* `bootImagePath` (direction in) - - bootfs module path\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMountBootfs(
        bootImagePath: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "start module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target module id\n * `args` (direction in) - - module start args\n * `argp` (direction in) - - module start argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_start res, SCE_KERNEL_START_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStartModuleForPid(
        pid: SceUID,
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelLMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "stop module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target module id\n * `args` (direction in) - - module stop args\n * `argp` (direction in) - - module stop argp\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n * `status` (direction out) - - module_stop res, SCE_KERNEL_STOP_SUCCESS etc...\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelStopModuleForPid(
        pid: SceUID,
        modid: SceUID,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "unmount bootfs (unload bootfs module)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelUmountBootfs() -> crate::ctypes::c_int;
    #[doc = "unload module\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target module id\n * `flags` (direction in) - - unknown, set zero\n * `option` (direction in) - - unknown\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelUnloadModuleForPid(
        pid: SceUID,
        modid: SceUID,
        flags: crate::ctypes::c_int,
        option: *mut SceKernelULMOption,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceModulemgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceModulemgrForKernel_stub")]
extern "C" {
    #[doc = "Get library info\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `modid` (direction in) - - target library id\n * `info` (direction out) - - info output\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetLibraryInfoForDebugger(
        pid: SceUID,
        library_id: SceUID,
        info: *mut SceKernelModuleLibraryInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get module info (internal)\n\n # Arguments\n\n* `modid` (direction in) - - target module id\n * `info` (direction out) - - module_info output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModuleCB(
        modid: SceUID,
        info: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get module info by address (internal)\n\n # Arguments\n\n* `pid` (direction in) - - target process id\n * `module_addr` (direction in) - - target module address\n * `info` (direction out) - - module_info output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModuleCBByAddr(
        pid: SceUID,
        module_addr: *const crate::ctypes::c_void,
        info: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get module id by module address\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `module_addr` (direction in) - - target module address\n\n # Returns\n\nmodid on success, < 0 on error."]
    pub fn ksceKernelGetModuleIdByAddrForDebugger(
        pid: SceUID,
        module_addr: *const crate::ctypes::c_void,
    ) -> SceUID;
    #[doc = "Get the main module id for a given process.\n # Arguments\n\n* `pid` - The process to query.\n # Returns\n\nthe UID of the module else < 0 for an error."]
    pub fn ksceKernelGetModuleIdByPid(pid: SceUID) -> SceUID;
    #[doc = "# Example1: Get max to 10 kernel module info\n ```c\n SceKernelModuleListInfo infolists\\[10\\];\n size_t num = 10;// Get max\n uint32_t offset = 0;\n SceKernelModuleListInfo *info = &infolists\\[0\\];\n\n ksceKernelGetModuleInfoForDebugger(0x10005, infolists, &num);\n\n for(int i=0;i<num;i++){\n printf(\"name : %sinfo->module_name);\n\n if(info->segments_num == 1){\n printf(\"vaddr:0x%08Xinfo->seg1.SegmentInfo\\[0\\].vaddr);\n }else if(info->segments_num == 2){\n printf(\"vaddr:0x%08Xinfo->seg2.SegmentInfo\\[0\\].vaddr);\n }\n info = ((char *)info) + info->size;\n }\n ```\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `infolists` (direction out) - - infolists output\n * `num` (direction in, out) - - Specify the maximum number of modinfolist to retrieve. If the function returns 0, it returns the number of modules loaded in the target pid in num\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModuleInfoForDebugger(
        pid: SceUID,
        infolists: *mut SceKernelModuleListInfo,
        num: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get module info mini by module address\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `module_addr` (direction in) - - target module address, Also possible with data segment address\n * `module_nid` (direction out) - - can also set NULL, module nid output\n * `program_text_addr` (direction out) - - can also set NULL, program text addr output\n * `module_name` (direction out) - - can also set NULL, module name output\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModuleInfoMinByAddr(
        pid: SceUID,
        module_addr: *const crate::ctypes::c_void,
        module_nid: *mut u32,
        program_text_addr: *mut *const crate::ctypes::c_void,
        module_name: *mut SceKernelModuleName,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the module path\n\n # Arguments\n\n* `pid` (direction in) - - target pid\n * `path` (direction out) - - module path output\n * `pathlen` (direction in) - - path output max len\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetModulePath(
        modid: SceUID,
        path: *mut crate::ctypes::c_char,
        pathlen: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Setup kernel for modulemgr\n\n > **Note:** - allocate and initialize syscall table\n\n # Returns\n\nnone"]
    pub fn ksceKernelRegisterModulesAfterBoot();
    #[doc = "Register syscall function\n\n # Arguments\n\n* `syscall_id` (direction in) - - register syscall id (Must be less than 0x1000)\n * `func` (direction in) - - syscall function\n\n # Returns\n\nnone"]
    pub fn ksceKernelRegisterSyscall(syscall_id: SceSize, func: *const crate::ctypes::c_void);
}
#[link(name = "SceMotionDevForDriver_stub", kind = "static")]
#[cfg(feature = "SceMotionDevForDriver_stub")]
extern "C" {}
#[link(name = "SceMotionDev_stub", kind = "static")]
#[cfg(feature = "SceMotionDev_stub")]
extern "C" {
    pub fn sceMotionDevGetAccCalibData(data: *mut SceMotionDevAccCalibData)
        -> crate::ctypes::c_int;
    pub fn sceMotionDevGetAccCalibData2(
        port: crate::ctypes::c_int,
        data: *mut SceMotionDevAccCalibData,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetCalibrationData(
        block_id: SceUInt32,
        data: *mut SceMotionDevCalibrationData,
        data_num: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetCalibrationHeader(
        block_id: SceUInt32,
        calib_header: *mut SceMotionDevCalibrationHeader,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetCurrentMagnCalibData(
        data: *mut SceMotionDevMagnCalibData,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetCurrentMagnStabilityLevel(level: *mut SceUInt32) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetDeviceInfo(
        device_info: *mut SceMotionDevDeviceInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetDeviceLocation(
        location: *mut SceMotionDevDeviceLocation,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetFactoryMagnCalibData(
        data: *mut SceMotionDevMagnCalibData,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetGyroBias(bias: *mut SceMotionDevGyroBiasData) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetGyroBias2(
        port: crate::ctypes::c_int,
        bias: *mut SceMotionDevGyroBiasData,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetGyroCalibData(
        data: *mut SceMotionDevGyroCalibData,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetGyroCalibData2(
        port: crate::ctypes::c_int,
        data: *mut SceMotionDevGyroCalibData,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevGetMeasMode(mode_info: *mut SceMotionDevModeInfo) -> crate::ctypes::c_int;
    pub fn sceMotionDevIsReady() -> crate::ctypes::c_int;
    pub fn sceMotionDevMagnSamplingStart() -> crate::ctypes::c_int;
    pub fn sceMotionDevMagnSamplingStop() -> crate::ctypes::c_int;
    pub fn sceMotionDevRead(
        data: *mut SceMotionDevData,
        data_num: crate::ctypes::c_int,
        info: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevRead2(
        port: crate::ctypes::c_int,
        data: *mut SceMotionDevData,
        data_num: crate::ctypes::c_int,
        info: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevReadForMagnCalib(
        data: *mut SceMotionDevData,
        data_num: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevSamplingStart() -> crate::ctypes::c_int;
    pub fn sceMotionDevSamplingStart2(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceMotionDevSamplingStop() -> crate::ctypes::c_int;
    pub fn sceMotionDevSamplingStop2(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceMotionDevSetSamplingMode(mode: SceUInt32) -> crate::ctypes::c_int;
    pub fn sceMotionDevUpdateMagnCalibData(
        data: *const SceMotionDevMagnCalibData,
        tag: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceMotionDevUpdateMagnStabilityLevel(level: SceUInt32) -> crate::ctypes::c_int;
}
#[link(name = "SceMotion_stub", kind = "static")]
#[cfg(feature = "SceMotion_stub")]
extern "C" {
    #[doc = "Get the angle threshold for basic orientation\n\n # Returns\n\nangle in degrees"]
    pub fn sceMotionGetAngleThreshold() -> f32;
    #[doc = "Gets the basic orientation of the device in relation to gravity\n > **Note:** - Possible values in the output vector are -1, 0 and 1\n > **Note:** - Using the same coordinate system as ::SceMotionDeviceLocation these values are set in the vector depending on if the axies' positive or negative directions are facing away from gravitational pull\n > **Note:** - For example if the vita is laying on a flat and level surface, with the OLED/LCD side facing upwards, the Z part of the vector will be 1\n > **Note:** - Now flipping the device upwards, taking hold of the right joystick's side, until it forms a 90 degree angle to the surface will result in the X part of the vector being 1 instead\n > **Note:** - Both examples would result in the returned value being -1 if flipped 180 degrees, swapping their top and bottom sides in correlation to gravity\n > **Note:** - The angle of rotation in relation to being in a centered state on an axis (returned as 0) after which the device will change the value is determined by ::SceMotionSetAngleThreshold\n > **Note:** - In order for this function to return up to date data, ::sceMotionGetState must be called prior to call this function.\n # Arguments\n\n* `*basicOrientation` (direction out) -\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionGetBasicOrientation(basicOrientation: *mut SceFVector3)
        -> crate::ctypes::c_int;
    #[doc = "Get status of deadbanding\n > **Note:** - With deadbanding enabled the device will filter out small movements to reduce jitter\n > **Note:** - Potentially decreaces accuracy of fine movements\n > **Note:** - Enabled by default\n # Returns\n\n1 if enabled, 0 if disabled"]
    pub fn sceMotionGetDeadband() -> crate::ctypes::c_int;
    #[doc = "Gets the location of the device's sensors in relation to its center point (in mm).\n\n # Arguments\n\n* `*deviceLocation` (direction out) - - See ::SceMotionDeviceLocation\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionGetDeviceLocation(
        deviceLocation: *mut SceMotionDeviceLocation,
    ) -> crate::ctypes::c_int;
    #[doc = "Get status of gyroscope bias correction\n > **Note:** - With gyroscope bias correction enabled the device will attempt to adjust for outside influences that could impact calibration\n > **Note:** - Enabled by default\n # Returns\n\n1 if enabled, 0 if disabled"]
    pub fn sceMotionGetGyroBiasCorrection() -> crate::ctypes::c_int;
    #[doc = "Get status of magnetometer sampling\n\n # Returns\n\n1 if enabled, 0 if disabled"]
    pub fn sceMotionGetMagnetometerState() -> crate::ctypes::c_int;
    #[doc = "Gets the current motion sensor state\n\n # Arguments\n\n* `numRecords` (direction in) - - Amount of records to get\n * `*motionSensorState` (direction out) - - See ::SceMotionSensorState\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionGetSensorState(
        sensorState: *mut SceMotionSensorState,
        numRecords: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets the current motion state.\n\n # Arguments\n\n* `*motionState` (direction out) - - See ::SceMotionState\n\n # Returns\n\n0, <0 on error."]
    pub fn sceMotionGetState(motionState: *mut SceMotionState) -> crate::ctypes::c_int;
    #[doc = "Get Status of tilt correction\n > **Note:** - With tilt correction enabled the data for roll and pitch movements of the device get recalculated to not distort the yaw movements in relation to gravity\n > **Note:** - Enabled by default\n # Returns\n\n1 if enabled, 0 if disabled"]
    pub fn sceMotionGetTiltCorrection() -> crate::ctypes::c_int;
    #[doc = "Stop magnetometer sampling\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionMagnetometerOff() -> crate::ctypes::c_int;
    #[doc = "Start magnetometer sampling\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionMagnetometerOn() -> crate::ctypes::c_int;
    #[doc = "Set current orientation as origin\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionReset() -> crate::ctypes::c_int;
    #[doc = "Rotate the yaw axis\n\n # Arguments\n\n* `radians` (direction in) - - Rotation angle in radians\n\n # Returns\n\n0"]
    pub fn sceMotionRotateYaw(radians: f32) -> crate::ctypes::c_int;
    #[doc = "Define the angle threshold for basic orientation\n\n # Arguments\n\n* `angle` (direction in) - - range of 0 to 45 degrees\n\n # Returns\n\n0"]
    pub fn sceMotionSetAngleThreshold(angle: f32) -> crate::ctypes::c_int;
    #[doc = "Activate/deactivate deadbanding\n > **Note:** - For more information see ::sceMotionGetDeadbanding\n # Arguments\n\n* `setValue` (direction in) - - 1 to enable, 0 to disable\n\n # Returns\n\n0"]
    pub fn sceMotionSetDeadband(setValue: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Activate/deactivate gyroscope bias correction\n > **Note:** - For more information see ::sceMotionGetGyroBiasCorrection\n # Arguments\n\n* `setValue` (direction in) - - 1 to enable, 0 to disable\n\n # Returns\n\n0"]
    pub fn sceMotionSetGyroBiasCorrection(setValue: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Activate/deactivate tilt correction\n > **Note:** - For more information see ::sceMotionGetTiltCorrection\n # Arguments\n\n* `setValue` (direction in) - - 1 to enable, 0 to disable\n\n # Returns\n\n0"]
    pub fn sceMotionSetTiltCorrection(setValue: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Start sampling\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionStartSampling() -> crate::ctypes::c_int;
    #[doc = "Stop sampling\n\n # Returns\n\n0, <0 on error"]
    pub fn sceMotionStopSampling() -> crate::ctypes::c_int;
}
#[link(name = "SceMsifForDriver_stub", kind = "static")]
#[cfg(feature = "SceMsifForDriver_stub")]
extern "C" {
    pub fn ksceMsifGetMsInfo(info: *mut SceMsInfo) -> crate::ctypes::c_int;
}
#[link(name = "SceMtpIfDriver_stub", kind = "static")]
#[cfg(feature = "SceMtpIfDriver_stub")]
extern "C" {
    #[doc = "Start MTP driver\n\n # Arguments\n\n* `flags` (direction in) - - Set to 1\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceMtpIfStartDriver(flags: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Stop MTP driver\n\n # Arguments\n\n* `flags` (direction in) - - Set to 1\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceMtpIfStopDriver(flags: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
#[link(name = "SceMusicExport_stub", kind = "static")]
#[cfg(feature = "SceMusicExport_stub")]
extern "C" {
    pub fn sceMusicExportFromFile(
        path: *const crate::ctypes::c_char,
        param: *const MusicExportParam,
        workingMemory: *mut crate::ctypes::c_void,
        cancelCb: *mut crate::ctypes::c_void,
        progress: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void, arg2: crate::ctypes::c_int),
        >,
        user: *mut crate::ctypes::c_void,
        outPath: *mut crate::ctypes::c_char,
        outPathSize: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceNearDialogUtil_stub", kind = "static")]
#[cfg(feature = "SceNearDialogUtil_stub")]
extern "C" {}
#[link(name = "SceNearUtil_stub", kind = "static")]
#[cfg(feature = "SceNearUtil_stub")]
extern "C" {}
#[link(name = "SceNetAdhocMatching_stub", kind = "static")]
#[cfg(feature = "SceNetAdhocMatching_stub")]
extern "C" {}
#[link(name = "SceNetCtl_stub", kind = "static")]
#[cfg(feature = "SceNetCtl_stub")]
extern "C" {
    pub fn sceNetCtlAdhocDisconnect() -> crate::ctypes::c_int;
    pub fn sceNetCtlAdhocGetInAddr(inaddr: *mut SceNetInAddr) -> crate::ctypes::c_int;
    pub fn sceNetCtlAdhocGetPeerList(
        buflen: *mut crate::ctypes::c_uint,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetCtlAdhocGetResult(
        eventType: crate::ctypes::c_int,
        errorCode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetCtlAdhocGetState(state: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetCtlAdhocRegisterCallback(
        func: SceNetCtlCallback,
        arg: *mut crate::ctypes::c_void,
        cid: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetCtlAdhocUnregisterCallback(cid: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetCtlCheckCallback() -> crate::ctypes::c_int;
    pub fn sceNetCtlGetNatInfo(natinfo: *mut SceNetCtlNatInfo) -> crate::ctypes::c_int;
    pub fn sceNetCtlInetGetInfo(
        code: crate::ctypes::c_int,
        info: *mut SceNetCtlInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceNetCtlInetGetResult(
        eventType: crate::ctypes::c_int,
        errorCode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetCtlInetGetState(state: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetCtlInetRegisterCallback(
        func: SceNetCtlCallback,
        arg: *mut crate::ctypes::c_void,
        cid: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetCtlInetUnregisterCallback(cid: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetCtlInit() -> crate::ctypes::c_int;
    pub fn sceNetCtlTerm();
}
#[link(name = "SceNetPsForDriver_stub", kind = "static")]
#[cfg(feature = "SceNetPsForDriver_stub")]
extern "C" {
    pub fn ksceNetAccept(
        s: crate::ctypes::c_int,
        addr: *mut SceNetSockaddr,
        addrlen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetBind(
        s: crate::ctypes::c_int,
        addr: *const SceNetSockaddr,
        addrlen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetClose(s: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceNetConnect(
        s: crate::ctypes::c_int,
        name: *const SceNetSockaddr,
        namelen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetListen(
        s: crate::ctypes::c_int,
        backlog: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetRecvfrom(
        s: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        flags: crate::ctypes::c_int,
        from: *mut SceNetSockaddr,
        fromlen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetSendto(
        s: crate::ctypes::c_int,
        msg: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        flags: crate::ctypes::c_int,
        to: *const SceNetSockaddr,
        tolen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetSetsockopt(
        s: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
        optname: crate::ctypes::c_int,
        optval: *const crate::ctypes::c_void,
        optlen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn ksceNetSocket(
        name: *const crate::ctypes::c_char,
        domain: crate::ctypes::c_int,
        type_: crate::ctypes::c_int,
        protocol: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceNetPs_stub", kind = "static")]
#[cfg(feature = "SceNetPs_stub")]
extern "C" {
    pub fn sceNetSyscallAccept(
        s: crate::ctypes::c_int,
        addr: *mut crate::ctypes::c_void,
        addrlen: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallBind(
        s: crate::ctypes::c_int,
        addr: *const crate::ctypes::c_void,
        addrlen: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallClose(s: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetSyscallConnect(
        s: crate::ctypes::c_int,
        name: *const crate::ctypes::c_void,
        namelen: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallControl(
        if_index: crate::ctypes::c_int,
        code: crate::ctypes::c_int,
        ptr: *mut crate::ctypes::c_void,
        len: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDescriptorClose(id: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDescriptorCreate(
        name: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDescriptorCtl(
        id: crate::ctypes::c_int,
        op: crate::ctypes::c_int,
        s: crate::ctypes::c_int,
        info: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDumpAbort(
        id: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDumpClose(id: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDumpCreate(
        name: *const crate::ctypes::c_char,
        len: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallDumpRead(
        id: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
        len: crate::ctypes::c_int,
        pflags: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallEpollAbort(
        eid: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallEpollClose(eid: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetSyscallEpollCreate(
        name: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallEpollCtl(
        eid: crate::ctypes::c_int,
        op: crate::ctypes::c_int,
        id: crate::ctypes::c_int,
        event: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallEpollWait(param: *mut SceNetSyscallParameter) -> crate::ctypes::c_int;
    #[doc = "Get net if list\n\n # Arguments\n\n* `list` (direction out) - - The output buffer list. size is (0x140 * n)\n * `n` (direction in) - - The output size number.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceNetSyscallGetIfList(
        list: *mut crate::ctypes::c_void,
        n: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallGetSockinfo(
        s: crate::ctypes::c_int,
        ptr: *mut crate::ctypes::c_void,
        n: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallGetpeername(
        s: crate::ctypes::c_int,
        name: *mut crate::ctypes::c_void,
        namelen: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallGetsockname(
        s: crate::ctypes::c_int,
        name: *mut crate::ctypes::c_void,
        namelen: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallGetsockopt(param: *mut SceNetSyscallParameter) -> crate::ctypes::c_int;
    pub fn sceNetSyscallIcmConnect(
        s: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallIoctl(
        s: crate::ctypes::c_int,
        com: crate::ctypes::c_uint,
        data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallListen(
        s: crate::ctypes::c_int,
        backlog: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallRecvfrom(param: *mut SceNetSyscallParameter) -> crate::ctypes::c_int;
    pub fn sceNetSyscallRecvmsg(
        s: crate::ctypes::c_int,
        msg: *mut crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallSendmsg(
        s: crate::ctypes::c_int,
        msg: *const crate::ctypes::c_void,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallSendto(param: *mut SceNetSyscallParameter) -> crate::ctypes::c_int;
    pub fn sceNetSyscallSetsockopt(param: *mut SceNetSyscallParameter) -> crate::ctypes::c_int;
    pub fn sceNetSyscallShutdown(
        s: crate::ctypes::c_int,
        how: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallSocket(
        name: *const crate::ctypes::c_char,
        domain: crate::ctypes::c_int,
        type_: crate::ctypes::c_int,
        protocol: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallSocketAbort(
        s: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSyscallSysctl(param: *mut SceNetSyscallParameter) -> crate::ctypes::c_int;
}
#[link(name = "SceNet_stub", kind = "static")]
#[cfg(feature = "SceNet_stub")]
extern "C" {
    pub fn sceNetAccept(
        s: crate::ctypes::c_int,
        addr: *mut SceNetSockaddr,
        addrlen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetBind(
        s: crate::ctypes::c_int,
        addr: *const SceNetSockaddr,
        addrlen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetClearDnsCache(flags: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetConnect(
        s: crate::ctypes::c_int,
        name: *const SceNetSockaddr,
        namelen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetDumpAbort(
        id: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetDumpCreate(
        name: *const crate::ctypes::c_char,
        len: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetDumpDestroy(id: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetDumpRead(
        id: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
        len: crate::ctypes::c_int,
        pflags: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEmulationGet(
        param: *mut SceNetEmulationParam,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEmulationSet(
        param: *mut SceNetEmulationParam,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEpollAbort(
        eid: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEpollControl(
        eid: crate::ctypes::c_int,
        op: crate::ctypes::c_int,
        id: crate::ctypes::c_int,
        event: *mut SceNetEpollEvent,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEpollCreate(
        name: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEpollDestroy(eid: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetEpollWait(
        eid: crate::ctypes::c_int,
        events: *mut SceNetEpollEvent,
        maxevents: crate::ctypes::c_int,
        timeout: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEpollWaitCB(
        eid: crate::ctypes::c_int,
        events: *mut SceNetEpollEvent,
        maxevents: crate::ctypes::c_int,
        timeout: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get pointer to last network errno.\n\n # Returns\n\npointer to int."]
    pub fn sceNetErrnoLoc() -> *mut crate::ctypes::c_int;
    pub fn sceNetEtherNtostr(
        n: *const SceNetEtherAddr,
        str_: *mut crate::ctypes::c_char,
        len: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetEtherStrton(
        str_: *const crate::ctypes::c_char,
        n: *mut SceNetEtherAddr,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetMacAddress(
        addr: *mut SceNetEtherAddr,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetSockIdInfo(
        fds: *mut SceNetFdSet,
        sockinfoflags: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetSockInfo(
        s: crate::ctypes::c_int,
        info: *mut SceNetSockInfo,
        n: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetStatisticsInfo(
        info: *mut SceNetStatisticsInfo,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetpeername(
        s: crate::ctypes::c_int,
        name: *mut SceNetSockaddr,
        namelen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetsockname(
        s: crate::ctypes::c_int,
        name: *mut SceNetSockaddr,
        namelen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetGetsockopt(
        s: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
        optname: crate::ctypes::c_int,
        optval: *mut crate::ctypes::c_void,
        optlen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetHtonl(host32: crate::ctypes::c_uint) -> crate::ctypes::c_uint;
    pub fn sceNetHtonll(host64: crate::ctypes::c_ulonglong) -> crate::ctypes::c_ulonglong;
    pub fn sceNetHtons(host16: crate::ctypes::c_ushort) -> crate::ctypes::c_ushort;
    pub fn sceNetInetNtop(
        af: crate::ctypes::c_int,
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_char,
        size: crate::ctypes::c_uint,
    ) -> *const crate::ctypes::c_char;
    pub fn sceNetInetPton(
        af: crate::ctypes::c_int,
        src: *const crate::ctypes::c_char,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetInit(param: *mut SceNetInitParam) -> crate::ctypes::c_int;
    pub fn sceNetListen(
        s: crate::ctypes::c_int,
        backlog: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetNtohl(net32: crate::ctypes::c_uint) -> crate::ctypes::c_uint;
    pub fn sceNetNtohll(net64: crate::ctypes::c_ulonglong) -> crate::ctypes::c_ulonglong;
    pub fn sceNetNtohs(net16: crate::ctypes::c_ushort) -> crate::ctypes::c_ushort;
    pub fn sceNetRecv(
        s: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetRecvfrom(
        s: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        flags: crate::ctypes::c_int,
        from: *mut SceNetSockaddr,
        fromlen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetRecvmsg(
        s: crate::ctypes::c_int,
        msg: *mut SceNetMsghdr,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetResolverAbort(
        rid: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetResolverCreate(
        name: *const crate::ctypes::c_char,
        param: *mut SceNetResolverParam,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetResolverDestroy(rid: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetResolverGetError(
        rid: crate::ctypes::c_int,
        result: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetResolverStartAton(
        rid: crate::ctypes::c_int,
        addr: *const SceNetInAddr,
        hostname: *mut crate::ctypes::c_char,
        len: crate::ctypes::c_int,
        timeout: crate::ctypes::c_int,
        retry: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetResolverStartNtoa(
        rid: crate::ctypes::c_int,
        hostname: *const crate::ctypes::c_char,
        addr: *mut SceNetInAddr,
        timeout: crate::ctypes::c_int,
        retry: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSend(
        s: crate::ctypes::c_int,
        msg: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSendmsg(
        s: crate::ctypes::c_int,
        msg: *const SceNetMsghdr,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSendto(
        s: crate::ctypes::c_int,
        msg: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        flags: crate::ctypes::c_int,
        to: *const SceNetSockaddr,
        tolen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSetDnsInfo(
        info: *mut SceNetDnsInfo,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSetsockopt(
        s: crate::ctypes::c_int,
        level: crate::ctypes::c_int,
        optname: crate::ctypes::c_int,
        optval: *const crate::ctypes::c_void,
        optlen: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceNetShowIfconfig(
        p: *mut crate::ctypes::c_void,
        b: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetShowNetstat() -> crate::ctypes::c_int;
    pub fn sceNetShowRoute() -> crate::ctypes::c_int;
    pub fn sceNetShutdown(
        s: crate::ctypes::c_int,
        how: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSocket(
        name: *const crate::ctypes::c_char,
        domain: crate::ctypes::c_int,
        type_: crate::ctypes::c_int,
        protocol: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSocketAbort(
        s: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetSocketClose(s: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceNetTerm() -> crate::ctypes::c_int;
}
#[link(name = "SceNgs_stub", kind = "static")]
#[cfg(feature = "SceNgs_stub")]
extern "C" {
    pub fn sceNgsModuleCheckParamsInRangeInternal(
        handle: SceNgsHVoice,
        module_id: SceNgsModuleID,
        descriptor: *const SceNgsParamsDescriptor,
        size: SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsModuleGetNumPresetsInternal(
        handle: SceNgsHSynSystem,
        module_id: SceNgsModuleID,
        num_presets: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsModuleGetPresetInternal(
        handle: SceNgsHSynSystem,
        module_id: SceNgsModuleID,
        preset_index: SceUInt32,
        info: *mut SceNgsBufferInfo,
    ) -> SceInt32;
    pub fn sceNgsPatchCreateRoutingInternal(
        info: *const SceNgsPatchSetupInfo,
        handle: *mut SceNgsHPatch,
    ) -> SceInt32;
    pub fn sceNgsPatchRemoveRoutingInternal(handle: SceNgsHPatch) -> SceInt32;
    pub fn sceNgsRackGetRequiredMemorySizeInternal(
        handle: SceNgsHSynSystem,
        rack_description: *const SceNgsRackDescription,
        user_size: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsRackGetVoiceHandleInternal(
        rack_handle: SceNgsHRack,
        index: SceUInt32,
        voice_handle: *mut SceNgsHVoice,
    ) -> SceInt32;
    pub fn sceNgsRackInitInternal(
        system_handle: SceNgsHSynSystem,
        rack_buffer: *mut SceNgsBufferInfo,
        rack_description: *const SceNgsRackDescription,
        rack_handle: *mut SceNgsHRack,
    ) -> SceInt32;
    pub fn sceNgsRackReleaseInternal(
        handle: SceNgsHRack,
        callback: SceNgsRackReleaseCallbackFunc,
    ) -> SceInt32;
    pub fn sceNgsRackSetParamErrorCallbackInternal(
        rack_handle: SceNgsHRack,
        callback: SceNgsParamsErrorCallbackFunc,
    ) -> SceInt32;
    pub fn sceNgsSulphaGetInfoInternal(
        obj_reg: *const SulphaNgsRegistration,
        info: *mut SceNgsBufferInfo,
    ) -> SceInt32;
    pub fn sceNgsSulphaGetModuleListInternal(
        module_ids: *mut SceUInt32,
        in_array_count: SceUInt32,
        count: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsSulphaGetSynthUpdateCallbackInternal(
        handle: SceNgsHSynSystem,
        update_callback: *mut SceNgsSulphaUpdateCallback,
        info: *mut SceNgsBufferInfo,
    ) -> SceInt32;
    pub fn sceNgsSulphaQueryModuleInternal(
        type_: SulphaNgsModuleQueryType,
        debug: *mut SulphaNgsModuleQuery,
    ) -> SceInt32;
    pub fn sceNgsSulphaSetSynthUpdateCallbackInternal(
        handle: SceNgsHSynSystem,
        update_callback: SceNgsSulphaUpdateCallback,
        info: *mut SceNgsBufferInfo,
    ) -> SceInt32;
    pub fn sceNgsSystemGetCallbackListInternal(
        handle: SceNgsHSynSystem,
        array: *mut *mut SceNgsCallbackListInfo,
        array_size: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsSystemGetRequiredMemorySizeInternal(
        params: *const SceNgsSystemInitParams,
        size: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsSystemInitInternal(
        buffer_info: *mut SceNgsBufferInfo,
        compiled_sdk_version: SceUInt32,
        params: *const SceNgsSystemInitParams,
        handle: *mut SceNgsHSynSystem,
    ) -> SceInt32;
    pub fn sceNgsSystemLockInternal(handle: SceNgsHSynSystem) -> SceInt32;
    pub fn sceNgsSystemPullDataInternal(
        handle: SceNgsHSynSystem,
        dirty_flags_a: SceUInt32,
        dirty_flags_b: SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsSystemPushDataInternal(handle: SceNgsHSynSystem) -> SceInt32;
    pub fn sceNgsSystemReleaseInternal(handle: SceNgsHSynSystem) -> SceInt32;
    pub fn sceNgsSystemSetFlagsInternal(
        handle: SceNgsHSynSystem,
        system_flags: SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsSystemSetParamErrorCallbackInternal(
        handle: SceNgsHSynSystem,
        callback_id: SceNgsParamsErrorCallbackFunc,
    ) -> SceInt32;
    pub fn sceNgsSystemUnlockInternal(handle: SceNgsHSynSystem) -> SceInt32;
    pub fn sceNgsSystemUpdateInternal(handle: SceNgsHSynSystem) -> SceInt32;
    pub fn sceNgsVoiceBypassModuleInternal(
        handle: SceNgsHVoice,
        module: SceUInt32,
        flag: SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsVoiceClearDirtyFlagInternal(
        handle: SceNgsHVoice,
        param_bit_flag: SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsVoiceDefGetAtrac9VoiceInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetCompressorBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetCompressorSideChainBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetDelayBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetDistortionBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetEnvelopeBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetEqBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetMasterBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetMixerBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetPauserBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetPitchshiftBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetReverbBussInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetSasEmuVoiceInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetScreamVoiceAT9Internal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetScreamVoiceInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetSimpleAtrac9VoiceInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetSimpleVoiceInternal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefGetTemplate1Internal() -> *const SceNgsVoiceDefinition;
    pub fn sceNgsVoiceDefinitionGetPresetInternal(
        definition: *const SceNgsVoiceDefinition,
        index: SceUInt32,
        presets: *mut *const SceNgsVoicePreset,
    ) -> SceInt32;
    pub fn sceNgsVoiceGetModuleBypassInternal(
        handle: SceNgsHVoice,
        module: SceUInt32,
        flag: *mut SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsVoiceGetOutputPatchInternal(
        handle: SceNgsHVoice,
        nOutputIndex: SceInt32,
        nSubIndex: SceInt32,
        pPatchHandle: *mut SceNgsHPatch,
    ) -> SceInt32;
    pub fn sceNgsVoiceGetParamsOutOfRangeBufferedInternal(
        handle: SceNgsHVoice,
        module: SceUInt32,
        message_buffer: *mut crate::ctypes::c_char,
    ) -> SceInt32;
    pub fn sceNgsVoiceInitInternal(
        handle: SceNgsHVoice,
        preset: *const SceNgsVoicePreset,
        flags: SceUInt32,
    ) -> SceInt32;
    pub fn sceNgsVoiceKeyOffInternal(handle: SceNgsHVoice) -> SceInt32;
    pub fn sceNgsVoiceKillInternal(handle: SceNgsHVoice) -> SceInt32;
    pub fn sceNgsVoicePauseInternal(handle: SceNgsHVoice) -> SceInt32;
    pub fn sceNgsVoicePlayInternal(handle: SceNgsHVoice) -> SceInt32;
    pub fn sceNgsVoiceResumeInternal(handle: SceNgsHVoice) -> SceInt32;
    pub fn sceNgsVoiceSetAllBypassesInternal(handle: SceNgsHVoice, bitflag: SceUInt32) -> SceInt32;
    pub fn sceNgsVoiceSetFinishedCallbackInternal(
        handle: SceNgsHVoice,
        callback: SceNgsCallbackFunc,
        userdata: *mut crate::ctypes::c_void,
    ) -> SceInt32;
    pub fn sceNgsVoiceSetModuleCallbackInternal(
        handle: SceNgsHVoice,
        module: SceUInt32,
        callback: SceNgsModuleCallbackFunc,
        callback_userdata: *mut crate::ctypes::c_void,
    ) -> SceInt32;
    pub fn sceNgsVoiceSetPresetInternal(
        handle: SceNgsHVoice,
        preset: *const SceNgsVoicePreset,
    ) -> SceInt32;
}
#[link(name = "SceNgsUser_stub", kind = "static")]
#[cfg(feature = "SceNgsUser_stub")]
extern "C" {}
#[link(name = "SceNotificationUtil_stub", kind = "static")]
#[cfg(feature = "SceNotificationUtil_stub")]
extern "C" {
    #[doc = "Initialize notification util for use with BG application.\n\n Does not need to be called for normal applications."]
    pub fn sceNotificationUtilBgAppInitialize() -> SceInt32;
    #[doc = "Clean notifications for calling app from notification history."]
    pub fn sceNotificationUtilCleanHistory() -> SceInt32;
    #[doc = "Start BGDL-type notification."]
    pub fn sceNotificationUtilProgressBegin(
        initParams: *mut SceNotificationUtilProgressInitParam,
    ) -> SceInt32;
    #[doc = "Finish BGDL-type notification."]
    pub fn sceNotificationUtilProgressFinish(
        finishParams: *mut SceNotificationUtilProgressFinishParam,
    ) -> SceInt32;
    #[doc = "Update BGDL-type notification."]
    pub fn sceNotificationUtilProgressUpdate(
        updateParams: *mut SceNotificationUtilProgressUpdateParam,
    ) -> SceInt32;
    #[doc = "Send notification.\n\n Text buffer size must be 0x410."]
    pub fn sceNotificationUtilSendNotification(text: *const SceWChar16) -> SceInt32;
}
#[link(name = "SceNpActivity_stub", kind = "static")]
#[cfg(feature = "SceNpActivity_stub")]
extern "C" {}
#[link(name = "SceNpBasic_stub", kind = "static")]
#[cfg(feature = "SceNpBasic_stub")]
extern "C" {}
#[link(name = "SceNpCommerce2_stub", kind = "static")]
#[cfg(feature = "SceNpCommerce2_stub")]
extern "C" {}
#[link(name = "SceNpCommon_stub", kind = "static")]
#[cfg(feature = "SceNpCommon_stub")]
extern "C" {}
#[link(name = "SceNpDrmForDriver_stub", kind = "static")]
#[cfg(feature = "SceNpDrmForDriver_stub")]
extern "C" {
    #[doc = "Check you have npdrm activation data, and get information from it\n\n # Arguments\n\n* `act_type` (direction out) - - The pointer of activation type output.\n * `version_flag` (direction out) - - The pointer of version flag output.\n * `account_id` (direction out) - - The pointer of activated account id output.\n * `act_start_time` (direction out) - - The pointer of activation data start time output.\n * `act_exp_time` (direction out) - - The pointer of activation data expire time output\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmCheckActData(
        act_type: *mut crate::ctypes::c_int,
        version_flag: *mut crate::ctypes::c_int,
        account_id: *mut SceUInt64,
        act_start_time: *mut SceUInt64,
        act_end_time: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert an older 0x100 byte eboot.pbp signature \"__sce_ebootpbp\" to a 0x200 byte one used in firmwares >2.00\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `old_eboot_signature` (direction in) - - The pointer of old eboot signature data. size is 0x100\n * `new_eboot_signature` (direction out) - - The pointer of new eboot signature data. size is 0x200\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn ksceNpDrmEbootSigConvert(
        eboot_pbp_path: *const crate::ctypes::c_char,
        old_eboot_signature: *const crate::ctypes::c_void,
        new_eboot_signature: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate eboot.pbp signature \"__sce_discinfo\" for a multi-disc PS1 game\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `sce_discinfo` (direction in) - - The pointer of contents of vs0:/app/NPXS10028/__sce_discinfo\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x100\n * `sw_version` (direction in) - - The minimum firmware version the signature can be used on. cannot be lower than current firmware\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn ksceNpDrmEbootSigGenMultiDisc(
        eboot_pbp_path: *const crate::ctypes::c_char,
        sce_discinfo: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
        sw_version: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate eboot.pbp signature \"__sce_ebootpbp\" for a single-disc PS1 game\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_sha256` (direction in) - - The pointer of SHA256 hash of first (data.psar offset + 0x1C0000) bytes into the EBOOT.PBP file\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x200\n * `sw_version` (direction in) - - The minimum firmware version the signature can be used on. cannot be lower than current firmware\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn ksceNpDrmEbootSigGenPs1(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_sha256: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
        sw_version: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate eboot.pbp signature \"__sce_ebootpbp\" for a PSP game\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_sha256` (direction in) - - The pointer of SHA256 hash of first (data.psar offset + 0x1C0000) bytes into the EBOOT.PBP file\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x200\n * `sw_version` (direction in) - - The minimum firmware version the signature can be used on. cannot be lower than current firmware\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn ksceNpDrmEbootSigGenPsp(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_sha256: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
        sw_version: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Verify a eboot.pbp signature \"__sce_ebootpbp\"\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_signature` (direction in) - - The pointer of data of __sce_ebootpbp signature. size is 0x200\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmEbootSigVerify(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_signature: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get license file name with fixed\n\n # Arguments\n\n* `name` (direction out) - - The pointer of license file name output buffer. size is 0x30.\n * `aid` (direction in) - - The license account id\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmGetFixedRifName(
        name: *mut crate::ctypes::c_char,
        aid: SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get license info\n\n # Arguments\n\n* `license` (direction in) - - The pointer of license data. see:SceNpDrmLicense\n * `license_size` (direction in) - - The license data size. 0x200 etc\n * `check_sign` (direction in) - - The license signature check flag. if pass 1, do check.\n * `content_id` (direction out) - - The pointer of license content_id output buffer. size is 0x30.\n * `account_id` (direction out) - - The pointer of license account_id output.\n * `license_version` (direction out) - - The pointer of license version output.\n * `license_flags` (direction out) - - The pointer of license flags output.\n * `flags` (direction out) - - The pointer of flags output.\n * `sku_flags` (direction out) - - The pointer of sku flags output.\n * `lic_start_time` (direction out) - - The pointer of license start time output.\n * `lic_exp_time` (direction out) - - The pointer of license exp time output.\n * `flags2` (direction out) - - The pointer of flags2 output.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmGetRifInfo(
        license: *const crate::ctypes::c_void,
        license_size: SceSize,
        check_sign: crate::ctypes::c_int,
        content_id: *mut crate::ctypes::c_char,
        account_id: *mut SceUInt64,
        license_version: *mut crate::ctypes::c_int,
        license_flags: *mut crate::ctypes::c_int,
        flags: *mut crate::ctypes::c_int,
        sku_flags: *mut crate::ctypes::c_int,
        lic_start_time: *mut SceInt64,
        lic_exp_time: *mut SceInt64,
        flags2: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get license file name\n\n # Arguments\n\n* `name` (direction out) - - The pointer of license file name output buffer. size is 0x30.\n * `aid` (direction in) - - The license account id\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmGetRifName(
        name: *mut crate::ctypes::c_char,
        aid: SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get license key info for a PSP game\n\n # Arguments\n\n* `license` (direction in) - - The pointer of license data. see:SceNpDrmLicense\n * `klicense` (direction out) - - The pointer of klicense output buffer. size is 0x10.\n * `flags` (direction out) - - The pointer of flags output.\n * `lic_start_time` (direction out) - - The pointer of license start time output.\n * `lic_exp_time` (direction out) - - The pointer of license exp time output.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmGetRifPspKey(
        license: *const crate::ctypes::c_void,
        klicense: *mut crate::ctypes::c_void,
        flags: *mut crate::ctypes::c_int,
        lic_start_time: *mut SceUInt64,
        lic_exp_time: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get license key info\n\n # Arguments\n\n* `license` (direction in) - - The pointer of license data. see:SceNpDrmLicense\n * `klicense` (direction out) - - The pointer of klicense output buffer. size is 0x10.\n * `flags` (direction out) - - The pointer of flags output.\n * `sku_flags` (direction out) - - The pointer of sku flags output.\n * `lic_start_time` (direction out) - - The pointer of license start time output.\n * `lic_exp_time` (direction out) - - The pointer of license exp time output.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmGetRifVitaKey(
        license: *const crate::ctypes::c_void,
        klicense: *mut crate::ctypes::c_void,
        flags: *mut crate::ctypes::c_int,
        sku_flags: *mut crate::ctypes::c_int,
        lic_start_time: *mut SceUInt64,
        lic_exp_time: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate an older 0x100 byte eboot.pbp signature \"__sce_ebootpbp\" for a PSP game - this is unused in firmware >2.00\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_sha256` (direction in) - - The pointer of SHA256 hash of first (data.psar offset + 0x1C0000) bytes into the EBOOT.PBP file\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x100\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn ksceNpDrmPspEbootSigGen(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_sha256: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Verify an older 0x100 byte eboot.pbp signature \"__sce_ebootpbp\" from firmware <2.00\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_signature` (direction in) - - The pointer of data of __sce_ebootpbp signature. size is 0x100\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmPspEbootVerify(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_signature: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get current activation data\n\n # Arguments\n\n* `act_data` (direction out) - - The pointer of output activation data see:SceNpDrmActivationData. if ecdsa or rsa verify fail, will be all 0.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceNpDrmReadActData(act_data: *mut SceNpDrmActivationData) -> crate::ctypes::c_int;
}
#[link(name = "SceNpDrm_stub", kind = "static")]
#[cfg(feature = "SceNpDrm_stub")]
extern "C" {
    #[doc = "Check you have npdrm activation data, and get information from it\n\n # Arguments\n\n* `act_type` (direction out) - - The pointer of activation type output.\n\n * `version_flag` (direction out) - - The pointer of version flag output.\n\n * `account_id` (direction out) - - The pointer of activated account id output.\n\n * `act_exp_time` (direction out) - - The pointer of activation expire time output, \\[0\\] is start_date, \\[1\\] is end_date\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceNpDrmCheckActData(
        act_type: *mut crate::ctypes::c_int,
        version_flag: *mut crate::ctypes::c_int,
        account_id: *mut SceUInt64,
        act_exp_time: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get fixed rif name\n\n # Arguments\n\n* `rif_name` (direction out) - - RIF name buffer (48 bytes)\n\n * `aid` (direction in) - - Account ID\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceNpDrmGetFixedRifName(
        rif_name: *mut crate::ctypes::c_char,
        aid: u64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get rif name\n\n # Arguments\n\n* `rif_name` (direction out) - - RIF name buffer (48 bytes)\n\n * `aid` (direction in) - - Account ID\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceNpDrmGetRifName(
        rif_name: *mut crate::ctypes::c_char,
        aid: u64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get rif name for install\n\n # Arguments\n\n* `rif_name` (direction out) - - RIF name buffer (48 bytes)\n\n * `rif_data` (direction in) - - Data of RIF file (512 bytes)\n\n * `unk` (direction in) - - Unknown, use 0\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceNpDrmGetRifNameForInstall(
        rif_name: *mut crate::ctypes::c_char,
        rif_data: *const crate::ctypes::c_void,
        unk: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Read the header of the PKG and initialize the context\n\n # Arguments\n\n* `buffer` - - The buffer containing the header of PKG.\n * `size` - - The size of buffer. The minimum confirmed value is 0x8000.\n * `zero` - - Unknown. Supposed to be set to 0.\n * `identifier` - - arbitrary value [0, 6) ORed with (1 << 8) or 0.\n If it is set to 0, the function just checks the header\n and doesn't create the context.\n\n # Returns\n\n0 on success, != 0 on error"]
    pub fn _sceNpDrmPackageCheck(
        buffer: *const crate::ctypes::c_void,
        size: SceSize,
        zero: crate::ctypes::c_int,
        identifier: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Decrypt a PKG\n\n # Arguments\n\n* `buffer` - - The buffer containing the content of the PKG.\n * `size` - - The size of the buffer. The minimum confirmed value is 0x20.\n * `opt` - - The options.\n\n # Returns\n\n0 on success, != 0 on error"]
    pub fn _sceNpDrmPackageDecrypt(
        buffer: *mut crate::ctypes::c_void,
        size: SceSize,
        opt: *mut _sceNpDrmPackageDecrypt_opt,
    ) -> crate::ctypes::c_int;
    #[doc = "Get PSM rif key\n\n # Arguments\n\n* `license_buf` (direction in) - - RIF buffer (1024 bytes)\n\n * `keydata` (direction out) - - Decrypted key data\n\n * `flags` (direction in) - - Unknown\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePsmDrmGetRifKey(
        license_buf: *const ScePsmDrmLicense,
        keydata: *mut crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceNpManager_stub", kind = "static")]
#[cfg(feature = "SceNpManager_stub")]
extern "C" {}
#[link(name = "SceNpMatching2_stub", kind = "static")]
#[cfg(feature = "SceNpMatching2_stub")]
extern "C" {}
#[link(name = "SceNpMessage_stub", kind = "static")]
#[cfg(feature = "SceNpMessage_stub")]
extern "C" {}
#[link(name = "SceNpParty_stub", kind = "static")]
#[cfg(feature = "SceNpParty_stub")]
extern "C" {}
#[link(name = "SceNpScore_stub", kind = "static")]
#[cfg(feature = "SceNpScore_stub")]
extern "C" {}
#[link(name = "SceNpSignaling_stub", kind = "static")]
#[cfg(feature = "SceNpSignaling_stub")]
extern "C" {}
#[link(name = "SceNpSnsFacebook_stub", kind = "static")]
#[cfg(feature = "SceNpSnsFacebook_stub")]
extern "C" {}
#[link(name = "SceNpTrophy_stub", kind = "static")]
#[cfg(feature = "SceNpTrophy_stub")]
extern "C" {}
#[link(name = "SceNpTus_stub", kind = "static")]
#[cfg(feature = "SceNpTus_stub")]
extern "C" {}
#[link(name = "SceNpUtility_stub", kind = "static")]
#[cfg(feature = "SceNpUtility_stub")]
extern "C" {}
#[link(name = "SceNpWebApi_stub", kind = "static")]
#[cfg(feature = "SceNpWebApi_stub")]
extern "C" {}
#[link(name = "SceOledForDriver_stub", kind = "static")]
#[cfg(feature = "SceOledForDriver_stub")]
extern "C" {}
#[link(name = "ScePaf_stub", kind = "static")]
#[cfg(feature = "ScePaf_stub")]
extern "C" {
    pub fn scePafCreateHeap(
        context: *mut ScePafHeapContext,
        membase: *mut crate::ctypes::c_void,
        size: SceSize,
        name: *const crate::ctypes::c_char,
        opt: *mut ScePafHeapOpt,
    );
    pub fn scePafDeleteHeap(context: *mut ScePafHeapContext);
    pub fn scePafFreeWithContext(context: *mut ScePafHeapContext, ptr: *mut crate::ctypes::c_void);
    pub fn scePafGetCurrentClockLocalTime(data: *mut ScePafDateTime) -> crate::ctypes::c_int;
    pub static mut scePafGraphicsCurrentWave: SceUInt32;
    #[doc = "Update the current wave\n\n # Arguments\n\n* `index` (direction in) - - The index from 0 to 0x1F within range.\n * `update_interval` (direction in) - - The update interval. 0.0f to it will change soon. 1.0f will slowly turn into an updated wave after 1 second, just like when you change it the normal way.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn scePafGraphicsUpdateCurrentWave(
        index: SceUInt32,
        update_interval: SceFloat32,
    ) -> crate::ctypes::c_int;
    pub fn scePafMallocAlignWithContext(
        context: *mut ScePafHeapContext,
        align: SceUInt32,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn scePafMallocWithContext(
        context: *mut ScePafHeapContext,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn scePafReallocWithContext(
        context: *mut ScePafHeapContext,
        ptr: *mut crate::ctypes::c_void,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn scePafSha1Init(context: *mut ScePafSha1Context) -> crate::ctypes::c_int;
    pub fn scePafSha1Result(
        context: *mut ScePafSha1Context,
        dst: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn scePafSha1Update(
        context: *mut ScePafSha1Context,
        data: *const crate::ctypes::c_void,
        length: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_bcmp(
        ptr1: *const crate::ctypes::c_void,
        ptr2: *const crate::ctypes::c_void,
        num: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_bcopy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        n: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sce_paf_bzero(dst: *mut crate::ctypes::c_void, n: SceSize)
        -> *mut crate::ctypes::c_void;
    pub fn sce_paf_free(ptr: *mut crate::ctypes::c_void);
    pub fn sce_paf_malloc(size: SceSize) -> *mut crate::ctypes::c_void;
    #[doc = "Alloc memory with align\n\n # Arguments\n\n* `align` (direction in) - The align size\n * `length` (direction in) - The alloc length\n\n # Returns\n\nmemory pointer or NULL"]
    pub fn sce_paf_memalign(align: SceSize, length: SceSize) -> *mut crate::ctypes::c_void;
    pub fn sce_paf_memchr(
        src: *const crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        length: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sce_paf_memcmp(
        s1: *const crate::ctypes::c_void,
        s2: *const crate::ctypes::c_void,
        n: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_memcpy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sce_paf_memmove(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sce_paf_memset(
        dst: *mut crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        len: SceSize,
    ) -> *mut crate::ctypes::c_void;
    pub fn sce_paf_snprintf(
        dst: *mut crate::ctypes::c_char,
        max: crate::ctypes::c_uint,
        fmt: *const crate::ctypes::c_char,
        ...
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_strcasecmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_strchr(
        s: *const crate::ctypes::c_char,
        ch: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_char;
    pub fn sce_paf_strcmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_strlen(s: *const crate::ctypes::c_char) -> usize;
    pub fn sce_paf_strncasecmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_strncmp(
        s1: *const crate::ctypes::c_char,
        s2: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn sce_paf_strncpy(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> *mut crate::ctypes::c_char;
    pub fn sce_paf_strrchr(
        s: *const crate::ctypes::c_char,
        ch: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_char;
    #[doc = "string to double\n\n # Arguments\n\n* `nptr` (direction in) - The input float string\n * `endptr` (direction out) - The float string endpoint\n\n # Returns\n\nparsed value"]
    pub fn sce_paf_strtod(
        nptr: *const crate::ctypes::c_char,
        endptr: *mut *mut crate::ctypes::c_char,
    ) -> f64;
    pub fn sce_paf_vsnprintf(
        dst: *mut crate::ctypes::c_char,
        max: crate::ctypes::c_uint,
        fmt: *const crate::ctypes::c_char,
        arg: va_list,
    ) -> crate::ctypes::c_int;
}
#[link(name = "ScePamgr_stub", kind = "static")]
#[cfg(feature = "ScePamgr_stub")]
extern "C" {
    pub fn _sceKernelPaAddArmTraceByKey(
        key: crate::ctypes::c_int,
        param: *const SceKernelPaArmTraceParam,
    ) -> crate::ctypes::c_int;
    pub fn _sceKernelPaAddCounterTraceByKey(
        key: crate::ctypes::c_int,
        param: *const SceKernelPaCounterTraceParam,
    ) -> crate::ctypes::c_int;
    pub fn _sceKernelPaAddGpuTraceByKey(
        key: crate::ctypes::c_int,
        param: *const SceKernelPaGpuTraceParam,
    ) -> crate::ctypes::c_int;
    pub fn _sceKernelPaGetGpuSampledData(
        data: *mut SceKernelPaGpuSampledData,
    ) -> crate::ctypes::c_int;
    pub fn _sceKernelPaSetupTraceBufferByKey(
        key: crate::ctypes::c_int,
        param: *const SceKernelPaTraceBufferParam,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelPaGetIoBaseAddress() -> SceUInt32;
    pub fn sceKernelPaGetTimebaseFrequency() -> SceUInt32;
    pub fn sceKernelPaGetTimebaseValue() -> SceUInt64;
    pub fn sceKernelPaGetTraceBufferSize(type_: SceUInt32) -> SceSize;
    pub fn sceKernelPaGetTraceBufferStatus() -> SceUInt32;
    pub fn sceKernelPaGetWritePointer() -> SceUInt32;
    pub fn sceKernelPaInsertBookmark(
        fifo: SceUInt32,
        channel: SceUInt32,
        data: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelPaRegister() -> crate::ctypes::c_int;
    pub fn sceKernelPaRemoveArmTraceByKey(key: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceKernelPaRemoveCounterTraceByKey(key: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceKernelPaRemoveGpuTraceByKey(key: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceKernelPaSetBookmarkChannelEnableByKey(
        key: crate::ctypes::c_int,
        fifo: SceUInt32,
        mask: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelPaStartByKey(key: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceKernelPaStopByKey(key: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceKernelPaUnregister(key: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonClose() -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonOpen() -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonReset(threadId: SceUID) -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonSelectEvent(
        threadId: SceUID,
        counter: SceUInt32,
        eventCode: SceUInt8,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonSetCounterValue(
        threadId: SceUID,
        counter: SceUInt32,
        value: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonStart(threadId: SceUID) -> crate::ctypes::c_int;
    pub fn sceKernelPerfArmPmonStop(threadId: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "ScePerf_stub", kind = "static")]
#[cfg(feature = "ScePerf_stub")]
extern "C" {
    pub fn scePerfArmPmonGetCounterValue(
        thid: SceUID,
        counter: SceUInt32,
        value: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn scePerfArmPmonReset(thid: SceUID) -> crate::ctypes::c_int;
    pub fn scePerfArmPmonSelectEvent(
        thid: SceUID,
        counter: SceUInt32,
        event_code: SceUInt8,
    ) -> crate::ctypes::c_int;
    pub fn scePerfArmPmonSetCounterValue(
        thid: SceUID,
        counter: SceUInt32,
        value: SceUInt32,
    ) -> crate::ctypes::c_int;
    pub fn scePerfArmPmonSoftwareIncrement(mask: SceUInt32) -> crate::ctypes::c_int;
    pub fn scePerfArmPmonStart(thid: SceUID) -> crate::ctypes::c_int;
    pub fn scePerfArmPmonStop(thid: SceUID) -> crate::ctypes::c_int;
    pub fn scePerfGetTimebaseFrequency() -> SceUInt32;
    pub fn scePerfGetTimebaseValue() -> SceUInt64;
}
#[link(name = "ScePervasiveForDriver_stub", kind = "static")]
#[cfg(feature = "ScePervasiveForDriver_stub")]
extern "C" {
    pub fn kscePervasiveDsiClockDisable(
        port: crate::ctypes::c_int,
        mask: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn kscePervasiveDsiClockEnable(
        port: crate::ctypes::c_int,
        mask: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn kscePervasiveDsiResetDisable(
        port: crate::ctypes::c_int,
        mask: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn kscePervasiveDsiResetEnable(
        port: crate::ctypes::c_int,
        mask: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn kscePervasiveDsiSetPixelClock(
        port: crate::ctypes::c_int,
        pixelclock: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn kscePervasiveGetSoCRevision() -> SceUInt32;
    pub fn kscePervasiveGpioClockDisable() -> crate::ctypes::c_int;
    pub fn kscePervasiveGpioClockEnable() -> crate::ctypes::c_int;
    pub fn kscePervasiveGpioResetDisable() -> crate::ctypes::c_int;
    pub fn kscePervasiveGpioResetEnable() -> crate::ctypes::c_int;
    pub fn kscePervasiveMsifClockDisable() -> crate::ctypes::c_int;
    pub fn kscePervasiveMsifClockEnable() -> crate::ctypes::c_int;
    pub fn kscePervasiveMsifResetDisable() -> crate::ctypes::c_int;
    pub fn kscePervasiveMsifResetEnable() -> crate::ctypes::c_int;
    pub fn kscePervasiveMsifSetClock(clock: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    pub fn kscePervasiveRemovableMemoryGetCardInsertState() -> crate::ctypes::c_int;
    pub fn kscePervasiveSpiClockDisable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveSpiClockEnable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveSpiResetDisable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveSpiResetEnable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveUartClockDisable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveUartClockEnable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveUartResetDisable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveUartResetEnable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn kscePervasiveUartSetBaudrate(
        port: crate::ctypes::c_int,
        baudrate: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
#[link(name = "ScePfsMgrForKernel_stub", kind = "static")]
#[cfg(feature = "ScePfsMgrForKernel_stub")]
extern "C" {
    pub fn kscePfsApprove(
        rnd_drive_id: *const ScePfsRndDriveId,
        program_authority_id: SceUInt64,
    ) -> crate::ctypes::c_int;
    pub fn kscePfsDisapprove(
        rnd_drive_id: *const ScePfsRndDriveId,
        program_authority_id: SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount pfs directory\n\n # Arguments\n\n* `path` (direction in) - - The pfs encrypted directory path\n * `rnd_drive_id` (direction in) - - The pfs mount target Pseudo Drive strings\n * `authid` (direction in) - - The authid\n * `klicensee` (direction in) - - The klicensee\n * `mode_index` (direction in) - - The mode_index\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn kscePfsMount(
        path: *const crate::ctypes::c_char,
        rnd_drive_id: *const ScePfsRndDriveId,
        program_authority_id: SceUInt64,
        klicensee: *const crate::ctypes::c_void,
        mode_index: u16,
    ) -> crate::ctypes::c_int;
    #[doc = "Mount pfs directory without authid\n\n # Arguments\n\n* `path` (direction in) - - The pfs encrypted directory path\n * `rnd_drive_id` (direction in) - - The pfs mount target Pseudo Drive strings\n * `klicensee` (direction in) - - The klicensee\n * `mode_index` (direction in) - - The mode_index\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn kscePfsMount2(
        path: *const crate::ctypes::c_char,
        rnd_drive_id: *const ScePfsRndDriveId,
        klicensee: *const crate::ctypes::c_void,
        mode_index: u16,
    ) -> crate::ctypes::c_int;
    #[doc = "Unmount pfs directory\n\n # Arguments\n\n* `rnd_drive_id` (direction in) - - The pfs mount drive strings\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn kscePfsUnmount(rnd_drive_id: *const ScePfsRndDriveId) -> crate::ctypes::c_int;
}
#[link(name = "ScePgf_stub", kind = "static")]
#[cfg(feature = "ScePgf_stub")]
extern "C" {
    pub fn sceFontClose(fontHandle: SceFontHandle) -> crate::ctypes::c_int;
    pub fn sceFontDoneLib(libHandle: SceFontLibHandle) -> crate::ctypes::c_int;
    pub fn sceFontFindFont(
        libHandle: SceFontLibHandle,
        fontStyle: *mut SceFontStyle,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceFontFindOptimumFont(
        libHandle: SceFontLibHandle,
        fontStyle: *mut SceFontStyle,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceFontFlush(fontHandle: SceFontHandle) -> crate::ctypes::c_int;
    pub fn sceFontGetCharGlyphImage(
        fontHandle: SceFontHandle,
        charCode: crate::ctypes::c_uint,
        glyphImage: *mut SceFontGlyphImage,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetCharGlyphImage_Clip(
        fontHandle: SceFontHandle,
        charCode: crate::ctypes::c_uint,
        glyphImage: *mut SceFontGlyphImage,
        clipXPos: crate::ctypes::c_int,
        clipYPos: crate::ctypes::c_int,
        clipWidth: crate::ctypes::c_int,
        clipHeight: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetCharImageRect(
        fontHandle: SceFontHandle,
        charCode: crate::ctypes::c_uint,
        charRect: *mut SceFontImageRect,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetCharInfo(
        fontHandle: SceFontHandle,
        charCode: crate::ctypes::c_uint,
        charInfo: *mut SceFontCharInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetFontInfo(
        fontHandle: SceFontHandle,
        fontInfo: *mut SceFontInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetFontInfoByIndexNumber(
        libHandle: SceFontLibHandle,
        fontStyle: *mut SceFontStyle,
        unknown: crate::ctypes::c_int,
        fontIndex: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetFontList(
        libHandle: SceFontLibHandle,
        fontStyle: *mut SceFontStyle,
        numFonts: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceFontGetNumFontList(
        libHandle: SceFontLibHandle,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceFontNewLib(
        params: *mut SceFontNewLibParams,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> SceFontLibHandle;
    pub fn sceFontOpen(
        libHandle: SceFontLibHandle,
        index: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> SceFontHandle;
    pub fn sceFontOpenUserFile(
        libHandle: SceFontLibHandle,
        file: *mut crate::ctypes::c_char,
        mode: crate::ctypes::c_int,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> SceFontHandle;
    pub fn sceFontOpenUserMemory(
        libHandle: SceFontLibHandle,
        pMemoryFont: *mut crate::ctypes::c_void,
        pMemoryFontSize: SceSize,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> SceFontHandle;
    pub fn sceFontPixelToPointH(
        libHandle: SceFontLibHandle,
        fontPixelsH: f32,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> f32;
    pub fn sceFontPixelToPointV(
        libHandle: SceFontLibHandle,
        fontPixelsV: f32,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> f32;
    pub fn sceFontPointToPixelH(
        libHandle: SceFontLibHandle,
        fontPointsH: f32,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> f32;
    pub fn sceFontPointToPixelV(
        libHandle: SceFontLibHandle,
        fontPointsV: f32,
        errorCode: *mut crate::ctypes::c_uint,
    ) -> f32;
    pub fn sceFontSetAltCharacterCode(
        libHandle: SceFontLibHandle,
        charCode: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceFontSetResolution(
        libHandle: SceFontLibHandle,
        hRes: f32,
        vRes: f32,
    ) -> crate::ctypes::c_int;
}
#[link(name = "ScePhotoExport_stub", kind = "static")]
#[cfg(feature = "ScePhotoExport_stub")]
extern "C" {
    pub fn scePhotoExportFromData(
        data: *const crate::ctypes::c_void,
        size: SceSize,
        param: *const PhotoExportParam,
        workingMemory: *mut crate::ctypes::c_void,
        cancelCb: *mut crate::ctypes::c_void,
        user: *mut crate::ctypes::c_void,
        outPath: *mut crate::ctypes::c_char,
        outPathSize: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn scePhotoExportFromFile(
        path: *const crate::ctypes::c_char,
        param: *const PhotoExportParam,
        workingMemory: *mut crate::ctypes::c_void,
        cancelCb: *mut crate::ctypes::c_void,
        user: *mut crate::ctypes::c_void,
        outPath: *mut crate::ctypes::c_char,
        outPathSize: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "ScePmMgrForDriver_stub", kind = "static")]
#[cfg(feature = "ScePmMgrForDriver_stub")]
extern "C" {
    pub fn kscePmMgrGetProductMode(result: *mut SceProductMode) -> crate::ctypes::c_int;
    pub fn kscePmMgrIsExternalBootMode() -> crate::ctypes::c_int;
}
#[link(name = "ScePowerForDriver_stub", kind = "static")]
#[cfg(feature = "ScePowerForDriver_stub")]
extern "C" {
    #[doc = "Returns CPU clock frequency\n\n # Returns\n\nCPU clock frequency in Mhz"]
    pub fn kscePowerGetArmClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns battery cycle count\n\n # Returns\n\nbattery cycle count"]
    pub fn kscePowerGetBatteryCycleCount() -> crate::ctypes::c_int;
    #[doc = "Returns battery full capacity\n\n # Returns\n\nbattery full capacity in mAh (milliampere hour)"]
    pub fn kscePowerGetBatteryFullCapacity() -> crate::ctypes::c_int;
    #[doc = "Returns battery life percentage\n\n # Returns\n\nBattery life percentage"]
    pub fn kscePowerGetBatteryLifePercent() -> crate::ctypes::c_int;
    #[doc = "Returns battery life time\n\n # Returns\n\nBattery life time in minutes"]
    pub fn kscePowerGetBatteryLifeTime() -> crate::ctypes::c_int;
    #[doc = "Returns battery remaining capacity\n\n # Returns\n\nbattery remaining capacity in mAh (milliampere hour)"]
    pub fn kscePowerGetBatteryRemainCapacity() -> crate::ctypes::c_int;
    #[doc = "Returns battery state of health\n\n # Returns\n\nbattery state of health percent"]
    pub fn kscePowerGetBatterySOH() -> crate::ctypes::c_int;
    #[doc = "Returns battery temperature\n\n # Returns\n\ntemperature in degrees celcius * 100"]
    pub fn kscePowerGetBatteryTemp() -> crate::ctypes::c_int;
    #[doc = "Returns battery voltage\n\n # Returns\n\nbattery voltage in mV (millivolts)"]
    pub fn kscePowerGetBatteryVolt() -> crate::ctypes::c_int;
    #[doc = "Returns BUS clock frequency\n\n # Returns\n\nBUS clock frequency in Mhz"]
    pub fn kscePowerGetBusClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns GPU crossbar clock frequency\n\n # Returns\n\nGPU crossbar clock frequency in Mhz"]
    pub fn kscePowerGetGpuXbarClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns Sys clock frequency\n\n # Returns\n\nSys clock frequency in Mhz"]
    pub fn kscePowerGetSysClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns battery charging status\n\n # Returns\n\nSCE_TRUE if under charge, SCE_FALSE otherwise"]
    pub fn kscePowerIsBatteryCharging() -> SceBool;
    #[doc = "Returns battery state\n\n # Returns\n\nSCE_TRUE if battery is low, SCE_FALSE otherwise"]
    pub fn kscePowerIsLowBattery() -> SceBool;
    #[doc = "Check if AC is plugged in\n\n # Returns\n\nSCE_TRUE if plugged in, SCE_FALSE otherwise"]
    pub fn kscePowerIsPowerOnline() -> SceBool;
    #[doc = "Check if a suspend is required\n\n # Returns\n\nSCE_TRUE if suspend is required, SCE_FALSE otherwise"]
    pub fn kscePowerIsSuspendRequired() -> SceBool;
    #[doc = "Registers a ScePower Callback\n\n # Arguments\n\n* `cbid` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn kscePowerRegisterCallback(cbid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to do a cold reset\n\n # Returns\n\nalways 0"]
    pub fn kscePowerRequestColdReset() -> crate::ctypes::c_int;
    #[doc = "Request display off\n\n # Returns\n\nalways 0"]
    pub fn kscePowerRequestDisplayOff() -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to do a soft reset\n\n # Returns\n\nalways 0"]
    pub fn kscePowerRequestSoftReset() -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to go into standby\n\n # Returns\n\nalways 0"]
    pub fn kscePowerRequestStandby() -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to suspend\n\n # Returns\n\nalways 0"]
    pub fn kscePowerRequestSuspend() -> crate::ctypes::c_int;
    #[doc = "Sets CPU clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn kscePowerSetArmClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets BUS clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn kscePowerSetBusClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set the screen brightness.\n [`crate::sceAVConfigSetDisplayBrightness`] for userland counterpart.\n\n # Arguments\n\n* `brightness` - Brightness that the screen will be set to (range 21-65536, 0 turns off the screen).\n\n # Returns\n\n?"]
    pub fn kscePowerSetDisplayBrightness(brightness: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets GPU clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn kscePowerSetGpuClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets GPU crossbar clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn kscePowerSetGpuXbarClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Unregister a callback\n\n # Arguments\n\n* `cbid` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn kscePowerUnregisterCallback(cbid: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "ScePower_stub", kind = "static")]
#[cfg(feature = "ScePower_stub")]
extern "C" {
    #[doc = "Returns CPU clock frequency\n\n # Returns\n\nCPU clock frequency in Mhz"]
    pub fn scePowerGetArmClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns battery cycle count\n\n # Returns\n\nbattery cycle count"]
    pub fn scePowerGetBatteryCycleCount() -> crate::ctypes::c_int;
    #[doc = "Returns battery full capacity\n\n # Returns\n\nbattery full capacity in mAh (milliampere hour)"]
    pub fn scePowerGetBatteryFullCapacity() -> crate::ctypes::c_int;
    #[doc = "Returns battery life percentage\n\n # Returns\n\nBattery life percentage"]
    pub fn scePowerGetBatteryLifePercent() -> crate::ctypes::c_int;
    #[doc = "Returns battery life time\n\n # Returns\n\nBattery life time in minutes"]
    pub fn scePowerGetBatteryLifeTime() -> crate::ctypes::c_int;
    #[doc = "Returns battery remaining capacity\n\n # Returns\n\nbattery remaining capacity in mAh (milliampere hour)"]
    pub fn scePowerGetBatteryRemainCapacity() -> crate::ctypes::c_int;
    #[doc = "Returns battery state of health\n\n # Returns\n\nbattery state of health percent"]
    pub fn scePowerGetBatterySOH() -> crate::ctypes::c_int;
    #[doc = "Returns battery temperature\n\n # Returns\n\ntemperature in degrees celcius * 100"]
    pub fn scePowerGetBatteryTemp() -> crate::ctypes::c_int;
    #[doc = "Returns battery voltage\n\n # Returns\n\nbattery voltage in mV (millivolts)"]
    pub fn scePowerGetBatteryVolt() -> crate::ctypes::c_int;
    #[doc = "Returns BUS clock frequency\n\n # Returns\n\nBUS clock frequency in Mhz"]
    pub fn scePowerGetBusClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns GPU clock frequency\n\n # Returns\n\nGPU clock frequency in Mhz"]
    pub fn scePowerGetGpuClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Returns GPU crossbar clock frequency\n\n # Returns\n\nGPU crossbar clock frequency in Mhz"]
    pub fn scePowerGetGpuXbarClockFrequency() -> crate::ctypes::c_int;
    #[doc = "Gets wireless features usage\n\n # Returns\n\nSCE_TRUE if enabled, SCE_FALSE otherwise"]
    pub fn scePowerGetUsingWireless() -> crate::ctypes::c_int;
    #[doc = "Returns battery charging status\n\n # Returns\n\nSCE_TRUE if under charge, SCE_FALSE otherwise"]
    pub fn scePowerIsBatteryCharging() -> SceBool;
    #[doc = "Returns battery state\n\n # Returns\n\nSCE_TRUE if battery is low, SCE_FALSE otherwise"]
    pub fn scePowerIsLowBattery() -> SceBool;
    #[doc = "Check if AC is plugged in\n\n # Returns\n\nSCE_TRUE if plugged in, SCE_FALSE otherwise"]
    pub fn scePowerIsPowerOnline() -> SceBool;
    #[doc = "Check if a suspend is required\n\n # Returns\n\nSCE_TRUE if suspend is required, SCE_FALSE otherwise"]
    pub fn scePowerIsSuspendRequired() -> SceBool;
    #[doc = "Registers a ScePower Callback\n\n # Arguments\n\n* `cbid` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerRegisterCallback(cbid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to do a cold reset\n\n # Returns\n\nalways 0"]
    pub fn scePowerRequestColdReset() -> crate::ctypes::c_int;
    #[doc = "Request display off\n\n # Returns\n\nalways 0"]
    pub fn scePowerRequestDisplayOff() -> crate::ctypes::c_int;
    #[doc = "Request display on\n\n # Returns\n\nalways 0"]
    pub fn scePowerRequestDisplayOn() -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to go into standby\n\n # Returns\n\nalways 0"]
    pub fn scePowerRequestStandby() -> crate::ctypes::c_int;
    #[doc = "Requests PS Vita to suspend\n\n # Returns\n\nalways 0"]
    pub fn scePowerRequestSuspend() -> crate::ctypes::c_int;
    #[doc = "Sets CPU clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerSetArmClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets BUS clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerSetBusClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set power configuration mode between:\n\n Mode A - This is the normal mode at process start-up. The clock frequency of the GPU core is the \"normal\" clock frequency. The WLAN/COM can be used.\n Mode B - This mode accelerates the GPU clock frequency. The clock frequency of the GPU core is the \"high\" clock frequency. The WLAN/COM cannot be used.\n Mode C - This mode accelerates the GPU clock frequency, and also uses the WLAN/COM. The clock frequency of the GPU core is the \"high\" clock frequency, and use of the WLAN/COM is possible. The screen (touchscreen) brightness, however, is limited. Also, camera cannot be used.\n\n # Arguments\n\n* `conf` - One of ::ScePowerConfigurationMode\n\n # Returns\n\n0 on success"]
    pub fn scePowerSetConfigurationMode(conf: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets GPU clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerSetGpuClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets GPU crossbar clock frequency\n\n # Arguments\n\n* `freq` - - Frequency to set in Mhz\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerSetGpuXbarClockFrequency(freq: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Sets wireless features usage\n\n # Arguments\n\n* `enabled` - - SCE_TRUE to enable, SCE_FALSE to disable\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerSetUsingWireless(enabled: SceBool) -> crate::ctypes::c_int;
    #[doc = "Unregister a callback\n\n # Arguments\n\n* `cbid` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn scePowerUnregisterCallback(cbid: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "SceProcessmgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceProcessmgrForDriver_stub")]
extern "C" {
    pub fn ksceKernelCreateProcessLocalStorage(
        name: *const crate::ctypes::c_char,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetProcessInfo(
        pid: SceUID,
        info: *mut SceKernelProcessInfo,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetProcessLocalStorageAddr(
        key: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_void;
    pub fn ksceKernelGetProcessLocalStorageAddrForPid(
        pid: SceUID,
        key: crate::ctypes::c_int,
        out_addr: *mut *mut crate::ctypes::c_void,
        create_if_doesnt_exist: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the status of a given process.\n # Arguments\n\n* `pid` (direction in) - The process ID to query.\n * `status` (direction out) - The bit field status of the process.\n # Returns\n\nZero on success, < 0 on error."]
    pub fn ksceKernelGetProcessStatus(
        pid: SceUID,
        status: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceProcessmgrForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceProcessmgrForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceProcessmgrForKernel_363_stub",
    feature = "SceProcessmgrForKernel_stub"
))]
extern "C" {
    pub fn ksceKernelGetProcessKernelBuf(pid: SceUID) -> *mut crate::ctypes::c_void;
}
#[link(name = "SceProcessmgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceProcessmgrForKernel_stub")]
extern "C" {
    #[doc = "Create process\n # Arguments\n\n* `titleid` (direction in) - - The TitleId of the app to open.\n * `type` (direction in) - - The process type.\n * `path` (direction in) - - Path of the process image.\n * `opt` (direction in) - - The create process option.\n # Returns\n\nPID of the created process on success, < 0 on error."]
    pub fn ksceKernelCreateProcess(
        titleid: *const crate::ctypes::c_char,
        type_: SceKernelProcessType,
        path: *const crate::ctypes::c_char,
        opt: *mut crate::ctypes::c_void,
    ) -> SceUID;
    #[doc = "Get the main thread for a given process.\n # Arguments\n\n* `pid` (direction in) - The process id to query for.\n # Returns\n\nThe thread UID on success, else < 0 on error."]
    pub fn ksceKernelGetProcessMainThread(pid: SceUID) -> SceUID;
    #[doc = "Get the process module control block.\n\n # Arguments\n\n* `-` (direction in) - The target process id.\n\n # Returns\n\nThe process module cb pointer"]
    pub fn ksceKernelGetProcessModuleInfo(pid: SceUID) -> ScePVoid;
    #[doc = "Get the process self auth info.\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `self_auth_info` (direction out) - - The output buffer pointer of self auth info.\n\n # Returns\n\nZero on success, < 0 on error."]
    pub fn ksceKernelGetProcessSelfAuthInfo(
        pid: SceUID,
        self_auth_info: *mut SceSelfAuthInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Resume a suspended process.\n # Arguments\n\n* `pid` (direction in) - The process to resume.\n # Returns\n\nZero on success, < 0 on error."]
    pub fn ksceKernelResumeProcess(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Suspend a running process.\n # Arguments\n\n* `pid` (direction in) - The process to suspend.\n * `status` (direction in) - The new status for the process.\n # Returns\n\nZero on success, < 0 on error."]
    pub fn ksceKernelSuspendProcess(
        pid: SceUID,
        status: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceProcessmgr_stub", kind = "static")]
#[cfg(feature = "SceProcessmgr_stub")]
extern "C" {
    pub fn sceKernelGetCurrentProcess() -> SceUID;
    pub fn sceKernelGetProcessParam() -> *const crate::ctypes::c_void;
    pub fn sceKernelGetRemoteProcessTime(
        processId: SceUID,
        pClock: *mut SceKernelSysClock,
    ) -> SceInt32;
    pub fn sceKernelGetStderr() -> SceUID;
    pub fn sceKernelGetStdin() -> SceUID;
    pub fn sceKernelGetStdout() -> SceUID;
    pub fn sceKernelLibcClock() -> SceKernelClock;
    pub fn sceKernelLibcGettimeofday(
        tv: *mut SceKernelTimeval,
        tz: *mut SceKernelTimezone,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelLibcTime(tloc: *mut SceKernelTime) -> SceKernelTime;
    #[doc = "Locks certain timers from triggering.\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceKernelPowerTickType\n\n # Returns\n\n0"]
    pub fn sceKernelPowerLock(type_: SceKernelPowerTickType) -> crate::ctypes::c_int;
    #[doc = "Cancel specified idle timers to prevent entering in power save processing.\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceKernelPowerTickType\n\n # Returns\n\n0"]
    pub fn sceKernelPowerTick(type_: SceKernelPowerTickType) -> crate::ctypes::c_int;
    #[doc = "Unlocks certain timers.\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceKernelPowerTickType\n\n # Returns\n\n0"]
    pub fn sceKernelPowerUnlock(type_: SceKernelPowerTickType) -> crate::ctypes::c_int;
}
#[link(name = "SceProcEventForDriver_stub", kind = "static")]
#[cfg(feature = "SceProcEventForDriver_stub")]
extern "C" {
    #[doc = "Invoke process event handler\n\n # Arguments\n\n* `pid` (direction in) - - The ProccessId\n * `event_id` (direction in) - - event_id, [1, 2, 3, 4, 5, 0x10, 0x11]\n * `event_type` (direction in) - - Various event types\n * `param` (direction in) - - The pointer of invoke parameter\n * `a5` (direction in) - - Unknown\n * `a6` (direction in) - - Unknown\n\n # Returns\n\nuid on success, < 0 on error."]
    pub fn ksceKernelInvokeProcEventHandler(
        pid: SceUID,
        event_id: crate::ctypes::c_int,
        event_type: crate::ctypes::c_int,
        param: *mut crate::ctypes::c_void,
        a5: *mut crate::ctypes::c_void,
        a6: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Register process event handler\n\n # Arguments\n\n* `name` (direction in) - - Name of handler\n * `handler` (direction in) - - The pointer of handler\n * `a3` (direction in) - - unknown, set to 0\n\n # Returns\n\nuid on success, < 0 on error."]
    pub fn ksceKernelRegisterProcEventHandler(
        name: *const crate::ctypes::c_char,
        handler: *const SceProcEventHandler,
        a3: crate::ctypes::c_int,
    ) -> SceUID;
    #[doc = "Unregister process event handler\n\n # Arguments\n\n* `uid` (direction in) - - ProcEvent uid\n\n # Returns\n\nuid on success, < 0 on error."]
    pub fn ksceKernelUnregisterProcEventHandler(uid: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "ScePromoterUtil_stub", kind = "static")]
#[cfg(feature = "ScePromoterUtil_stub")]
extern "C" {
    #[doc = "Check if titleid exists\n\n # Arguments\n\n* `*res` (direction out) - - the result, unknown meaning\n\n # Returns\n\n0 if exists, < 0 otherwise."]
    pub fn scePromoterUtilityCheckExist(
        titleid: *const crate::ctypes::c_char,
        res: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Delete a package from the LiveArea.\n\n # Arguments\n\n* `*titleid` (direction in) -\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityDeletePkg(
        titleid: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Deinit the promoter utility.\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityExit() -> crate::ctypes::c_int;
    #[doc = "Returns the result of a finished operation\n\n # Arguments\n\n* `*res` (direction out) - - the result, 0 on success\n\n # Returns\n\n< 0 if failed."]
    pub fn scePromoterUtilityGetResult(res: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Returns the state of an operation.\n\n # Arguments\n\n* `*state` (direction out) - - the current status, 0 when finished\n\n # Returns\n\n< 0 if failed."]
    pub fn scePromoterUtilityGetState(state: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Init the promoter utility.\n > **Note:** Needs to be called before using the other functions.\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityInit() -> crate::ctypes::c_int;
    #[doc = "Install Content Manager import contents and create bubbles without checking license files.\n\n # Arguments\n\n* `*params` (direction in) - - see ::ScePromoterUtilImportParams\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityPromoteImport(
        params: *mut ScePromoterUtilityImportParams,
    ) -> crate::ctypes::c_int;
    #[doc = "Install a package from a directory, and add an icon on the LiveArea.\n\n # Arguments\n\n* `*path` (direction in) - - the path of the directory where the extracted content of the package is\n * `sync` - - pass 0 for asynchronous, 1 for synchronous\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityPromotePkg(
        path: *const crate::ctypes::c_char,
        sync: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Install a package from a directory and generate a rif.\n\n # Arguments\n\n* `*path` (direction in) - - the path of the directory where the extracted content of the package is\n * `sync` - - pass 0 for asynchronous, 1 for synchronous\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityPromotePkgWithRif(
        path: *const crate::ctypes::c_char,
        sync: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Update the LiveArea resources of an app\n\n # Arguments\n\n* `*args` (direction in) - - see ::ScePromoterUtilityLAUpdate\n\n # Returns\n\n0 on success."]
    pub fn scePromoterUtilityUpdateLiveArea(
        args: *mut ScePromoterUtilityLAUpdate,
    ) -> crate::ctypes::c_int;
}
#[link(name = "ScePsmDrmForDriver_stub", kind = "static")]
#[cfg(feature = "ScePsmDrmForDriver_stub")]
extern "C" {}
#[link(name = "ScePspnetAdhoc_stub", kind = "static")]
#[cfg(feature = "ScePspnetAdhoc_stub")]
extern "C" {
    pub fn sceNetAdhocGetPdpStat(
        buflen: *mut crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocGetPtpStat(
        buflen: *mut crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocGetSocketAlert(
        id: crate::ctypes::c_int,
        flag: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocInit() -> crate::ctypes::c_int;
    pub fn sceNetAdhocPdpCreate(
        saddr: *const SceNetEtherAddr,
        sport: SceUShort16,
        bufsize: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPdpDelete(
        id: crate::ctypes::c_int,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPdpRecv(
        id: crate::ctypes::c_int,
        saddr: *mut SceNetEtherAddr,
        sport: *mut SceUShort16,
        buf: *mut crate::ctypes::c_void,
        len: *mut crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPdpSend(
        id: crate::ctypes::c_int,
        daddr: *const SceNetEtherAddr,
        dport: SceUShort16,
        data: *const crate::ctypes::c_void,
        len: crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPollSocket(
        sds: *mut SceNetAdhocPollSd,
        nsds: crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpAccept(
        id: crate::ctypes::c_int,
        addr: *mut SceNetEtherAddr,
        port: *mut SceUShort16,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpClose(
        id: crate::ctypes::c_int,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpConnect(
        id: crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpFlush(
        id: crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpListen(
        saddr: *const SceNetEtherAddr,
        sport: SceUShort16,
        bufsize: crate::ctypes::c_uint,
        rexmt_int: crate::ctypes::c_uint,
        rexmt_cnt: crate::ctypes::c_int,
        backlog: crate::ctypes::c_int,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpOpen(
        saddr: *const SceNetEtherAddr,
        sport: SceUShort16,
        daddr: *const SceNetEtherAddr,
        dport: SceUShort16,
        bufsize: crate::ctypes::c_uint,
        rexmt_int: crate::ctypes::c_uint,
        rexmt_cnt: crate::ctypes::c_int,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpRecv(
        id: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
        len: *mut crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocPtpSend(
        id: crate::ctypes::c_int,
        data: *const crate::ctypes::c_void,
        len: *mut crate::ctypes::c_int,
        timeout: crate::ctypes::c_uint,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocSetSocketAlert(
        id: crate::ctypes::c_int,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocTerm() -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetAddrByName(
        nickname: *const SceNetAdhocctlNickname,
        buflen: *mut crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetAdhocId(adhocId: *mut SceNetAdhocctlAdhocId) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetEtherAddr(addr: *mut SceNetEtherAddr) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetNameByAddr(
        addr: *const SceNetEtherAddr,
        nickname: *mut SceNetAdhocctlNickname,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetParameter(
        parameter: *mut SceNetAdhocctlParameter,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetPeerInfo(
        addr: *const SceNetEtherAddr,
        size: crate::ctypes::c_int,
        peerInfo: *mut SceNetAdhocctlPeerInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlGetPeerList(
        buflen: *mut crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlInit(adhocId: *const SceNetAdhocctlAdhocId) -> crate::ctypes::c_int;
    pub fn sceNetAdhocctlTerm() -> crate::ctypes::c_int;
}
#[link(name = "ScePvf_stub", kind = "static")]
#[cfg(feature = "ScePvf_stub")]
extern "C" {
    pub fn scePvfClose(fontID: ScePvfFontId) -> ScePvfError;
    pub fn scePvfDoneLib(libID: ScePvfLibId) -> ScePvfError;
    pub fn scePvfFindFont(
        libID: ScePvfLibId,
        fontStyleInfo: *mut ScePvfFontStyleInfo,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontIndex;
    pub fn scePvfFindOptimumFont(
        libID: ScePvfLibId,
        fontStyleInfo: *mut ScePvfFontStyleInfo,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontIndex;
    pub fn scePvfFlush(fontID: ScePvfFontId) -> ScePvfError;
    pub fn scePvfGetCharGlyphImage(
        fontID: ScePvfFontId,
        charCode: ScePvfCharCode,
        imageBuffer: *mut ScePvfUserImageBufferRec,
    ) -> ScePvfError;
    pub fn scePvfGetCharGlyphImage_Clip(
        fontID: ScePvfFontId,
        charCode: ScePvfCharCode,
        imageBuffer: *mut ScePvfUserImageBufferRec,
        clipX: ScePvfS32,
        clipY: ScePvfS32,
        clipWidth: ScePvfU32,
        clipHeight: ScePvfU32,
    ) -> ScePvfError;
    pub fn scePvfGetCharImageRect(
        fontID: ScePvfFontId,
        charCode: ScePvfCharCode,
        rect: *mut ScePvfIrect,
    ) -> ScePvfError;
    pub fn scePvfGetCharInfo(
        fontID: ScePvfFontId,
        charCode: ScePvfCharCode,
        charInfo: *mut ScePvfCharInfo,
    ) -> ScePvfError;
    pub fn scePvfGetFontInfo(fontID: ScePvfFontId, fontInfo: *mut ScePvfFontInfo) -> ScePvfError;
    pub fn scePvfGetFontInfoByIndexNumber(
        libID: ScePvfLibId,
        fontStyleInfo: *mut ScePvfFontStyleInfo,
        fontIndex: ScePvfFontIndex,
    ) -> ScePvfError;
    pub fn scePvfGetFontList(
        libID: ScePvfLibId,
        fontStyleInfo: *mut ScePvfFontStyleInfo,
        arraySize: ScePvfInt,
    ) -> ScePvfError;
    pub fn scePvfGetKerningInfo(
        fontID: ScePvfFontId,
        leftCharCode: ScePvfCharCode,
        rightCharCode: ScePvfCharCode,
        pKerningInfo: *mut ScePvfKerningInfo,
    ) -> ScePvfError;
    pub fn scePvfGetNumFontList(libID: ScePvfLibId, errorCode: *mut ScePvfError) -> ScePvfInt;
    pub fn scePvfIsElement(fontID: ScePvfFontId, charCode: ScePvfCharCode) -> ScePvfBool;
    pub fn scePvfNewLib(initParam: *mut ScePvfInitRec, errorCode: *mut ScePvfError) -> ScePvfLibId;
    pub fn scePvfOpen(
        libID: ScePvfLibId,
        fontIndex: ScePvfFontIndex,
        mode: ScePvfU32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfOpenDefaultJapaneseFontOnSharedMemory(
        libID: ScePvfLibId,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfOpenDefaultLatinFontOnSharedMemory(
        libID: ScePvfLibId,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfOpenUserFile(
        libID: ScePvfLibId,
        filename: ScePvfPointer,
        mode: ScePvfU32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfOpenUserFileWithSubfontIndex(
        libID: ScePvfLibId,
        filename: ScePvfPointer,
        mode: ScePvfU32,
        subFontIndex: ScePvfU32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfOpenUserMemory(
        libID: ScePvfLibId,
        addr: ScePvfPointer,
        size: ScePvfU32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfOpenUserMemoryWithSubfontIndex(
        libID: ScePvfLibId,
        addr: ScePvfPointer,
        size: ScePvfU32,
        subFontIndex: ScePvfU32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFontId;
    pub fn scePvfPixelToPointH(
        libID: ScePvfLibId,
        pixel: ScePvfFloat32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFloat32;
    pub fn scePvfPixelToPointV(
        libID: ScePvfLibId,
        pixel: ScePvfFloat32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFloat32;
    pub fn scePvfPointToPixelH(
        libID: ScePvfLibId,
        point: ScePvfFloat32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFloat32;
    pub fn scePvfPointToPixelV(
        libID: ScePvfLibId,
        point: ScePvfFloat32,
        errorCode: *mut ScePvfError,
    ) -> ScePvfFloat32;
    pub fn scePvfSetAltCharacterCode(libID: ScePvfLibId, charCode: ScePvfCharCode) -> ScePvfError;
    pub fn scePvfSetCharSize(
        fontID: ScePvfFontId,
        hSize: ScePvfFloat32,
        vSize: ScePvfFloat32,
    ) -> ScePvfError;
    pub fn scePvfSetEM(libID: ScePvfLibId, emValue: ScePvfFloat32) -> ScePvfError;
    pub fn scePvfSetEmboldenRate(fontID: ScePvfFontId, emboldenRate: ScePvfFloat32) -> ScePvfError;
    pub fn scePvfSetResolution(
        libID: ScePvfLibId,
        hResolution: ScePvfFloat32,
        vResolution: ScePvfFloat32,
    ) -> ScePvfError;
    pub fn scePvfSetSkewValue(
        fontID: ScePvfFontId,
        angleX: ScePvfFloat32,
        angleY: ScePvfFloat32,
    ) -> ScePvfError;
}
#[link(name = "SceQafMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceQafMgrForDriver_stub")]
extern "C" {}
#[link(name = "SceRazorCapture_stub", kind = "static")]
#[cfg(feature = "SceRazorCapture_stub")]
extern "C" {
    #[doc = "Enables collecting of GPU captures when a gpucrash happens\n\n # Arguments\n\n* `filename` (direction in) - - Filename of the file where to save capture results"]
    pub fn sceRazorGpuCaptureEnableSalvage(filename: *const crate::ctypes::c_char);
    #[doc = "Sets a trigger for a gpu capture in next frame from Razor debugger\n\n # Arguments\n\n* `filename` (direction in) - - Filename of the file where to save capture results"]
    pub fn sceRazorGpuCaptureSetTriggerNextFrame(filename: *const crate::ctypes::c_char);
}
#[link(name = "SceRazorHud_stub", kind = "static")]
#[cfg(feature = "SceRazorHud_stub")]
extern "C" {
    #[doc = "Sets the buffer in which to store gpu live debugging results for the current frame\n\n # Arguments\n\n* `buffer` (direction in) - - The buffer to use\n * `buf_size` (direction in) - - The buffer size in bytes\n * `results` (direction out) - - The debugging results of the previous frame\n\n # Returns\n\n0, <0 on error."]
    pub fn sceRazorGpuLiveSetBuffer(
        buffer: *mut crate::ctypes::c_void,
        buf_size: SceSize,
        results: *mut SceRazorGpuLiveResultInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Sets a metrics group to use for gpu live debugging\n\n # Arguments\n\n* `metrics` (direction in) - - The metrics group to use (One of ::SceRazorGpuLiveMetricsGroup)\n\n # Returns\n\n0, <0 on error."]
    pub fn sceRazorGpuLiveSetMetricsGroup(metrics: u32) -> crate::ctypes::c_int;
    #[doc = "Starts gpu live debugging\n\n # Returns\n\n0, <0 on error."]
    pub fn sceRazorGpuLiveStart() -> crate::ctypes::c_int;
    #[doc = "Stops gpu live debugging\n\n # Returns\n\n0, <0 on error."]
    pub fn sceRazorGpuLiveStop() -> crate::ctypes::c_int;
}
#[link(name = "SceRegistryMgr_stub", kind = "static")]
#[cfg(feature = "SceRegistryMgr_stub")]
extern "C" {
    #[doc = "Get all keys' initial information by category (from os0:kd/registry.db0)\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `buf[out]` - - Pointer to a char buffer to hold the values\n * `elements_number` - - The number of elements of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrGetInitVals(
        category: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        elements_number: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrGetKeyBin(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a int buffer to hold the value\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrGetKeyInt(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a char buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrGetKeyStr(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get all keys' information by category\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `buf[out]` - - Pointer to a char buffer to hold the values\n * `elements_number` - - The number of elements of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrGetKeys(
        category: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        elements_number: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the registry version\n\n # Arguments\n\n* `id` - - The id of the key\n * `buf[out]` - - Pointer to a char buffer to hold the value\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrGetRegVersion(
        version: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Set a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrSetKeyBin(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to an int buffer to hold the value\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrSetKeyInt(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a char buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrSetKeyStr(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set all keys' information by category\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `buf[out]` - - Pointer to a char buffer that holds the values\n * `elements_number` - - The number of elements of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrSetKeys(
        category: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        elements_number: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a system param key's information by id\n\n # Arguments\n\n* `id` - - The id of the key\n * `buf[out]` - - Pointer to an int to hold the value\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrSystemParamGetInt(
        id: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a system param key's information by id\n\n # Arguments\n\n* `id` - - The id of the key\n * `buf[out]` - - Pointer to a char buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceRegMgrSystemParamGetStr(
        id: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_char,
        size: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceRegMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceRegMgrForDriver_stub")]
extern "C" {
    #[doc = "Get a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceRegMgrGetKeyBin(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a int buffer to hold the value\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceRegMgrGetKeyInt(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a char buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceRegMgrGetKeyStr(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceRegMgrSetKeyBin(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to an int buffer to hold the value\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceRegMgrSetKeyInt(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set a key's information by category and name\n\n # Arguments\n\n* `category` - - The path to the directory to be opened (e.g. /CONFIG/SYSTEM)\n * `name` - - Name of the key\n * `buf` - - Pointer to a char buffer to hold the value\n * `size` - - The size of the buffer\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceRegMgrSetKeyStr(
        category: *const crate::ctypes::c_char,
        name: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        size: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceRegMgrServiceForDriver_stub", kind = "static")]
#[cfg(feature = "SceRegMgrServiceForDriver_stub")]
extern "C" {}
#[link(name = "SceRtabi_stub", kind = "static")]
#[cfg(feature = "SceRtabi_stub")]
extern "C" {}
#[link(name = "SceRtcForDriver_stub", kind = "static")]
#[cfg(feature = "SceRtcForDriver_stub")]
extern "C" {
    #[doc = "Convert date time to unix time\n\n # Arguments\n\n* `src` (direction in) - - The input SceDateTime struct pointer.\n * `dst` (direction out) - - The output unix time buffer pointer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceRtcConvertDateTimeToUnixTime(
        src: *const SceDateTime,
        dst: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert tick to date time\n\n # Arguments\n\n* `dst` (direction out) - - The output SceDateTime struct pointer.\n * `src` (direction in) - - The input tick pointer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceRtcConvertTickToDateTime(
        dst: *mut SceDateTime,
        src: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    #[doc = "Get current real time clock time.\n\n # Arguments\n\n* `time` (direction out) - - see ::SceDateTime.\n * `time_zone` (direction in) - - The time zone the return value will be.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceRtcGetCurrentClock(
        time: *mut SceDateTime,
        time_zone: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get current real time clock time with system time zone.\n\n # Arguments\n\n* `time` (direction out) - - see ::SceDateTime.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceRtcGetCurrentClockLocalTime(time: *mut SceDateTime) -> crate::ctypes::c_int;
    pub fn ksceRtcGetCurrentDebugNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcGetCurrentNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcGetCurrentSecureTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcGetCurrentTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcSetCurrentDebugNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcSetCurrentNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcSetCurrentSecureTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn ksceRtcSetCurrentTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
}
#[link(name = "SceRtc_stub", kind = "static")]
#[cfg(feature = "SceRtc_stub")]
extern "C" {
    #[doc = "Convert localtime to UTC\n\n # Arguments\n\n* `localtime` (direction in) - - The localtime buffer pointer\n * `utc` (direction out) - - The UTC buffer pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceRtcConvertLocalTimeToUtc(
        localtime: *const SceRtcTick,
        utc: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert UTC to localtime\n\n # Arguments\n\n* `utc` (direction in) - - The UTC buffer pointer\n * `localtime` (direction out) - - The localtime buffer pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceRtcConvertUtcToLocalTime(
        utc: *const SceRtcTick,
        localtime: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert RFC2822 time string from UTC\n\n # Arguments\n\n* `datetime` (direction out) - - The datetime string buffer\n * `utc` (direction in) - - The UTC time tick pointer\n * `offset` (direction in) - - A timezone offset. this value have to minute value\n * `a4` (direction in) - - The Syscall validity buffer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceRtcFormatRFC2822(
        datetime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
        offset: crate::ctypes::c_int,
        a4: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert RFC2822 time string from UTC with localtime\n\n # Arguments\n\n* `datetime` (direction out) - - The datetime string buffer\n * `utc` (direction in) - - The UTC time tick pointer\n * `a3` (direction in) - - The Syscall validity buffer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceRtcFormatRFC2822LocalTime(
        datetime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
        a3: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert RFC3339 time string from UTC\n\n # Arguments\n\n* `datetime` (direction out) - - The datetime string buffer\n * `utc` (direction in) - - The UTC time tick pointer\n * `offset` (direction in) - - A timezone offset. this value have to minute value\n * `a4` (direction in) - - The Syscall validity buffer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceRtcFormatRFC3339(
        datetime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
        offset: crate::ctypes::c_int,
        a4: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Convert RFC3339 time string from UTC with localtime\n\n # Arguments\n\n* `datetime` (direction out) - - The datetime string buffer\n * `utc` (direction in) - - The UTC time tick pointer\n * `a3` (direction in) - - The Syscall validity buffer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _sceRtcFormatRFC3339LocalTime(
        datetime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
        a3: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcCheckValid(time: *const SceDateTime) -> crate::ctypes::c_int;
    pub fn sceRtcCompareTick(
        pTick1: *const SceRtcTick,
        pTick2: *const SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcConvertLocalTimeToUtc(
        local_time: *const SceRtcTick,
        utc: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcConvertUtcToLocalTime(
        utc: *const SceRtcTick,
        local_time: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcFormatRFC2822(
        pszDateTime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
        iTimeZoneMinutes: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcFormatRFC2822LocalTime(
        pszDateTime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcFormatRFC3339(
        pszDateTime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
        iTimeZoneMinutes: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcFormatRFC3339LocalTime(
        pszDateTime: *mut crate::ctypes::c_char,
        utc: *const SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcGetAccumulativeTime() -> SceULong64;
    pub fn sceRtcGetCurrentAdNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    #[doc = "Get current real time clock time.\n\n # Arguments\n\n* `time` (direction out) - - see ::SceDateTime.\n * `time_zone` (direction in) - - The time zone the return value will be.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceRtcGetCurrentClock(
        time: *mut SceDateTime,
        time_zone: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get current real time clock time with system time zone.\n\n # Arguments\n\n* `time` (direction out) - - see ::SceDateTime.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceRtcGetCurrentClockLocalTime(time: *mut SceDateTime) -> crate::ctypes::c_int;
    pub fn sceRtcGetCurrentDebugNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetCurrentGpsTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetCurrentNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetCurrentRetainedNetworkTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetCurrentTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetDayOfWeek(
        year: crate::ctypes::c_int,
        month: crate::ctypes::c_int,
        day: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcGetDaysInMonth(
        year: crate::ctypes::c_int,
        month: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcGetDosTime(
        time: *const SceDateTime,
        puiDosTime: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcGetLastAdjustedTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetLastReincarnatedTick(tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetTick(time: *const SceDateTime, tick: *mut SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcGetTickResolution() -> crate::ctypes::c_uint;
    pub fn sceRtcGetTime64_t(
        time: *const SceDateTime,
        pullTime: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcGetTime_t(time: *const SceDateTime, piTime: *mut time_t) -> crate::ctypes::c_int;
    pub fn sceRtcGetWin32FileTime(
        time: *const SceDateTime,
        ulWin32Time: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcIsLeapYear(year: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceRtcParseDateTime(
        utc: *mut SceRtcTick,
        pszDateTime: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcParseRFC3339(
        utc: *mut SceRtcTick,
        pszDateTime: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcSetDosTime(
        time: *mut SceDateTime,
        uiDosTime: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcSetTick(time: *mut SceDateTime, tick: *const SceRtcTick) -> crate::ctypes::c_int;
    pub fn sceRtcSetTime64_t(time: *mut SceDateTime, ullTime: SceUInt64) -> crate::ctypes::c_int;
    pub fn sceRtcSetTime_t(time: *mut SceDateTime, iTime: time_t) -> crate::ctypes::c_int;
    pub fn sceRtcSetWin32FileTime(
        time: *mut SceDateTime,
        ulWin32Time: SceUInt64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddDays(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddHours(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddMicroseconds(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: SceLong64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddMinutes(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: SceLong64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddMonths(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddSeconds(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: SceLong64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddTicks(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: SceLong64,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddWeeks(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceRtcTickAddYears(
        pTick0: *mut SceRtcTick,
        pTick1: *const SceRtcTick,
        lAdd: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceRudp_stub", kind = "static")]
#[cfg(feature = "SceRudp_stub")]
extern "C" {}
#[link(name = "SceSas_stub", kind = "static")]
#[cfg(feature = "SceSas_stub")]
extern "C" {}
#[link(name = "SceSblACMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceSblACMgrForDriver_stub")]
extern "C" {
    #[doc = "Get media type for input path.\n\n # Arguments\n\n* `path` (direction in) - - The target path\n * `media_type` (direction out) - - The media type output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceSblACMgrGetMediaType(
        path: *const crate::ctypes::c_char,
        media_type: *mut SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Get process authority id\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n * `authid` (direction out) - - The authid output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceSblACMgrGetProcessProgramAuthId(
        pid: SceUID,
        authid: *mut SceUInt64,
    ) -> crate::ctypes::c_int;
    #[doc = "Get development mode state\n\n # Returns\n\nIf development mode, 1. else 0."]
    pub fn ksceSblACMgrIsDevelopmentMode() -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf fake self process, 1. else 0."]
    pub fn ksceSblACMgrIsFself(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf game mode process, 1. else 0."]
    pub fn ksceSblACMgrIsGameProgram(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf non game mode process, 1. else 0."]
    pub fn ksceSblACMgrIsNonGameProgram(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf pspemu process, 1. else 0."]
    pub fn ksceSblACMgrIsPspEmu(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf root mode process, 1. else 0."]
    pub fn ksceSblACMgrIsRootProgram(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf SceShell process(authid:0x2800000000000001), 1. else 0."]
    pub fn ksceSblACMgrIsSceShell(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get process type state\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n\n # Returns\n\nIf system mode process, 1. else 0."]
    pub fn ksceSblACMgrIsSystemProgram(pid: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "SceSblACMgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceSblACMgrForKernel_stub")]
extern "C" {}
#[link(name = "SceSblACMgr_stub", kind = "static")]
#[cfg(feature = "SceSblACMgr_stub")]
extern "C" {}
#[link(name = "SceSblAIMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceSblAIMgrForDriver_stub")]
extern "C" {
    #[doc = "Get product code.\n\n # Returns\n\nsee:SceProductCode."]
    pub fn ksceSblAimgrGetProductCode() -> crate::ctypes::c_int;
    #[doc = "Get product sub code.\n\n # Returns\n\nproduct sub code value."]
    pub fn ksceSblAimgrGetProductSubCode() -> crate::ctypes::c_int;
    #[doc = "Get service/manufacturing information (factory/minimum firmware).\n\n # Arguments\n\n* `info` (direction out) - - The info output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceSblAimgrGetSMI(info: *mut SceUInt32) -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf product code is CEX, 1. else 0."]
    pub fn ksceSblAimgrIsCEX() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf product code is DEX, 1. else 0."]
    pub fn ksceSblAimgrIsDEX() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf device is dolce, or PSTV emu enabled, 1. else 0."]
    pub fn ksceSblAimgrIsDolce() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf device is dolce, 1. else 0."]
    pub fn ksceSblAimgrIsGenuineDolce() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf device is vita, 1. else 0."]
    pub fn ksceSblAimgrIsGenuineVITA() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf product code is TEST, 1. else 0."]
    pub fn ksceSblAimgrIsTest() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf product code is TOOL, 1. else 0."]
    pub fn ksceSblAimgrIsTool() -> crate::ctypes::c_int;
    #[doc = "Get system type state.\n\n # Returns\n\nIf device is vita, 1. else 0."]
    pub fn ksceSblAimgrIsVITA() -> crate::ctypes::c_int;
}
#[link(name = "SceSblAuthMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceSblAuthMgrForDriver_stub")]
extern "C" {}
#[link(name = "SceSblAuthMgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceSblAuthMgrForKernel_stub")]
extern "C" {
    pub fn ksceSblAuthMgrClearDmac5Key(
        slot_id: crate::ctypes::c_int,
        val: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblAuthMgrSetDmac5Key(
        key: *const crate::ctypes::c_void,
        keylen: SceSize,
        slot_id: crate::ctypes::c_int,
        key_id: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSblFwLoaderForDriver_stub", kind = "static")]
#[cfg(feature = "SceSblFwLoaderForDriver_stub")]
extern "C" {}
#[link(name = "SceSblGcAuthMgr_stub", kind = "static")]
#[cfg(feature = "SceSblGcAuthMgr_stub")]
extern "C" {}
#[link(name = "SceSblPostSsMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceSblPostSsMgrForDriver_stub")]
extern "C" {
    #[doc = "Create the new RSA signature\n\n # Arguments\n\n* `rsa_signature` (direction in, out) - - The RSA signature result\n * `hash` (direction in) - - The RSA signature hash\n * `private_key` (direction in) - - The RSA private key\n * `type` (direction in) - - The RSA signature type. [2, 4, 5, 0xB, 0xC, 0xD, 0xE]\n\n # Returns\n\nSCE_OK on success, < 0 on error"]
    pub fn ksceSblRSA2048CreateSignature(
        rsa_signature: *mut SceSblRsaDataParam,
        hash: *mut SceSblRsaDataParam,
        private_key: *mut SceSblRsaPrivateKeyParam,
        type_: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Verufy the new RSA signature\n\n # Arguments\n\n* `rsa_signature` (direction in) - - The RSA signature input\n * `hash` (direction in) - - The RSA signature hash\n * `public_key` (direction in) - - The RSA public key\n * `type` (direction in) - - The RSA signature type. [2, 4, 5, 0xB, 0xC, 0xD, 0xE]\n\n # Returns\n\nSCE_OK on success, < 0 on error"]
    pub fn ksceSblRSA2048VerifySignature(
        rsa_signature: *mut SceSblRsaDataParam,
        hash: *mut SceSblRsaDataParam,
        public_key: *mut SceSblRsaPublicKeyParam,
        type_: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSblPostSsMgr_stub", kind = "static")]
#[cfg(feature = "SceSblPostSsMgr_stub")]
extern "C" {}
#[link(name = "SceSblSmCommForKernel_stub", kind = "static")]
#[cfg(feature = "SceSblSmCommForKernel_stub")]
extern "C" {
    pub fn ksceSblSmCommCallFunc(
        id: SceSblSmCommId,
        service_id: SceUInt32,
        service_result: *mut SceUInt32,
        data: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblSmCommStartSmFromFile(
        priority: SceUInt32,
        sm_path: *const crate::ctypes::c_char,
        cmd_id: SceUInt32,
        auth_info: *mut SceAuthInfo,
        id: *mut SceSblSmCommId,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblSmCommStopSm(
        id: SceSblSmCommId,
        result: *mut SceSblSmCommPair,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSblSmSchedProxyForKernel_stub", kind = "static")]
#[cfg(feature = "SceSblSmSchedProxyForKernel_stub")]
extern "C" {}
#[link(name = "SceSblSsMgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceSblSsMgrForDriver_stub")]
extern "C" {
    pub fn ksceSblAimgrGetConsoleId(cid: *mut SceConsoleId) -> crate::ctypes::c_int;
    pub fn ksceSblAimgrGetOpenPsId(open_psid: *mut SceOpenPsId) -> crate::ctypes::c_int;
    pub fn ksceSblAimgrGetPscode(pscode: *mut ScePsCode) -> crate::ctypes::c_int;
    pub fn ksceSblDmac5AesCbcDec(
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_int,
        key: *const crate::ctypes::c_void,
        key_size: crate::ctypes::c_int,
        iv: *mut crate::ctypes::c_void,
        mask_enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblDmac5AesCbcEnc(
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_int,
        key: *const crate::ctypes::c_void,
        key_size: crate::ctypes::c_int,
        iv: *mut crate::ctypes::c_void,
        mask_enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblDmac5AesCtrDec(
        src: *const crate::ctypes::c_void,
        dst: *mut crate::ctypes::c_void,
        size: crate::ctypes::c_int,
        key: *const crate::ctypes::c_void,
        key_size: crate::ctypes::c_int,
        iv: *mut crate::ctypes::c_void,
        mask_enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblRngPseudoRandomNumber(
        result: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSblSsDecryptWithPortability(
        key_type: SceUInt32,
        iv: *mut crate::ctypes::c_void,
        src: *mut ScePortabilityData,
        dst: *mut ScePortabilityData,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSblSsMgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceSblSsMgrForKernel_stub")]
extern "C" {}
#[link(name = "SceSblSsMgr_stub", kind = "static")]
#[cfg(feature = "SceSblSsMgr_stub")]
extern "C" {
    #[doc = "Execute DMAC5 encdec command\n\n # Arguments\n\n* `param` (direction in, out) - - The encdec param.\n * `command` (direction in) - - The DMAC5 encdec command.\n\n # Returns\n\n0 on success, else < 0."]
    pub fn sceSblDmac5EncDec(
        param: *mut SceSblDmac5EncDecParam,
        command: SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Execute DMAC5 hash transform command\n\n # Arguments\n\n* `param` (direction in, out) - - The encdec param.\n * `command` (direction in) - - The DMAC5 hash base command.\n * `extra` (direction in) - - The DMAC5 extra command.\n\n # Returns\n\n0 on success, else < 0."]
    pub fn sceSblDmac5HashTransform(
        param: *mut SceSblDmac5HashTransformParam,
        command: SceUInt32,
        extra: SceUInt32,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSblUpdateMgr_stub", kind = "static")]
#[cfg(feature = "SceSblUpdateMgr_stub")]
extern "C" {
    #[doc = "Getting system update mode on boot\n\n # Arguments\n\n* `mode` (direction out) - - The pointer of SceUpdateMode variable\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceSblUsGetUpdateMode(mode: *mut SceUpdateMode) -> crate::ctypes::c_int;
    #[doc = "Setting system update mode on boot\n\n # Arguments\n\n* `mode` (direction in) - - The update mode\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceSblUsSetUpdateMode(mode: SceUpdateMode) -> crate::ctypes::c_int;
    #[doc = "Verify PUP\n\n # Arguments\n\n* `path` (direction in) - - The PUP path\n\n # Returns\n\n0 on success, < 0 on error.\n\n note - If verify CEX PUP on Devkit system, got error."]
    pub fn sceSblUsVerifyPup(path: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
#[link(name = "SceScreenShot_stub", kind = "static")]
#[cfg(feature = "SceScreenShot_stub")]
extern "C" {
    #[doc = "Disable screenshot"]
    pub fn sceScreenShotDisable() -> crate::ctypes::c_int;
    #[doc = "Enable screenshot"]
    pub fn sceScreenShotEnable() -> crate::ctypes::c_int;
    #[doc = "Set overlay image"]
    pub fn sceScreenShotSetOverlayImage(
        filepath: *const crate::ctypes::c_char,
        offsetX: crate::ctypes::c_int,
        offsetY: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set screenshot params"]
    pub fn sceScreenShotSetParam(param: *const SceScreenShotParam) -> crate::ctypes::c_int;
}
#[link(name = "SceSdifForDriver_stub", kind = "static")]
#[cfg(feature = "SceSdifForDriver_stub")]
extern "C" {}
#[link(name = "SceShaccCg_stub", kind = "static")]
#[cfg(feature = "SceShaccCg_stub")]
extern "C" {
    pub fn sceShaccCgCompileProgram(
        options: *const SceShaccCgCompileOptions,
        callbacks: *const SceShaccCgCallbackList,
        unk: crate::ctypes::c_int,
    ) -> *const SceShaccCgCompileOutput;
    pub fn sceShaccCgDestroyCompileOutput(output: *const SceShaccCgCompileOutput);
    pub fn sceShaccCgGetVersionString() -> *const crate::ctypes::c_char;
    pub fn sceShaccCgInitializeCallbackList(
        callbacks: *mut SceShaccCgCallbackList,
        defaults: SceShaccCgCallbackDefaults,
    );
    pub fn sceShaccCgInitializeCompileOptions(
        options: *mut SceShaccCgCompileOptions,
    ) -> crate::ctypes::c_int;
    pub fn sceShaccCgReleaseCompiler();
    pub fn sceShaccCgSetDefaultAllocator(
        malloc_cb: ::core::option::Option<
            unsafe extern "C" fn(arg1: crate::ctypes::c_uint) -> *mut crate::ctypes::c_void,
        >,
        free_cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void)>,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceShellSvc_stub", kind = "static")]
#[cfg(feature = "SceShellSvc_stub")]
extern "C" {
    #[doc = "Init events\n\n # Arguments\n\n* `unk` (direction in) - - Unknown, use 0\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceShellUtilInitEvents(unk: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn sceShellUtilLaunchAppRequestLaunchApp(
        param: *mut SceShellUtilLaunchAppParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock event\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceShellUtilLockType\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceShellUtilLock(type_: SceShellUtilLockType) -> crate::ctypes::c_int;
    #[doc = "Register event handler\n\n # Arguments\n\n* `handler` (direction in) - - Event handler\n\n * `userData` (direction in) - - The user data passed to the handler\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceShellUtilRegisterEventHandler(
        handler: SceShellUtilEventHandler,
        userData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceShellUtilRequestLaunchApp(
        param: *mut SceShellUtilLaunchAppParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Unlock event\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceShellUtilLockType\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceShellUtilUnlock(type_: SceShellUtilLockType) -> crate::ctypes::c_int;
}
#[link(name = "SceShutterSound_stub", kind = "static")]
#[cfg(feature = "SceShutterSound_stub")]
extern "C" {
    #[doc = "Plays a shutter sound\n\n # Arguments\n\n* `type` (direction in) - - The sound type to play (One of ::SceShutterSoundType)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceShutterSoundPlay(type_: u32) -> crate::ctypes::c_int;
}
#[link(name = "SceSmart_stub", kind = "static")]
#[cfg(feature = "SceSmart_stub")]
extern "C" {}
#[link(name = "SceSqlite_stub", kind = "static")]
#[cfg(feature = "SceSqlite_stub")]
extern "C" {
    #[doc = "Wrapper for sqlite3_config(SQLITE_CONFIG_MALLOC)\n\n # Arguments\n\n* `methods` (direction in) - - A proper set of memory allocation methods\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceSqliteConfigMallocMethods(
        methods: *mut SceSqliteMallocMethods,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSsl_stub", kind = "static")]
#[cfg(feature = "SceSsl_stub")]
extern "C" {
    pub fn sceSslFreeSslCertName(certName: *mut SceSslCertName) -> crate::ctypes::c_int;
    pub fn sceSslGetIssuerName(sslCert: *mut SceSslCert) -> *mut SceSslCertName;
    pub fn sceSslGetMemoryPoolStats(
        currentStat: *mut SceSslMemoryPoolStats,
    ) -> crate::ctypes::c_int;
    pub fn sceSslGetNameEntryCount(certName: *mut SceSslCertName) -> crate::ctypes::c_int;
    pub fn sceSslGetNameEntryInfo(
        certName: *mut SceSslCertName,
        entryNum: crate::ctypes::c_int,
        oidname: *mut crate::ctypes::c_char,
        maxOidnameLen: crate::ctypes::c_uint,
        value: *mut crate::ctypes::c_char,
        maxValueLen: crate::ctypes::c_uint,
        valueLen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceSslGetNotAfter(
        sslCert: *mut SceSslCert,
        limit: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceSslGetNotBefore(
        sslCert: *mut SceSslCert,
        begin: *mut SceRtcTick,
    ) -> crate::ctypes::c_int;
    pub fn sceSslGetSerialNumber(
        sslCert: *mut SceSslCert,
        sboData: *mut *const crate::ctypes::c_char,
        sboLen: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    pub fn sceSslGetSubjectName(sslCert: *mut SceSslCert) -> *mut SceSslCertName;
    pub fn sceSslInit(poolSize: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    pub fn sceSslTerm() -> crate::ctypes::c_int;
}
#[link(name = "SceStdio_0931_stub", kind = "static")]
#[cfg(feature = "SceStdio_0931_stub")]
extern "C" {}
#[link(name = "SceSulpha_stub", kind = "static")]
#[cfg(feature = "SceSulpha_stub")]
extern "C" {}
#[link(name = "SceSysclibForDriver_stub", kind = "static")]
#[cfg(feature = "SceSysclibForDriver_stub")]
extern "C" {
    pub fn __memcpy_chk(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        dst_len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    pub fn __memmove_chk(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        dst_len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    pub fn __memset_chk(
        dst: *mut crate::ctypes::c_void,
        ch: crate::ctypes::c_int,
        len: crate::ctypes::c_uint,
        dst_len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Internal functions used for snprintf, vsnprintf, kscDebugPrintf\n\n # Arguments\n\n* `callback` (direction in) - - The callback to receive ch output by this function\n * `argp` (direction in) - - The passed to callback\n * `fmt` (direction in) - - The base format. example: \"%-18s\"\n * `list` (direction in) - - The variable argument list\n\n # Returns\n\nnone"]
    pub fn __prnt(
        callback: SceSysclibPrntCallback,
        argp: *mut crate::ctypes::c_void,
        fmt: *const crate::ctypes::c_char,
        list: va_list,
    );
    pub fn __strncpy_chk(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        n: crate::ctypes::c_uint,
        dst_len: crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_char;
    pub fn look_ctype_table(ch: crate::ctypes::c_char) -> crate::ctypes::c_char;
    #[doc = "Get string length with length limit\n\n # Arguments\n\n* `s` (direction in) - - The string pointer\n * `n` (direction in) - - The max length\n\n # Returns\n\nString length."]
    pub fn strnlen(
        s: *const crate::ctypes::c_char,
        n: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_uint;
    pub fn timingsafe_memcmp(
        s1: *const crate::ctypes::c_void,
        s2: *const crate::ctypes::c_void,
        n: usize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSysconForDriver_stub", kind = "static")]
#[cfg(feature = "SceSysconForDriver_stub")]
extern "C" {
    pub fn ksceSysconBeginConfigstorageTransaction() -> crate::ctypes::c_int;
    pub fn ksceSysconClearTemperatureLog(arg1: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Execute synchronously a syscon packet.\n\n # Arguments\n\n* `packet` - The packet to execute. Its tx member needs to be initialized.\n * `flags` - The packet flags. Check SceSysconPacketFlags.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconCmdExec(
        packet: *mut SceSysconPacket,
        flags: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Execute asynchronously a syscon packet.\n\n # Arguments\n\n* `packet` - The packet to execute. Its tx member needs to be initialized.\n * `flags` - The packet flags. Check SceSysconPacketFlags.\n * `callback` - The packet callback. Check the callback member of SceSysconPacket.\n * `argp` - The second argument that will be passed to the callback when executed.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconCmdExecAsync(
        packet: *mut SceSysconPacket,
        flags: crate::ctypes::c_uint,
        cb: SceSysconCmdExecAsyncCallback,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for the currently queued syscon packets to be executed, or check if any are in the queue.\n\n # Arguments\n\n* `packet` - The packet you want to check or wait for, or NULL if you want to check or wait for all the currently running packets.\n * `noWait` - Set to 1 if you just want to check the packet status, or 0 if you want the function to return only when the packet queue is empty.\n\n # Returns\n\n1 if packets are still running (and noWait was set to 1), 0 on success, < 0 otherwise."]
    pub fn ksceSysconCmdSync(
        packet: *mut SceSysconPacket,
        noWait: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconCommitConfigstorageTransaction() -> crate::ctypes::c_int;
    #[doc = "Set the ADV7533 HDMI CEC power.\n\n # Arguments\n\n* `power` - The new power value.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconCtrlHdmiCecPower(power: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Turn a LED on or off.\n\n # Arguments\n\n* `led` - The LED id.\n * `enable` - Set this value to 1 if you want the LED to turn on, or 0 if you want it to turn off.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconCtrlLED(
        led: crate::ctypes::c_int,
        enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconCtrlManualChargeMode(arg1: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set the memory stick power.\n\n # Arguments\n\n* `power` - The new power value.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconCtrlRMRPower(power: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set the SD power.\n\n # Arguments\n\n* `power` - The new power value.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconCtrlSdPower(power: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceSysconEnableHibernateIO(arg1: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceSysconEndConfigstorageTransaction() -> crate::ctypes::c_int;
    #[doc = "Get the baryon timestamp.\n\n # Returns\n\nThe baryon timestamp."]
    pub fn ksceSysconGetBaryonTimestamp() -> crate::ctypes::c_ulonglong;
    #[doc = "Get the baryon version.\n\n # Returns\n\nThe baryon version."]
    pub fn ksceSysconGetBaryonVersion() -> crate::ctypes::c_int;
    pub fn ksceSysconGetBatteryCalibData(
        arg1: *mut crate::ctypes::c_int,
        arg2: *mut crate::ctypes::c_int,
        arg3: *mut crate::ctypes::c_int,
        arg4: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get physics button control info\n\n # Arguments\n\n* `ctrl` (direction out) - - The pointer of physics button control info output\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconGetControlsInfo(ctrl: *mut SceUInt32) -> crate::ctypes::c_int;
    pub fn ksceSysconGetHardwareInfo() -> crate::ctypes::c_int;
    pub fn ksceSysconGetHardwareInfo2(
        arg1: *mut crate::ctypes::c_int,
        arg2: *mut crate::ctypes::c_int,
        arg3: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconGetLogInfo(arg1: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceSysconGetManualChargeMode(arg1: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceSysconGetManufacturesStatus(arg1: *mut crate::ctypes::c_int)
        -> crate::ctypes::c_int;
    pub fn ksceSysconGetTemperatureLog(arg1: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceSysconGetUsbDetStatus(arg1: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceSysconIduModeClear() -> crate::ctypes::c_int;
    pub fn ksceSysconIduModeSet() -> crate::ctypes::c_int;
    pub fn ksceSysconIsDownLoaderMode() -> crate::ctypes::c_int;
    pub fn ksceSysconLoadConfigstorageScript(
        arg1: crate::ctypes::c_ushort,
        buff: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconLogReadData(
        arg1: crate::ctypes::c_ushort,
        buff: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconLogStart() -> crate::ctypes::c_int;
    pub fn ksceSysconLogStartWaiting() -> crate::ctypes::c_int;
    pub fn ksceSysconReadCommand(
        cmd: crate::ctypes::c_ushort,
        buffer: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconSendCommand(
        cmd: crate::ctypes::c_ushort,
        buffer: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the alarm callback, that will be ran when the alarm timer is passed.\n\n # Arguments\n\n* `callback` - The callback function.\n * `argp` - The second argument that will be passed to the callback.\n\n # Returns\n\n0."]
    pub fn ksceSysconSetAlarmCallback(
        callback: SceSysconCallback,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the debug handlers.\n\n # Returns\n\n0."]
    pub fn ksceSysconSetDebugHandlers(
        handlers: *const SceSysconDebugHandlers,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the low battery callback, that will be ran when the battery is low.\n\n # Arguments\n\n* `callback` - The callback function.\n * `argp` - The second argument that will be passed to the callback.\n\n # Returns\n\n0."]
    pub fn ksceSysconSetLowBatteryCallback(
        callback: SceSysconCallback,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Reset the device.\n\n # Arguments\n\n* `type` - The reset type value, one of SceSysconResetType.\n * `mode` - The resetting mode (?).\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconSetPowerMode(
        type_: crate::ctypes::c_int,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the thermal alert callback, that will be ran when the temperature reaches a critical point.\n\n # Arguments\n\n* `callback` - The callback function.\n * `argp` - The second argument that will be passed to the callback.\n\n # Returns\n\n0."]
    pub fn ksceSysconSetThermalAlertCallback(
        callback: SceSysconCallback,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceSysconShowModeClear() -> crate::ctypes::c_int;
    pub fn ksceSysconShowModeSet() -> crate::ctypes::c_int;
    pub fn ksceSysconVerifyConfigstorageScript(
        arg1: crate::ctypes::c_ushort,
        buff: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Waits until the syscon is initialized.\n\n # Returns\n\n0 on success."]
    pub fn ksceSysconWaitInitialized() -> crate::ctypes::c_int;
}
#[link(name = "SceSysmemForDriver_0990_stub", kind = "static")]
#[cfg(feature = "SceSysmemForDriver_0990_stub")]
extern "C" {}
#[link(name = "SceSysmemForDriver_stub", kind = "static")]
#[cfg(feature = "SceSysmemForDriver_stub")]
extern "C" {
    pub fn ksceGUIDClose(guid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Gets an object from a UID.\n\n This increases the internal reference count.\n\n # Arguments\n\n* `guid` (direction in) - - The target global uid.\n * `object` (direction out) - - The object pointer output pointer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceGUIDReferObject(
        guid: SceUID,
        object: *mut *mut SceObjectBase,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets an object from a UID with class.\n\n This retains the object refer count internally! You must call `ksceKernelUidRelease`\n after you are done using it.\n\n # Arguments\n\n* `guid` (direction in) - - The target global uid.\n * `sce_class` (direction in) - - The guid parent class.\n * `object` (direction out) - - The object pointer output pointer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceGUIDReferObjectWithClass(
        guid: SceUID,
        sce_class: *mut SceClass,
        object: *mut *mut SceObjectBase,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets an object from a UID with class and level.\n\n This retains the object refer count internally! You must call `ksceKernelUidRelease`\n after you are done using it.\n\n # Arguments\n\n* `guid` (direction in) - - The target global uid.\n * `sce_class` (direction in) - - The guid parent class.\n * `level` (direction in) - - The openable level (count/number).\n The max passable number is 7.\n If the internal object retention count is (level + 1) or higher, get an error.\n * `object` (direction out) - - The object pointer output pointer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceGUIDReferObjectWithClassLevel(
        guid: SceUID,
        pClass: *mut SceClass,
        level: SceUInt32,
        entry: *mut *mut SceObjectBase,
    ) -> crate::ctypes::c_int;
    #[doc = "Releases an object referenced by the UID.\n\n This decreases the internal reference count.\n\n # Arguments\n\n* `guid` (direction in) - - The target global uid.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceGUIDReleaseObject(guid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Allocation the specified length of memory from heap\n\n # Arguments\n\n* `uid` (direction in) - - The heapid\n * `size` (direction in) - - The alloc size\n\n # Returns\n\nThe pointer of allocated memory on success, NULL on error."]
    pub fn ksceKernelAllocHeapMemory(uid: SceUID, size: SceSize) -> *mut crate::ctypes::c_void;
    #[doc = "Allocation the specified length of memory from heap with option\n\n # Arguments\n\n* `uid` (direction in) - - The heapid\n * `size` (direction in) - - The alloc size\n * `opt` (direction in) - - The pointer of option\n\n # Returns\n\nThe pointer of allocated memory on success, NULL on error."]
    pub fn ksceKernelAllocHeapMemoryWithOption(
        heapid: SceUID,
        len: SceSize,
        opt: *mut SceAllocOpt,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Allocates a new memory block\n\n # Arguments\n\n* `name` (direction in) - - Name for the memory block\n * `type` (direction in) - - Type of the memory to allocate. Use `SCE_KERNEL_MEMBLOCK_TYPE_USER_*` or `SCE_KERNEL_MEMBLOCK_TYPE_KERNEL_*`.\n * `size` (direction in) - - Size of the memory to allocate\n * `opt` (direction in) - - Memory block options?\n\n # Returns\n\nSceUID of the memory block on success, < 0 on error."]
    pub fn ksceKernelAllocMemBlock(
        name: *const crate::ctypes::c_char,
        type_: SceKernelMemBlockType,
        size: SceSize,
        opt: *mut SceKernelAllocMemBlockKernelOpt,
    ) -> SceUID;
    pub fn ksceKernelCreateClass(
        cls: *mut SceClass,
        name: *const crate::ctypes::c_char,
        uidclass: *mut crate::ctypes::c_void,
        itemsize: SceSize,
        create: SceClassCallback,
        destroy: SceClassCallback,
    ) -> crate::ctypes::c_int;
    #[doc = "Create heap area\n\n # Arguments\n\n* `name` (direction in) - - The heap name\n * `size` (direction in) - - The heap size\n * `opt` (direction in) - - The pointer of SceKernelHeapCreateOpt option data\n\n # Returns\n\nheapid on success, < 0 on error."]
    pub fn ksceKernelCreateHeap(
        name: *const crate::ctypes::c_char,
        size: SceSize,
        opt: *mut SceKernelHeapCreateOpt,
    ) -> SceUID;
    #[doc = "Delete heap area\n\n # Arguments\n\n* `uid` (direction in) - - The heapid\n\n # Returns\n\nalways 0.\n\n note - Trigger an infinite loop if something fails internally.\n For example, passing an invalid heapid."]
    pub fn ksceKernelDeleteHeap(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Find the SceUID of a memory block\n\n # Arguments\n\n* `addr` (direction in) - - Base address of the memory block\n * `size` (direction in) - - Size to search for (usally set to 0)\n\n # Returns\n\nSceUID of the memory block on success, < 0 on error."]
    pub fn ksceKernelFindMemBlockByAddr(
        addr: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> SceUID;
    #[doc = "Find the SceUID of a memory block for a PID\n\n # Arguments\n\n* `pid` (direction in) - - PID of the process\n * `addr` (direction in) - - Base address of the memory block\n * `size` (direction in) - - Size to search for (usally set to 0)\n\n # Returns\n\nSceUID of the memory block on success, < 0 on error."]
    pub fn ksceKernelFindMemBlockByAddrForPid(
        pid: SceUID,
        addr: *const crate::ctypes::c_void,
        size: SceSize,
    ) -> SceUID;
    #[doc = "Free allocated memory\n\n # Arguments\n\n* `uid` (direction in) - - The heapid\n * `ptr` (direction in) - - The pointer of allocated memory\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelFreeHeapMemory(
        uid: SceUID,
        ptr: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Frees new memory block\n\n # Arguments\n\n* `uid` (direction in) - - SceUID of the memory block to free\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelFreeMemBlock(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get the AllocMapSize of a MemBlock\n\n # Arguments\n\n* `memid` (direction in) - - The target uid of the memblock\n * `alloc_map_size` (direction out) - - The output for AllocMapSize\n\n # Returns\n\nSCE_OK on success, < 0 on error."]
    pub fn ksceKernelGetMemBlockAllocMapSize(
        memid: SceUID,
        alloc_map_size: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets the base address of a memory block\n\n # Arguments\n\n* `uid` (direction in) - - SceUID of the memory block\n * `base` (direction out) - - Base address of the memory block identified by uid\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetMemBlockBase(
        uid: SceUID,
        base: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetPidContext(
        pid: SceUID,
        ctx: *mut *mut SceKernelProcessContext,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetUidClass() -> *mut SceClass;
    pub fn ksceKernelMapBlockUserVisible(uid: SceUID) -> crate::ctypes::c_int;
    pub fn ksceKernelMapUserBlock(
        name: *const crate::ctypes::c_char,
        permission: crate::ctypes::c_int,
        type_: crate::ctypes::c_int,
        user_buf: *const crate::ctypes::c_void,
        size: SceSize,
        kernel_page: *mut *mut crate::ctypes::c_void,
        kernel_size: *mut SceSize,
        kernel_offset: *mut crate::ctypes::c_uint,
    ) -> SceUID;
    #[doc = "Releases a memblock referenced by the UID.\n\n This decreases the internal reference count.\n\n # Arguments\n\n* `uid` (direction in) - The uid of the memblock\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemBlockRelease(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Releases a memory range\n\n This decreases the internal reference count of the memblocks belonging to the range.\n\n Note: It uses ::SCE_KERNEL_MEMORY_REF_PERM_ANY as the reference permission.\n\n # Arguments\n\n* `addr` (direction in) - The start address\n * `size` (direction in) - The memory range size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemRangeRelease(
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Releases a memory range for a process (pid)\n\n This decreases the internal reference count of the memblocks belonging to the range.\n\n Note: It uses ::SCE_KERNEL_MEMORY_REF_PERM_ANY as the reference permission.\n\n # Arguments\n\n* `pid` (direction in) - The pid of the process\n * `addr` (direction in) - The start address\n * `size` (direction in) - The memory range size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemRangeReleaseForPid(
        pid: SceUID,
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Releases a memory range checking for a given permission\n\n This decreases the internal reference count of the memblocks belonging to the range.\n If the memory blocks belonging to the range don't have the required memory access permission,\n it returns an error.\n\n # Arguments\n\n* `perm` (direction in) - The required permission of the memory blocks belonging to the range\n * `addr` (direction in) - The start address\n * `size` (direction in) - The memory range size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemRangeReleaseWithPerm(
        perm: SceKernelMemoryRefPerm,
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Retains a memory range\n\n This increases the internal reference count of the memblocks belonging to the range.\n\n Note: It uses ::SCE_KERNEL_MEMORY_REF_PERM_ANY as the reference permission.\n\n # Arguments\n\n* `addr` (direction in) - The start address\n * `size` (direction in) - The memory range size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemRangeRetain(
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Retains a memory range for a process (pid)\n\n This increases the internal reference count of the memblocks belonging to the range.\n\n Note: It uses ::SCE_KERNEL_MEMORY_REF_PERM_ANY as the reference permission.\n\n # Arguments\n\n* `pid` (direction in) - The pid of the process\n * `addr` (direction in) - The start address\n * `size` (direction in) - The memory range size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemRangeRetainForPid(
        pid: SceUID,
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Retains a memory range checking for a given permission\n\n This increases the internal reference count of the memblocks belonging to the range.\n If the memory blocks belonging to the range don't have the required memory access permission,\n it returns an error.\n\n # Arguments\n\n* `perm` (direction in) - The required permission of the memory blocks belonging to the range\n * `addr` (direction in) - The start address\n * `size` (direction in) - The memory range size\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelMemRangeRetainWithPerm(
        perm: SceKernelMemoryRefPerm,
        addr: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Memcpy from user memory\n\n # Arguments\n\n* `dst` (direction in) - - The userland or kernel memory pointer.\n * `src` (direction in) - - The userland memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcMemcpyFromUser.\n DACR - 0x55555555\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelMemcpyFromUser(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Memcpy to user memory\n\n # Arguments\n\n* `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcMemcpyToUser.\n DACR - 0x55555555\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelMemcpyToUser(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Memcpy from user memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `dst` (direction in) - - The userland or kernel memory pointer.\n * `src` (direction in) - - The userland memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelMemcpyFromUser with disable interrupts.\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcMemcpyFromUser(
        pid: SceUID,
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Memcpy from user memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelMemcpyToUser with disable interrupts.\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcMemcpyToUser(
        pid: SceUID,
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Strncpy from user memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `dst` (direction in) - - The userland or kernel memory pointer.\n * `src` (direction in) - - The userland memory pointer.\n * `len` (direction in) - - The copy length.\n\n # Returns\n\nThe copied length on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelStrncpyFromUserInternal with disable interrupts.\n DACR - Current process DACR\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcStrncpyFromUser(
        pid: SceUID,
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> SceSSize;
    #[doc = "Strncpy to user memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The copy length.\n\n # Returns\n\nThe copied length on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelStrncpyToUserInternal with disable interrupts.\n DACR - Current process DACR\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcStrncpyToUser(
        pid: SceUID,
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> SceSSize;
    #[doc = "Strnlen user memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `s` (direction in) - - The userland memory pointer.\n * `n` (direction in) - - The max length.\n\n # Returns\n\nThe strings length on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelStrnlenUserInternal with disable interrupts.\n DACR - Current process DACR\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcStrnlenUser(
        pid: SceUID,
        s: *const crate::ctypes::c_char,
        n: SceSize,
    ) -> SceSSize;
    #[doc = "The mapping user address space to kernel with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `name` (direction in) - - The mapping name.\n * `permission` (direction in) - - The access permission. 1 for Read.\n * `user_buf` (direction in) - - The target address of user space.\n * `size` (direction in) - - The mapping size.\n * `kernel_page` (direction out) - - The mapped kernel address space.\n * `kernel_size` (direction out) - - The mapped size.\n * `kernel_offset` (direction out) - - The output of address align value.\n For example, if user_buf is 0x81000123, kernel_offset to 0x123.\n\n # Returns\n\nuid on success, < 0 on error.\n\n note - If no longer use the mapped address, need to release it with ksceKernelMemBlockRelease"]
    pub fn ksceKernelProcUserMap(
        pid: SceUID,
        name: *const crate::ctypes::c_char,
        permission: crate::ctypes::c_int,
        user_buf: *const crate::ctypes::c_void,
        size: SceSize,
        kernel_page: *mut *mut crate::ctypes::c_void,
        kernel_size: *mut SceSize,
        kernel_offset: *mut SceUInt32,
    ) -> SceUID;
    #[doc = "Memcpy user memory to user memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland memory pointer.\n * `len` (direction in) - - The copy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelUserMemcpyInternal with disable interrupts.\n DACR - Current process DACR\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcUserMemcpy(
        pid: SceUID,
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the process context\n\n # Arguments\n\n* `pid` (direction in) - - The target process id\n * `ctx` (direction out) - - The context output pointer of pointer"]
    pub fn ksceKernelProcessGetContext(
        pid: SceUID,
        ctx: *mut *mut SceKernelProcessContext,
    ) -> crate::ctypes::c_int;
    #[doc = "Switch the process context\n\n # Arguments\n\n* `new_context` (direction in) - - The new context\n * `prev_context` (direction out) - - The prev context"]
    pub fn ksceKernelProcessSwitchContext(
        new_context: *const SceKernelProcessContext,
        prev_context: *mut SceKernelProcessContext,
    ) -> crate::ctypes::c_int;
    #[doc = "Changes the block type\n\n # Arguments\n\n* `uid` (direction in) - - SceUID of the memory block to change\n * `type` (direction in) - - Type of the memory to change to\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelRemapBlock(uid: SceUID, type_: SceKernelMemBlockType) -> crate::ctypes::c_int;
    #[doc = "Strncpy from user memory\n\n # Arguments\n\n* `dst` (direction in) - - The userland or kernel memory pointer.\n * `src` (direction in) - - The userland memory pointer.\n * `len` (direction in) - - The copy length.\n\n # Returns\n\nThe copied length on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcStrncpyFromUser.\n DACR - 0x55555555\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelStrncpyFromUser(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> SceSSize;
    #[doc = "Strncpy to user memory\n\n # Arguments\n\n* `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The copy length.\n\n # Returns\n\nThe copied length on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcStrncpyToUser.\n DACR - 0x55555555\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelStrncpyToUser(
        dst: *mut crate::ctypes::c_char,
        src: *const crate::ctypes::c_char,
        len: SceSize,
    ) -> SceSSize;
    #[doc = "Strnlen user memory\n\n # Arguments\n\n* `s` (direction in) - - The userland memory pointer.\n * `n` (direction in) - - The max length.\n\n # Returns\n\nThe strings length\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcStrnlenUser.\n DACR - 0x55555555\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelStrnlenUser(s: *const crate::ctypes::c_char, n: SceSize) -> SceSize;
    pub fn ksceKernelSwitchVmaForPid(pid: SceUID) -> crate::ctypes::c_int;
    #[doc = "The mapping user address space to kernel\n\n # Arguments\n\n* `name` (direction in) - - The mapping name.\n * `permission` (direction in) - - The access permission. 1 for Read.\n * `user_buf` (direction in) - - The target address of user space.\n * `size` (direction in) - - The mapping size.\n * `kernel_page` (direction out) - - The mapped kernel address space.\n * `kernel_size` (direction out) - - The mapped size.\n * `kernel_offset` (direction out) - - The output of address align value.\n For example, if user_buf is 0x81000123, kernel_offset to 0x123.\n\n # Returns\n\nuid on success, < 0 on error.\n\n note - If no longer use the mapped address, need to release it with ksceKernelMemBlockRelease"]
    pub fn ksceKernelUserMap(
        name: *const crate::ctypes::c_char,
        permission: crate::ctypes::c_int,
        user_buf: *const crate::ctypes::c_void,
        size: SceSize,
        kernel_page: *mut *mut crate::ctypes::c_void,
        kernel_size: *mut SceSize,
        kernel_offset: *mut SceUInt32,
    ) -> SceUID;
    #[doc = "Memcpy user memory to user memory\n\n # Arguments\n\n* `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland memory pointer.\n * `len` (direction in) - - The copy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcUserMemcpy.\n DACR - 0x55555555\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelUserMemcpy(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the physical address list of a given virtual address range\n\n # Arguments\n\n* `va_range` (direction in) - - The virtual address range\n * `pa_vector` (direction out) - - The vector of physical addresses\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelVARangeToPAVector(
        va_range: *const SceKernelVARange,
        pa_vector: *mut SceKernelPAVector,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the physical address of a given virtual address\n\n # Arguments\n\n* `va` (direction in) - - The virtual address\n * `pa` (direction out) - - The physical address\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelVAtoPA(
        va: *const crate::ctypes::c_void,
        pa: *mut usize,
    ) -> crate::ctypes::c_int;
    pub fn kscePUIDClose(pid: SceUID, puid: SceUID) -> crate::ctypes::c_int;
    pub fn kscePUIDOpenByGUID(pid: SceUID, guid: SceUID) -> SceUID;
    pub fn kscePUIDtoGUID(pid: SceUID, puid: SceUID) -> SceUID;
}
#[link(name = "SceSysmemForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceSysmemForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceSysmemForKernel_363_stub",
    feature = "SceSysmemForKernel_stub"
))]
extern "C" {
    pub fn ksceGUIDKernelCreateWithOpt(
        sce_class: *mut SceClass,
        name: *const crate::ctypes::c_char,
        opt: *mut SceGUIDKernelCreateOpt,
        obj: *mut *mut SceObjectBase,
    ) -> SceUID;
    pub fn ksceKernelFindClassByName(
        name: *const crate::ctypes::c_char,
        cls: *mut *mut SceClass,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets the memory block type of a memory block\n\n # Arguments\n\n* `uid` (direction in) - - SceUID of the memory block\n * `type` (direction out) - - Type of the memory block identified by uid\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelGetMemBlockType(
        uid: SceUID,
        type_: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Memcpy to user RX memory with process\n\n # Arguments\n\n* `pid` (direction in) - - The target process id.\n * `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** - Invoke ksceKernelMemcpyToUserRx with disable interrupts.\n Setting TTBR1 - Yes"]
    pub fn ksceKernelProcMemcpyToUserRx(
        pid: SceUID,
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSysmemForKernel_stub", kind = "static")]
#[cfg(feature = "SceSysmemForKernel_stub")]
extern "C" {
    #[doc = "Get created GUID vectors.\n\n # Arguments\n\n* `cls` (direction in) - - The Class.\n * `vis_level` (direction in) - - The Visible level.\n * `vector` (direction out) - - The GUID vector output.\n * `num` (direction in) - - The GUID vector max number.\n * `ret_num` (direction out) - - The GUID vector result number.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceGUIDGetUIDVectorByClass(
        cls: *mut SceClass,
        vis_level: crate::ctypes::c_int,
        vector: *mut SceUID,
        num: SceSize,
        ret_num: *mut SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Alloc kernel memory\n\n # Arguments\n\n* `size` (direction in) - - The alloction memory size\n\n # Returns\n\nmemory pointer on success, NULL on error."]
    pub fn ksceKernelAlloc(size: crate::ctypes::c_uint) -> *mut crate::ctypes::c_void;
    #[doc = "Free kernel memory\n\n # Arguments\n\n* `ptr` (direction in) - - The free memory pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelFree(ptr: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
    pub fn ksceKernelGetUidDLinkClass() -> *mut SceClass;
    pub fn ksceKernelGetUidHeapClass() -> *mut SceClass;
    pub fn ksceKernelGetUidMemBlockClass() -> *mut SceClass;
    #[doc = "Memcpy to user RO memory\n\n # Arguments\n\n* `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context.\n DACR - 0x15450FC3\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelMemcpyToUserRo(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Memcpy to user RO memory with DcacheAndL2WritebackRange\n\n # Arguments\n\n* `dst` (direction in) - - The userland memory pointer.\n * `src` (direction in) - - The userland or kernel memory pointer.\n * `len` (direction in) - - The memcpy length.\n\n # Returns\n\n0 on success, < 0 on error.\n\n > **Note:** Cannot use this function in kernel context. Use ksceKernelProcMemcpyToUserRx.\n DACR - 0x15450FC3\n Setting TTBR1 - No (use current TTBR1)"]
    pub fn ksceKernelMemcpyToUserRx(
        dst: *mut crate::ctypes::c_void,
        src: *const crate::ctypes::c_void,
        len: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSysmem_stub", kind = "static")]
#[cfg(feature = "SceSysmem_stub")]
extern "C" {
    #[doc = "Allocates a new memory block\n\n # Arguments\n\n* `name` (direction in) - - Name for the memory block\n * `type` (direction in) - - Type of the memory to allocate. Use `SCE_KERNEL_MEMBLOCK_TYPE_USER_*`.\n * `size` (direction in) - - Size of the memory to allocate\n * `opt` (direction in) - - Memory block options?\n\n # Returns\n\nSceUID of the memory block on success, < 0 on error."]
    pub fn sceKernelAllocMemBlock(
        name: *const crate::ctypes::c_char,
        type_: SceKernelMemBlockType,
        size: SceSize,
        opt: *mut SceKernelAllocMemBlockOpt,
    ) -> SceUID;
    pub fn sceKernelAllocMemBlockForVM(name: *const crate::ctypes::c_char, size: SceSize)
        -> SceUID;
    pub fn sceKernelCloseMemBlock(uid: SceUID) -> crate::ctypes::c_int;
    pub fn sceKernelCloseVMDomain() -> crate::ctypes::c_int;
    pub fn sceKernelFindMemBlockByAddr(addr: *const crate::ctypes::c_void, size: SceSize)
        -> SceUID;
    #[doc = "Frees new memory block\n\n # Arguments\n\n* `uid` (direction in) - - SceUID of the memory block to free\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceKernelFreeMemBlock(uid: SceUID) -> crate::ctypes::c_int;
    pub fn sceKernelGetCpuId() -> crate::ctypes::c_int;
    #[doc = "Get free memory size in bytes\n\n # Arguments\n\n* `info` (direction out) - - Returned free memory size for different kind of memory block types\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceKernelGetFreeMemorySize(
        info: *mut SceKernelFreeMemorySizeInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets the base address of a memory block\n\n # Arguments\n\n* `uid` (direction in) - - SceUID of the memory block to free\n * `base` (direction out) - - Base address of the memory block identified by SceUID\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceKernelGetMemBlockBase(
        uid: SceUID,
        base: *mut *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelGetMemBlockInfoByAddr(
        base: *mut crate::ctypes::c_void,
        info: *mut SceKernelMemBlockInfo,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelGetMemBlockInfoByRange(
        base: *mut crate::ctypes::c_void,
        size: SceSize,
        info: *mut SceKernelMemBlockInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the model number of the device\n\n # Returns\n\nA value from SCE_KERNEL_MODEL"]
    pub fn sceKernelGetModel() -> crate::ctypes::c_int;
    #[doc = "Get the model number of the device\n\n # Returns\n\nA value from SCE_KERNEL_MODEL"]
    pub fn sceKernelGetModelForCDialog() -> crate::ctypes::c_int;
    pub fn sceKernelIsPSVitaTV() -> crate::ctypes::c_int;
    pub fn sceKernelOpenMemBlock(
        name: *const crate::ctypes::c_char,
        flags: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn sceKernelOpenVMDomain() -> crate::ctypes::c_int;
    pub fn sceKernelSyncVMDomain(
        uid: SceUID,
        data: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSysmodule_stub", kind = "static")]
#[cfg(feature = "SceSysmodule_stub")]
extern "C" {
    #[doc = "Check if a module is loaded.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to check.\n\n # Returns\n\n0 if loaded, <0 otherwise."]
    pub fn sceSysmoduleIsLoaded(id: SceSysmoduleModuleId) -> crate::ctypes::c_int;
    #[doc = "Check if an internal module is loaded.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to check.\n\n # Returns\n\n0 if loaded, <0 otherwise."]
    pub fn sceSysmoduleIsLoadedInternal(id: SceSysmoduleInternalModuleId) -> crate::ctypes::c_int;
    #[doc = "Load a module.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to load.\n\n # Returns\n\n0 on success, <0 on error."]
    pub fn sceSysmoduleLoadModule(id: SceSysmoduleModuleId) -> crate::ctypes::c_int;
    #[doc = "Load an internal module.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to load.\n\n # Returns\n\n0 on success, <0 on error."]
    pub fn sceSysmoduleLoadModuleInternal(id: SceSysmoduleInternalModuleId)
        -> crate::ctypes::c_int;
    #[doc = "Load an internal module with custom arguments.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to check.\n * `args` (direction in) - - Size of passed arguments.\n * `argp` (direction in) - - Pointer to arguments to pass.\n * `option` (direction in) - - Module load option.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceSysmoduleLoadModuleInternalWithArg(
        id: SceSysmoduleInternalModuleId,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        option: *const SceSysmoduleOpt,
    ) -> crate::ctypes::c_int;
    #[doc = "Unload a module.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to unload.\n\n # Returns\n\n0 on success, <0 on error."]
    pub fn sceSysmoduleUnloadModule(id: SceSysmoduleModuleId) -> crate::ctypes::c_int;
    #[doc = "Unload an internal module.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to unload.\n\n # Returns\n\n0 on success, <0 on error."]
    pub fn sceSysmoduleUnloadModuleInternal(
        id: SceSysmoduleInternalModuleId,
    ) -> crate::ctypes::c_int;
    #[doc = "Unload an internal module with custom arguments.\n\n # Arguments\n\n* `id` (direction in) - - Module ID to check.\n * `args` (direction in) - - Size of passed arguments.\n * `argp` (direction in) - - Pointer to arguments to pass.\n * `option` (direction in) - - Module load option.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceSysmoduleUnloadModuleInternalWithArg(
        id: SceSysmoduleInternalModuleId,
        args: SceSize,
        argp: *mut crate::ctypes::c_void,
        option: *const SceSysmoduleOpt,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceSysrootForDriver_stub", kind = "static")]
#[cfg(feature = "SceSysrootForDriver_stub")]
extern "C" {
    #[doc = "Get SceShell process id\n\n # Returns\n\npid on success, < 0 on error."]
    pub fn ksceKernelSysrootGetShellPid() -> SceUID;
    #[doc = "Get System software version from ksceKernelSysrootSetGetSystemSwVersionFunc setting function\n\n # Returns\n\nSystemSwVersion on success, < 0 on error."]
    pub fn ksceKernelSysrootGetSystemSwVersion() -> crate::ctypes::c_int;
    #[doc = "Register coredump trigger function.\n\n # Arguments\n\n* `func` (direction in) - - The coredump trigger function pointer.\n\n # Returns\n\nnone."]
    pub fn ksceKernelSysrootRegisterCoredumpTrigger(func: SceKernelCoredumpTriggerFunc);
    #[doc = "Set GetSystemSwVersion function.\n\n # Arguments\n\n* `func` (direction in) - - The GetSystemSwVersion function pointer.\n\n # Returns\n\nnone."]
    pub fn ksceKernelSysrootSetGetSystemSwVersionFunc(func: SceKernelGetSystemSwVersionFunc);
    #[doc = "Set handlers for the process lifecycle.\n\n This internal function allows a developer to introspect and receive events based\n on the process lifecycle.\n\n # Arguments\n\n* `handlers` (direction in) - Pointer to struct containing the handlers. This function does not copy the handlers, so this pointer must remain valid after a successful call.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysrootSetProcessHandler(
        handlers: *const SceSysrootProcessHandler,
    ) -> crate::ctypes::c_int;
    #[doc = "Get hardware flags.\n\n # Arguments\n\n* `flags` (direction out) - - The flags output buffer. size is 0x10 byte\n\n # Returns\n\nalways 0."]
    pub fn ksceSysrootGetHardwareFlags(flags: *mut crate::ctypes::c_void) -> crate::ctypes::c_int;
    #[doc = "Get UseExternalStorage status.\n\n Returns 1 if an external device(sdcard) is available.\n\n # Returns\n\n0 or 1."]
    pub fn ksceSysrootUseExternalStorage() -> crate::ctypes::c_int;
    #[doc = "Get UseInternalStorage status.\n\n Returns 1 if using an internal device(pre-memcard).\n\n # Returns\n\n0 or 1."]
    pub fn ksceSysrootUseInternalStorage() -> crate::ctypes::c_int;
}
#[link(name = "SceSysrootForKernel_stub", kind = "static")]
#[cfg(feature = "SceSysrootForKernel_stub")]
extern "C" {
    #[doc = "Get SceKblParam.\n\n # Returns\n\nThe pointer of SceKblParam data or NULL."]
    pub fn ksceKernelSysrootGetKblParam() -> *mut crate::ctypes::c_void;
    pub fn ksceKernelSysrootGetProcessTitleId(
        pid: SceUID,
        titleid: *mut crate::ctypes::c_char,
        len: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Register Dbgp handlers.\n\n # Arguments\n\n* `handlers` (direction in) - pointer of handlers\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysrootRegisterDbgpHandler(
        handlers: *const SceSysrootDbgpHandler,
    ) -> crate::ctypes::c_int;
    #[doc = "Set sysroot object uid.\n\n # Returns\n\nnone.\n\n note - Not should be call this function after boot."]
    pub fn ksceKernelSysrootSetSysroot(sysroot_uid: SceUID);
    #[doc = "Unregister Dbgp handlers.\n\n # Returns\n\nnone."]
    pub fn ksceKernelSysrootUnregisterDbgpHandler();
    pub fn ksceSysrootGetSelfInfo(
        index: SceKernelSysrootSelfIndex,
        info: *mut SceKernelSysrootSelfInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get sysroot object pointer.\n\n # Returns\n\nsysroot object pointer."]
    pub fn ksceSysrootGetSysroot() -> *mut SceSysroot;
    pub fn ksceSysrootIsBsodReboot() -> crate::ctypes::c_int;
    pub fn ksceSysrootIsExternalBootMode() -> crate::ctypes::c_int;
    #[doc = "Get ManufacturingMode status.\n\n Returns 1 if the device is in manufacturing mode.\n\n # Returns\n\n0 or 1."]
    pub fn ksceSysrootIsManufacturingMode() -> crate::ctypes::c_int;
    #[doc = "Get NonRemovableCardMode status.\n\n Returns 1 if using an non removable card(pre-memcard).\n\n # Returns\n\n0 or 1."]
    pub fn ksceSysrootIsNonRemovableCardMode() -> crate::ctypes::c_int;
    pub fn ksceSysrootIsSafeMode() -> crate::ctypes::c_int;
    pub fn ksceSysrootIsUpdateMode() -> crate::ctypes::c_int;
    pub fn ksceSysrootIsUsbEnumWakeup() -> crate::ctypes::c_int;
}
#[link(name = "SceSystemGesture_stub", kind = "static")]
#[cfg(feature = "SceSystemGesture_stub")]
extern "C" {}
#[link(name = "SceSystimerForDriver_stub", kind = "static")]
#[cfg(feature = "SceSystimerForDriver_stub")]
extern "C" {
    #[doc = "Allocate one of the system's timers.\n\n # Arguments\n\n* `timerType` - - One of ::SceSysTimerType.\n\n # Returns\n\nThe id of the new timer on success, < 0 on error."]
    pub fn ksceKernelSysTimerAlloc(timerType: SceSysTimerType) -> SceSysTimerId;
    #[doc = "Free an allocated system timer\n\n # Arguments\n\n* `timerId` - - The timer to free.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerFree(timerId: SceSysTimerId) -> crate::ctypes::c_int;
    #[doc = "Get the timer count value.\n\n # Arguments\n\n* `timerId` - - The target timer.\n * `pCount` - - The variable to store the count to.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerGetCount(
        timerId: SceSysTimerId,
        pCount: *mut SceKernelSysClock,
    ) -> crate::ctypes::c_int;
    #[doc = "Reset the timer count.\n\n # Arguments\n\n* `timerId` - - The target timer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerResetCount(timerId: SceSysTimerId) -> crate::ctypes::c_int;
    #[doc = "Configure the source clock signal for a timer.\n\n # The final input clock is determined as such:\n ```c\n inputClock = sourceClock / (prescaleFactor + 1)\n ```\n\n # Arguments\n\n* `timerId` - - The target timer.\n * `clockSource` - - The source of the clock signal.\n * `prescaleFactor` - - The prescale factor applied to the clock signal.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerSetClockSource(
        timerId: SceSysTimerId,
        clockSource: SceSysTimerClockSource,
        prescaleFactor: SceUInt8,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the timer count value.\n\n # Arguments\n\n* `timerId` - - The target timer.\n * `count` - - The count to set.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerSetCount(
        timerId: SceSysTimerId,
        count: SceKernelSysClock,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the interrupt callback handler for the timer.\n\n # Arguments\n\n* `timerId` - - The target timer.\n * `callback` - - The callback function.\n * `targetCPU` - - The CPU cores the interrupt can be handled from.\n * `pUserData` - - User data to be passed to the callback.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerSetHandler(
        timerId: SceSysTimerId,
        callback: SceSysTimerCallback,
        targetCPU: SceUInt32,
        pUserData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Set the timer interval.\n\n The interval determines the count at which the timer will overflow to 0, and an interrupt will be fired.\n\n # Arguments\n\n* `timerId` - - The target timer.\n * `interval` - - The timer interval.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerSetInterval(
        timerId: SceSysTimerId,
        interval: SceKernelSysClock,
    ) -> crate::ctypes::c_int;
    #[doc = "Start a timer.\n\n # Arguments\n\n* `timerId` - - The target timer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerStartCount(timerId: SceSysTimerId) -> crate::ctypes::c_int;
    #[doc = "Stop a timer.\n\n # Arguments\n\n* `timerId` - - The target timer.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceKernelSysTimerStopCount(timerId: SceSysTimerId) -> crate::ctypes::c_int;
}
#[link(name = "SceTeleportClient_stub", kind = "static")]
#[cfg(feature = "SceTeleportClient_stub")]
extern "C" {}
#[link(name = "SceTeleportServer_stub", kind = "static")]
#[cfg(feature = "SceTeleportServer_stub")]
extern "C" {}
#[link(name = "SceThreadmgrForDriver_stub", kind = "static")]
#[cfg(feature = "SceThreadmgrForDriver_stub")]
extern "C" {
    #[doc = "Cancel a callback ?\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelCancelCallback(cb: SceUID) -> crate::ctypes::c_int;
    #[doc = "Cancel a message pipe\n\n # Arguments\n\n* `uid` - - UID of the pipe to cancel\n * `psend` - - Receive number of sending threads, NULL is valid\n * `precv` - - Receive number of receiving threads, NULL is valid\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelCancelMsgPipe(
        uid: SceUID,
        psend: *mut crate::ctypes::c_int,
        precv: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Cancels a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::ksceKernelCreateMutex\n * `newCount` - - The new lock count of the mutex\n * `numWaitThreads` - - Number of threads waiting for the mutex\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelCancelMutex(
        mutexid: SceUID,
        newCount: crate::ctypes::c_int,
        numWaitThreads: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Change the threads current priority.\n\n # Arguments\n\n* `thid` - - The ID of the thread (from ::ksceKernelCreateThread or ::ksceKernelGetThreadId)\n * `priority` - - The new priority (the lower the number the higher the priority)\n\n # Example:\n ```c\n int thid = ksceKernelGetThreadId();\n // Change priority of current thread to 16\n ksceKernelChangeThreadPriority(thid, 16);\n ```\n\n # Returns\n\n0 if successful, otherwise the error code."]
    pub fn ksceKernelChangeThreadPriority(
        thid: SceUID,
        priority: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Change the thread suspension status to another value.\n\n More research needs to be done to find out exactly what each status actually means. Some examples of useful scenarios:\n When handling an exception changing the status to 0x1002 (on a newly suspended thread) will stop the kernel rethrowing the same exception.\n When resuming a suspended thread changing the status to 2 will allow it to resume.\n\n > **Note:** The valid mask for `status` is 0xF7F03.\n\n # Arguments\n\n* `thid` (direction in) - The thread to change.\n * `status` (direction in) - The new status for suspension.\n # Returns\n\nZero on success, else < 0 on error."]
    pub fn ksceKernelChangeThreadSuspendStatus(
        thid: SceUID,
        status: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Check callback ?\n\n # Returns\n\nSomething or another"]
    pub fn ksceKernelCheckCallback() -> crate::ctypes::c_int;
    #[doc = "Clear a event flag bit pattern\n\n # Arguments\n\n* `evid` - - The event id returned by ::ksceKernelCreateEventFlag\n * `bits` - - The bits to clean\n\n # Returns\n\n< 0 on Error"]
    pub fn ksceKernelClearEventFlag(
        evfid: SceUID,
        bits: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Create callback\n\n # Example:\n ```c\n int cbid;\n cbid = ksceKernelCreateCallback(\"Exit Callback\", 0, exit_cb, NULL);\n ```\n\n # Arguments\n\n* `name` - - A textual name for the callback\n * `func` - - A pointer to a function that will be called as the callback\n * `arg` - - Argument for the callback ?\n\n # Returns\n\n>= 0 A callback id which can be used in subsequent functions, < 0 an error."]
    pub fn ksceKernelCreateCallback(
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_uint,
        func: SceKernelCallbackFunction,
        arg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Creates a new condition variable\n\n # Example:\n ```c\n SceUID condId;\n condId = ksceKernelCreateCond(\"MyCond\", 0, mutexId, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the condition variable\n * `attr` - - Condition variable attribute flags (normally set to 0)\n * `mutexId` - - Mutex to be related to the condition variable\n * `option` - - Condition variable options (normally set to 0)\n # Returns\n\nA condition variable id"]
    pub fn ksceKernelCreateCond(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        mutexId: SceUID,
        option: *const SceKernelCondOptParam,
    ) -> SceUID;
    #[doc = "Create an event flag.\n\n # Arguments\n\n* `name` - - The name of the event flag.\n * `attr` - - Attributes from ::SceEventFlagAttributes\n * `bits` - - Initial bit pattern.\n * `opt` - - Options, set to NULL\n # Returns\n\n< 0 on error. >= 0 event flag id.\n\n # Example:\n ```c\n int evid;\n evfid = ksceKernelCreateEventFlag(\"wait_event_flags\", 0, 0, NULL);\n ```"]
    pub fn ksceKernelCreateEventFlag(
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_int,
        bits: crate::ctypes::c_int,
        opt: *mut SceKernelEventFlagOptParam,
    ) -> SceUID;
    #[doc = "Create a message pipe\n\n # Arguments\n\n* `name` - - Name of the pipe\n * `type` - - The type of memory attribute to use internally (set to 0x40)\n * `attr` - - Set to 12\n * `bufSize` - - The size of the internal buffer in multiples of 0x1000 (4KB)\n * `opt` - - Message pipe options (set to NULL)\n\n # Returns\n\nThe UID of the created pipe, < 0 on error"]
    pub fn ksceKernelCreateMsgPipe(
        name: *const crate::ctypes::c_char,
        type_: crate::ctypes::c_int,
        attr: crate::ctypes::c_int,
        bufSize: SceSize,
        opt: *mut crate::ctypes::c_void,
    ) -> SceUID;
    #[doc = "Creates a new mutex\n\n # Example:\n ```c\n int mutexid;\n mutexid = ksceKernelCreateMutex(\"MyMutex\", 0, 1, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the mutex\n * `attr` - - Mutex attribute flags (normally set to 0)\n * `initCount` - - Mutex initial value\n * `option` - - Mutex options (normally set to 0)\n # Returns\n\nA mutex id"]
    pub fn ksceKernelCreateMutex(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        initCount: crate::ctypes::c_int,
        option: *mut SceKernelMutexOptParam,
    ) -> SceUID;
    #[doc = "Creates a new semaphore\n\n # Example:\n ```c\n int semaid;\n semaid = ksceKernelCreateSema(\"MySema\", 0, 1, 1, NULL);\n ```\n\n # Arguments\n\n* `name` - - Specifies the name of the sema\n * `attr` - - Sema attribute flags (normally set to 0)\n * `initVal` - - Sema initial value\n * `maxVal` - - Sema maximum value\n * `option` - - Sema options (normally set to 0)\n # Returns\n\nA semaphore id"]
    pub fn ksceKernelCreateSema(
        name: *const crate::ctypes::c_char,
        attr: SceUInt,
        initVal: crate::ctypes::c_int,
        maxVal: crate::ctypes::c_int,
        option: *mut SceKernelSemaOptParam,
    ) -> SceUID;
    #[doc = "Create a thread\n\n # Example:\n ```c\n SceUID thid;\n thid = ksceKernelCreateThread(\"my_thread\", threadFunc, 0x10000100, 0x10000, 0, 0, NULL);\n ```\n\n # Arguments\n\n* `name` - - An arbitrary thread name.\n * `entry` - - The thread function to run when started.\n * `initPriority` - - The initial priority of the thread. Less if higher priority.\n * `stackSize` - - The size of the initial stack.\n * `attr` - - The thread attributes, zero or more of ::SceThreadAttributes.\n * `cpuAffinityMask` - - The CPU affinity mask\n * `option` - - Additional options specified by ::SceKernelThreadOptParam.\n\n # Returns\n\nUID of the created thread, or an error code."]
    pub fn ksceKernelCreateThread(
        name: *const crate::ctypes::c_char,
        entry: SceKernelThreadEntry,
        initPriority: crate::ctypes::c_int,
        stackSize: SceSize,
        attr: SceUInt,
        cpuAffinityMask: crate::ctypes::c_int,
        option: *const SceKernelThreadOptParam,
    ) -> SceUID;
    #[doc = "Debug resume a thread.\n\n > **Note:** The valid mask for `status` is 0xF7F03.\n\n # Arguments\n\n* `thid` (direction in) - The thread global uid.\n * `status` (direction in) - The suspend status to resume from.\n\n # Returns\n\nZero on success, else <0 on error."]
    pub fn ksceKernelDebugResumeThread(
        thid: SceUID,
        status: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Debug suspend a thread.\n\n > **Note:** The valid mask for `status` is 0xF7F03.\n\n # Arguments\n\n* `thid` (direction in) - The thread global uid.\n * `status` (direction in) - The suspend status.\n\n # Returns\n\nZero on success, else <0 on error."]
    pub fn ksceKernelDebugSuspendThread(
        thid: SceUID,
        status: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Delay the current thread by a specified number of microseconds\n\n # Arguments\n\n* `delay` - - Delay in microseconds.\n\n # Example:\n ```c\n ksceKernelDelayThread(1000000); // Delay for a second\n ```"]
    pub fn ksceKernelDelayThread(delay: SceUInt) -> crate::ctypes::c_int;
    #[doc = "Delay the current thread by a specified number of microseconds and handle any callbacks.\n\n # Arguments\n\n* `delay` - - Delay in microseconds.\n\n # Example:\n ```c\n ksceKernelDelayThread(1000000); // Delay for a second\n ```"]
    pub fn ksceKernelDelayThreadCB(delay: SceUInt) -> crate::ctypes::c_int;
    #[doc = "Delete a callback\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelDeleteCallback(cb: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a condition variable\n\n # Arguments\n\n* `condition` - variableid - The condition variable id returned from ::ksceKernelCreateCond\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn ksceKernelDeleteCond(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Delete an event flag\n\n # Arguments\n\n* `evid` - - The event id returned by ::ksceKernelCreateEventFlag.\n\n # Returns\n\n< 0 On error"]
    pub fn ksceKernelDeleteEventFlag(evfid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Delete a message pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelDeleteMsgPipe(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::ksceKernelCreateMutex\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn ksceKernelDeleteMutex(mutexid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Destroy a semaphore\n\n # Arguments\n\n* `semaid` - - The semaid returned from a previous create call.\n # Returns\n\nReturns the value 0 if it's successful, otherwise -1"]
    pub fn ksceKernelDeleteSema(semaid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Delate a thread\n\n # Arguments\n\n* `thid` - - UID of the thread to be deleted.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelDeleteThread(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Enqueue work to a workqueue\n\n # Arguments\n\n* `uid` (direction in) - UID of the workqueue (0x10023 for the SceKernelGlobalWorkQueue)\n * `name` (direction in) - Name of the work to enqueue\n * `work` (direction in) - Work function to enqueue\n * `args` (direction in) - Argument to pass to the work function\n\n # Returns\n\nZero on success"]
    pub fn ksceKernelEnqueueWorkQueue(
        uid: SceUID,
        name: *const crate::ctypes::c_char,
        work: SceKernelWorkQueueWorkFunction,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Exit a thread and delete itself.\n\n # Arguments\n\n* `status` - - Exit status"]
    pub fn ksceKernelExitDeleteThread(status: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Exit a thread\n\n # Arguments\n\n* `status` - - Exit status."]
    pub fn ksceKernelExitThread(status: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceKernelFinalizeFastMutex(fast_mutex: *mut SceKernelFastMutex)
        -> crate::ctypes::c_int;
    #[doc = "Get the callback count\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n\n # Returns\n\nThe callback count, < 0 on error"]
    pub fn ksceKernelGetCallbackCount(cb: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get event flags info\n\n # Arguments\n\n* `evfid` (direction in) - - The event flags guid.\n * `info` (direction out) - - The info output buffer pointer.\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelGetEventFlagInfo(
        evfid: SceUID,
        info: *mut SceKernelEventFlagInfo,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetFastMutexInfo(
        fast_mutex: *mut SceKernelFastMutex,
        info: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetLwCondInfo(
        lwcond_id: SceUID,
        info: *mut SceKernelLwCondInfo,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetLwMutexInfo(
        lwmtxid: SceUID,
        info: *mut SceKernelLwMutexInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get msgpipe info\n\n # Arguments\n\n* `msgpipe_id` (direction in) - - The msg pipe guid.\n * `info` (direction out) - - The info output buffer pointer.\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelGetMsgPipeInfo(
        msgpipe_id: SceUID,
        info: *mut SceKernelMsgPipeInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Retrieve information about a mutex.\n\n # Arguments\n\n* `mutexid` - - UID of the mutex to retrieve info for.\n * `info` - - Pointer to a ::SceKernelMutexInfo struct to receive the info.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelGetMutexInfo(
        mutexid: SceUID,
        info: *mut SceKernelMutexInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Gets the current process PID\n\n # Returns\n\nCurrent PID"]
    pub fn ksceKernelGetProcessId() -> SceUID;
    #[doc = "Get Process id from Thread Local Storage\n\n # Returns\n\ncurrent process id"]
    pub fn ksceKernelGetProcessIdFromTLS() -> SceUID;
    #[doc = "Get semaphore info\n\n # Arguments\n\n* `semaid` (direction in) - - The semaphore guid.\n * `info` (direction out) - - The info output buffer pointer.\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelGetSemaInfo(
        semaid: SceUID,
        info: *mut SceKernelSemaInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the system time\n\n # Returns\n\nThe system time"]
    pub fn ksceKernelGetSystemTimeLow() -> SceUInt32;
    #[doc = "Get the system time (wide version)\n\n # Returns\n\nThe system time"]
    pub fn ksceKernelGetSystemTimeWide() -> SceInt64;
    #[doc = "ksceKernelGetTLSAddr get pointer to TLS key area for current thread\n # Arguments\n\n* `key` - - the TLS keyslot index\n # Returns\n\npointer to TLS key value"]
    pub fn ksceKernelGetTLSAddr(key: crate::ctypes::c_int) -> *mut crate::ctypes::c_void;
    #[doc = "Query the state of the registers for a suspended thread.\n\n The registers returned are the user/kernel set for the requested thread.\n It's not certain that user/kernel is correct representation, instead it could be current/exception.\n The thread provided must be suspended for this function to succeed.\n\n # Arguments\n\n* `thid` (direction in) - The thread to query.\n * `registers` (direction out) - The set of registers belonging to the thread.\n # Returns\n\nZero on success, else < 0 on error."]
    pub fn ksceKernelGetThreadCpuRegisters(
        thid: SceUID,
        registers: *mut SceThreadCpuRegisters,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the current priority of the thread you are in.\n\n # Returns\n\nThe current thread priority"]
    pub fn ksceKernelGetThreadCurrentPriority() -> crate::ctypes::c_int;
    #[doc = "Get the current thread Id\n\n # Returns\n\nThe thread id of the calling thread."]
    pub fn ksceKernelGetThreadId() -> crate::ctypes::c_int;
    #[doc = "Retrieve a list of all threads belonging to a process.\n # Arguments\n\n* `pid` (direction in) - The process to query.\n * `ids` (direction out) - The list of thread ids. Can be NULL if output is not required.\n * `n` (direction in) - The max number of thread ids to copy out.\n * `copy_count` (direction out) - The number of thread ids copied.\n # Returns\n\nThe number of threads within the process, else < 0 on error."]
    pub fn ksceKernelGetThreadIdList(
        pid: SceUID,
        ids: *mut SceUID,
        n: crate::ctypes::c_int,
        copy_count: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the thread info by thread id.\n\n # Arguments\n\n* `thid` - - The thread id for get info.\n * `info` - - The info output.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelGetThreadInfo(
        thid: SceUID,
        info: *mut SceKernelThreadInfo,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelGetThreadInfoForDebugger(
        thid: SceUID,
        a2: crate::ctypes::c_int,
        pInfo: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get the free stack size for a thread.\n\n # Arguments\n\n* `thid` - - The thread ID\n\n # Returns\n\nThe free size."]
    pub fn ksceKernelGetThreadStackFreeSize(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "ksceKernelGetThreadTLSAddr gets an address to a 4 bytes area of TLS memory for the specified thread\n # Arguments\n\n* `thid` - - The UID of the thread to access TLS\n * `key` - - the TLS keyslot index\n # Returns\n\npointer to TLS memory"]
    pub fn ksceKernelGetThreadTLSAddr(
        thid: SceUID,
        key: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_void;
    #[doc = "Get the type of a Threadmgr uid\n\n # Arguments\n\n* `uid` - - The uid to get the type from\n\n # Returns\n\nThe type, < 0 on error"]
    pub fn ksceKernelGetThreadmgrUIDClass(uid: SceUID) -> SceKernelIdListType;
    #[doc = "Get thread PUID from GUID.\n\n # Arguments\n\n* `thid` (direction in) - - The thread global uid.\n\n # Returns\n\nthread_puid on success, else < 0 on error."]
    pub fn ksceKernelGetUserThreadId(thid: SceUID) -> SceUID;
    pub fn ksceKernelGetVfpRegisterForDebugger(
        thid: SceUID,
        pVfpRegister: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelInitializeFastMutex(
        fast_mutex: *mut SceKernelFastMutex,
        name: *const crate::ctypes::c_char,
        attr: crate::ctypes::c_int,
        opt: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get thread suspend status.\n\n # Arguments\n\n* `thid` (direction in) - - The thread global uid.\n\n # Returns\n\nSuspend status on success, else <0 on error."]
    pub fn ksceKernelIsThreadDebugSuspended(thid: SceUID) -> crate::ctypes::c_int;
    pub fn ksceKernelLockFastMutex(fast_mutex: *mut SceKernelFastMutex) -> crate::ctypes::c_int;
    #[doc = "Lock a mutex\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::ksceKernelCreateMutex\n * `lockCount` - - The value to increment to the lock count of the mutex\n * `timeout` - - Timeout in microseconds (assumed)\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelLockMutex(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Notify a callback\n\n # Arguments\n\n* `cb` - - The UID of the specified callback\n * `arg2` - - Passed as arg2 into the callback function\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelNotifyCallback(cb: SceUID, arg2: crate::ctypes::c_int)
        -> crate::ctypes::c_int;
    #[doc = "Poll an event flag for a given bit pattern.\n\n # Arguments\n\n* `evid` - - The event id returned by ::ksceKernelCreateEventFlag.\n * `bits` - - The bit pattern to poll for.\n * `wait` - - Wait type, one or more of ::SceEventFlagWaitTypes or'ed together\n * `outBits` - - The bit pattern that was matched.\n # Returns\n\n< 0 On error"]
    pub fn ksceKernelPollEventFlag(
        evfid: SceUID,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Poll a semaphore.\n\n # Arguments\n\n* `semaid` - - UID of the semaphore to poll.\n * `signal` - - The value to test for.\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelPollSema(semaid: SceUID, signal: crate::ctypes::c_int)
        -> crate::ctypes::c_int;
    #[doc = "Receive a message from a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - async vs sync? use 0 for sync\n * `unk2` - - Unknown - use NULL\n * `timeout` - - Timeout for receive in us. use NULL to wait indefinitely\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelReceiveMsgPipeVector(
        uid: SceUID,
        v: *const MsgPipeRecvData,
        n: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Runs a function with larger stack size\n\n # Arguments\n\n* `stack_size` (direction in) - The stack size\n * `to_call` (direction in) - To call\n * `args` - The arguments\n\n # Returns\n\nZero on success"]
    pub fn ksceKernelRunWithStack(
        stack_size: SceSize,
        to_call: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void) -> crate::ctypes::c_int,
        >,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Send a message to a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - async vs sync? use 0 for sync\n * `unk2` - - Unknown - use NULL\n * `timeout` - - Timeout for send in us. use NULL to wait indefinitely\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelSendMsgPipeVector(
        uid: SceUID,
        v: *const MsgPipeSendData,
        n: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Set an event flag bit pattern.\n\n # Arguments\n\n* `evid` - - The event id returned by ::ksceKernelCreateEventFlag.\n * `bits` - - The bit pattern to set.\n\n # Returns\n\n< 0 On error"]
    pub fn ksceKernelSetEventFlag(
        evfid: SceUID,
        bits: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Set Permission\n\n # Arguments\n\n* `value` (direction in) - - The new permission\n\n # Returns\n\nprevious permission value"]
    pub fn ksceKernelSetPermission(value: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Set Process id to Thread Local Storage\n\n # Arguments\n\n* `value` (direction in) - - The new process id\n\n # Returns\n\nprevious process id"]
    pub fn ksceKernelSetProcessIdToTLS(pid: SceUID) -> SceUID;
    #[doc = "Signals a condition variable\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::ksceKernelCreateCond\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelSignalCond(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Signals a condition variable to all threads waiting for it\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::ksceKernelCreateCond\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelSignalCondAll(condId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Signals a condition variable to a specific thread waiting for it\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::ksceKernelCreateCond\n * `threadId` - - The thread id returned from ::ksceKernelCreateThread\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelSignalCondTo(condId: SceUID, threadId: SceUID) -> crate::ctypes::c_int;
    #[doc = "Send a signal to a semaphore\n\n # Example:\n ```c\n // Signal the sema\n ksceKernelSignalSema(semaid, 1);\n ```\n\n # Arguments\n\n* `semaid` - - The sema id returned from ::ksceKernelCreateSema\n * `signal` - - The amount to signal the sema (i.e. if 2 then increment the sema by 2)\n\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelSignalSema(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Start a created thread\n\n # Arguments\n\n* `thid` - - Thread id from ::ksceKernelCreateThread\n * `arglen` - - Length of the data pointed to by argp, in bytes\n * `argp` - - Pointer to the arguments."]
    pub fn ksceKernelStartThread(
        thid: SceUID,
        arglen: SceSize,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelTryLockFastMutex(fast_mutex: *mut SceKernelFastMutex) -> crate::ctypes::c_int;
    #[doc = "Try to lock a mutex (non-blocking)\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::ksceKernelCreateMutex\n * `lockCount` - - The value to increment to the lock count of the mutex\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelTryLockMutex(
        mutexid: SceUID,
        lockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Receive a message from a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - use 0\n * `unk2` - - Unknown - use NULL\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelTryReceiveMsgPipeVector(
        uid: SceUID,
        v: *const MsgPipeRecvData,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Try to send a message to a pipe\n\n # Arguments\n\n* `uid` - - The UID of the pipe\n * `message` - - Pointer to the message\n * `size` - - Size of the message\n * `unk1` - - Unknown - use 0\n * `unk2` - - Unknown - use NULL\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceKernelTrySendMsgPipeVector(
        uid: SceUID,
        v: *const MsgPipeSendData,
        size: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    pub fn ksceKernelUnlockFastMutex(fast_mutex: *mut SceKernelFastMutex) -> crate::ctypes::c_int;
    #[doc = "Try to unlock a mutex (non-blocking)\n\n # Arguments\n\n* `mutexid` - - The mutex id returned from ::ksceKernelCreateMutex\n * `unlockCount` - - The value to decrement to the lock count of the mutex\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelUnlockMutex(
        mutexid: SceUID,
        unlockCount: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Waits for a signal of a condition variable\n\n # Arguments\n\n* `condId` - - The condition variable id returned from ::ksceKernelCreateCond\n * `timeout` - - Timeout in microseconds (assumed)\n # Returns\n\n< 0 On error."]
    pub fn ksceKernelWaitCond(
        condId: SceUID,
        timeout: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for an event flag for a given bit pattern.\n\n # Arguments\n\n* `evid` - - The event id returned by ::ksceKernelCreateEventFlag.\n * `bits` - - The bit pattern to poll for.\n * `wait` - - Wait type, one or more of ::SceEventFlagWaitTypes or'ed together\n * `outBits` - - The bit pattern that was matched.\n * `timeout` - - Timeout in microseconds\n # Returns\n\n< 0 On error"]
    pub fn ksceKernelWaitEventFlag(
        evfid: SceUID,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for an event flag for a given bit pattern with callback.\n\n # Arguments\n\n* `evid` - - The event id returned by ::ksceKernelCreateEventFlag.\n * `bits` - - The bit pattern to poll for.\n * `wait` - - Wait type, one or more of ::SceEventFlagWaitTypes or'ed together\n * `outBits` - - The bit pattern that was matched.\n * `timeout` - - Timeout in microseconds\n # Returns\n\n< 0 On error"]
    pub fn ksceKernelWaitEventFlagCB(
        evfid: SceUID,
        bits: crate::ctypes::c_uint,
        wait: crate::ctypes::c_uint,
        outBits: *mut crate::ctypes::c_uint,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Lock a semaphore\n\n # Example:\n ```c\n ksceKernelWaitSema(semaid, 1, NULL);\n ```\n\n # Arguments\n\n* `semaid` - - The sema id returned from ::ksceKernelCreateSema\n * `signal` - - The value to wait for (i.e. if 1 then wait till reaches a signal state of 1)\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelWaitSema(
        semaid: SceUID,
        signal: crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait until a thread has ended.\n\n # Arguments\n\n* `thid` - - Id of the thread to wait for.\n * `stat` - - Exit status.\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelWaitThreadEnd(
        thid: SceUID,
        stat: *mut crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait until a thread has ended and handle callbacks if necessary.\n\n # Arguments\n\n* `thid` - - Id of the thread to wait for.\n * `stat` - - Exit status.\n * `timeout` - - Timeout in microseconds (assumed).\n\n # Returns\n\n< 0 on error."]
    pub fn ksceKernelWaitThreadEndCB(
        thid: SceUID,
        stat: *mut crate::ctypes::c_int,
        timeout: *mut SceUInt,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceThreadmgrForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceThreadmgrForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceThreadmgrForKernel_363_stub",
    feature = "SceThreadmgrForKernel_stub"
))]
extern "C" {
    #[doc = "Obtain the context information for the thread scheduled on this CPU.\n\n This function can be called from an exception handler to obtain information about\n the thread that was interrupted.\n\n # Arguments\n\n* `pInfo` (direction out) - Context information of the thread\n\n # Returns\n\nZero on success, < 0 on error"]
    pub fn ksceKernelGetThreadContextInfo(
        pInfo: *mut SceKernelThreadContextInfo,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceThreadmgrForKernel_stub", kind = "static")]
#[cfg(feature = "SceThreadmgrForKernel_stub")]
extern "C" {}
#[link(name = "SceTouchForDriver_stub", kind = "static")]
#[cfg(feature = "SceTouchForDriver_stub")]
extern "C" {
    #[doc = "Set touch enable flag\n\n # Arguments\n\n* `port` (direction in) - - The port number.\n * `enable` (direction in) - - The enable flag.\n\n # Returns\n\n0 on success. < 0 on error."]
    pub fn ksceTouchSetEnableFlag(port: SceUInt32, enable: SceBool) -> crate::ctypes::c_int;
}
#[link(name = "SceTouch_stub", kind = "static")]
#[cfg(feature = "SceTouch_stub")]
extern "C" {
    #[doc = "Disable touch force output.\n\n # Arguments\n\n* `port` (direction in) - Port number."]
    pub fn sceTouchDisableTouchForce(port: SceUInt32) -> crate::ctypes::c_int;
    #[doc = "Enable touch force output.\n\n # Arguments\n\n* `port` (direction in) - Port number."]
    pub fn sceTouchEnableTouchForce(port: SceUInt32) -> crate::ctypes::c_int;
    #[doc = "Get Touch Panel information\n\n # Arguments\n\n* `port` (direction in) - Port number.\n * `pPanelInfo` (direction out) - The buffer to get the Touch Panel information."]
    pub fn sceTouchGetPanelInfo(
        port: SceUInt32,
        pPanelInfo: *mut SceTouchPanelInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get sampling state of touch panel.\n\n # Arguments\n\n* `port` (direction in) - Port number.\n * `pState` (direction out) - The buffer to receive sampling state."]
    pub fn sceTouchGetSamplingState(
        port: SceUInt32,
        pState: *mut SceTouchSamplingState,
    ) -> crate::ctypes::c_int;
    #[doc = "Get touch data (Polling)\n\n # Arguments\n\n* `port` (direction in) - port number.\n * `pData` (direction out) - Buffer to receive touch data.\n * `nBufs` (direction in) - Number of buffers to receive touch data.\n\n # Returns\n\nBuffers count, between 1 and 'nBufs'. <0 on error."]
    pub fn sceTouchPeek(
        port: SceUInt32,
        pData: *mut SceTouchData,
        nBufs: SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Get touch data (Blocking)\n\n # Arguments\n\n* `port` (direction in) - Port Number.\n * `pData` (direction out) - Buffer to receive touch data.\n * `nBufs` (direction in) - Number of buffers to receive touch data.\n\n # Returns\n\nBuffers count, between 1 and 'nBufs'. <0 on error."]
    pub fn sceTouchRead(
        port: SceUInt32,
        pData: *mut SceTouchData,
        nBufs: SceUInt32,
    ) -> crate::ctypes::c_int;
    #[doc = "Set sampling state of touch panel.\n\n # Arguments\n\n* `port` (direction in) - Port number.\n * `state` (direction in) - Sampling state."]
    pub fn sceTouchSetSamplingState(
        port: SceUInt32,
        state: SceTouchSamplingState,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceTriggerUtil_stub", kind = "static")]
#[cfg(feature = "SceTriggerUtil_stub")]
extern "C" {
    #[doc = "Get value from \"Settings->System->Auto-Start Settings\" for caller application. Required to be 1 to use sceTriggerUtil\n\n # Arguments\n\n* `status` (direction out) - - auto-start status. Required to be 1 to use sceTriggerUtil.\n * `a2` (direction in) - - Unknown, set to 0.\n * `a3` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetAutoStartStatus(
        status: *mut crate::ctypes::c_int,
        a2: crate::ctypes::c_int,
        a3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get daily event info for caller application\n\n # Arguments\n\n* `eventId` (direction in) - - ID number of event to get information for.\n * `param` (direction out) - - event parameters.\n * `a5` (direction in) - - Unknown, set to 0.\n * `a6` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetDailyEventInfo(
        eventId: crate::ctypes::c_int,
        param: *mut SceTriggerUtilEventParamDaily,
        a5: crate::ctypes::c_int,
        a6: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get one time event info for caller application\n\n # Arguments\n\n* `eventId` (direction in) - - ID number of event to get information for.\n * `triggerTime` (direction out) - - SceRtcTick, UTC\n * `a4` (direction in) - - Unknown, set to 0.\n * `a5` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetOneTimeEventInfo(
        eventId: crate::ctypes::c_int,
        triggerTime: *mut SceRtcTick,
        a4: crate::ctypes::c_int,
        a5: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get list of system applications that has registered sceTriggerUtil events. List contains null-separated fake title IDs\n\n # Arguments\n\n* `titleIdBuffer` (direction out) - - pointer to buffer to recieve fake title ID list. Max size is 0x140, min size is unlimited\n * `numOfIds` (direction out) - - number of fake title IDs stored in the list\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetRegisteredSystemTitleIdList(
        buffer: *mut crate::ctypes::c_char,
        numOfIds: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get list of user applications that has registered sceTriggerUtil events. List contains null-separated title IDs\n\n # Arguments\n\n* `titleIdBuffer` (direction out) - - pointer to buffer to recieve title ID list. Max size is 0x1000, min size is unlimited\n * `numOfIds` (direction out) - - number of title IDs stored in the list\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetRegisteredUserTitleIdList(
        titleIdBuffer: *mut crate::ctypes::c_char,
        numOfIds: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get info for system application that has registered sceTriggerUtil events\n\n # Arguments\n\n* `titleid` (direction in) - - title ID of application to get info for.\n * `appInfo` (direction out) - - application information\n * `a4` (direction in) - - Unknown, set to 0.\n * `a5` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetSystemAppInfo(
        titleid: *const crate::ctypes::c_char,
        appInfo: *mut SceTriggerUtilSystemAppInfo,
        a4: crate::ctypes::c_int,
        a5: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get info for user application that has registered sceTriggerUtil events\n\n # Arguments\n\n* `titleid` (direction in) - - title ID of application to get info for.\n * `appInfo` (direction out) - - application information\n * `a4` (direction in) - - Unknown, set to 0.\n * `a5` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilGetUserAppInfo(
        titleid: *const crate::ctypes::c_char,
        appInfo: *mut SceTriggerUtilUserAppInfo,
        a4: crate::ctypes::c_int,
        a5: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Register application start event that will be repeated on certain days\n\n # Arguments\n\n* `titleid` (direction in) - - title ID of application to register event for.\n * `param` (direction in) - - event parameters.\n * `eventId` (direction in) - - ID number of event.\n * `a4` (direction in) - - Unknown, set to 0.\n * `a5` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilRegisterDailyEvent(
        titleid: *const crate::ctypes::c_char,
        param: *const SceTriggerUtilEventParamDaily,
        eventId: crate::ctypes::c_int,
        a4: crate::ctypes::c_int,
        a5: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Register one time application start event\n\n # Arguments\n\n* `titleid` (direction in) - - title ID of application to register event for.\n * `param` (direction in) - - event parameters.\n * `eventId` (direction in) - - ID number of event.\n * `a4` (direction in) - - Unknown, set to 0.\n * `a5` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilRegisterOneTimeEvent(
        titleid: *const crate::ctypes::c_char,
        param: *const SceTriggerUtilEventParamOneTime,
        eventId: crate::ctypes::c_int,
        a4: crate::ctypes::c_int,
        a5: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Unregister daily event for caller application\n\n # Arguments\n\n* `eventId` (direction in) - - ID number of event to unregister.\n * `a2` (direction in) - - Unknown, set to 0.\n * `a3` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilUnregisterDailyEvent(
        eventId: crate::ctypes::c_int,
        a2: crate::ctypes::c_int,
        a3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Unregister one time event for caller application\n\n # Arguments\n\n* `eventId` (direction in) - - ID number of event to unregister.\n * `a2` (direction in) - - Unknown, set to 0.\n * `a3` (direction in) - - Unknown, set to 0.\n\n # Returns\n\n0 on success, <0 otherwise."]
    pub fn sceTriggerUtilUnregisterOneTimeEvent(
        eventId: crate::ctypes::c_int,
        a2: crate::ctypes::c_int,
        a3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceUartForKernel_363_stub", kind = "static")]
#[cfg(feature = "SceUartForKernel_363_stub")]
extern "C" {}
#[cfg(any(
    feature = "SceUartForKernel_363_stub",
    feature = "SceUartForKernel_stub"
))]
extern "C" {
    pub fn ksceUartInit(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceUartRead(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceUartReadAvailable(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceUartWrite(
        port: crate::ctypes::c_int,
        data: crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceUartForKernel_stub", kind = "static")]
#[cfg(feature = "SceUartForKernel_stub")]
extern "C" {}
#[link(name = "SceUdcdForDriver_stub", kind = "static")]
#[cfg(feature = "SceUdcdForDriver_stub")]
extern "C" {
    #[doc = "Activate a USB driver.\n\n # Arguments\n\n* `pid` - - Product ID for the default USB Driver\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdActivate(productId: crate::ctypes::c_uint) -> crate::ctypes::c_int;
    #[doc = "Activate a USB driver for an UDCD bus.\n\n # Arguments\n\n* `pid` - - Product ID for the default USB Driver\n * `bus_powered` (direction in) - - Enable USB bus power\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdActivateInternal(
        productId: crate::ctypes::c_uint,
        bus_powered: crate::ctypes::c_uint,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Clear the FIFO on an endpoint\n\n # Arguments\n\n* `endp` - - The endpoint to clear\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdClearFIFO(endp: *mut SceUdcdEndpoint) -> crate::ctypes::c_int;
    #[doc = "Clear the FIFO on an endpoint for an UDCD bus\n\n # Arguments\n\n* `endp` - - The endpoint to clear\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdClearFIFOInternal(
        endp: *mut SceUdcdEndpoint,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Deactivate USB driver.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdDeactivate() -> crate::ctypes::c_int;
    #[doc = "Deactivate USB driver for an UDCD bus.\n\n # Arguments\n\n* `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdDeactivateInternal(bus: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get device information\n\n # Arguments\n\n* `devInfo` (direction out) - - Device information\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdGetDeviceInfo(devInfo: *mut SceUdcdDeviceInfo) -> crate::ctypes::c_int;
    #[doc = "Get device information for an UDCD bus\n\n # Arguments\n\n* `devInfo` (direction out) - - Device information\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdGetDeviceInfoInternal(
        devInfo: *mut SceUdcdDeviceInfo,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Get USB state\n\n # Returns\n\nOne or more ::SceUdcdStatus."]
    pub fn ksceUdcdGetDeviceState() -> crate::ctypes::c_int;
    #[doc = "Get USB state for an UDCD bus\n\n # Arguments\n\n* `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\nOne or more ::SceUdcdStatus."]
    pub fn ksceUdcdGetDeviceStateInternal(bus: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Get state of a specific USB driver\n\n # Arguments\n\n* `driverName` - - name of USB driver to get status from\n\n # Returns\n\nSCE_UDCD_STATUS_DRIVER_STARTED if the driver has been started, SCE_UDCD_STATUS_DRIVER_REGISTERED if it is stopped"]
    pub fn ksceUdcdGetDrvState(driverName: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Get state of a specific USB driver for an UDCD bus\n\n # Arguments\n\n* `driverName` - - name of USB driver to get status from\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\nSCE_UDCD_STATUS_DRIVER_STARTED if the driver has been started, SCE_UDCD_STATUS_DRIVER_REGISTERED if it is stopped"]
    pub fn ksceUdcdGetDrvStateInternal(
        driverName: *const crate::ctypes::c_char,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Register a USB driver.\n\n # Arguments\n\n* `drv` - - Pointer to a filled out USB driver\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdRegister(drv: *mut SceUdcdDriver) -> crate::ctypes::c_int;
    #[doc = "Register a USB driver to a specific USB bus.\n\n # Arguments\n\n* `drv` - - Pointer to a filled out USB driver\n * `bus` - - The USB bus index (usually 2)\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdRegisterInternal(
        drv: *mut SceUdcdDriver,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Cancel any pending requests on an endpoint.\n\n # Arguments\n\n* `endp` - - The endpoint to cancel\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdReqCancelAll(endp: *mut SceUdcdEndpoint) -> crate::ctypes::c_int;
    #[doc = "Queue a receive request (OUT from host pov)\n\n # Arguments\n\n* `req` - - Pointer to a filled out ::SceUdcdDeviceRequest structure\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdReqRecv(req: *mut SceUdcdDeviceRequest) -> crate::ctypes::c_int;
    #[doc = "Queue a receive request (OUT from host pov) for an UDCD bus\n\n # Arguments\n\n* `req` - - Pointer to a filled out ::SceUdcdDeviceRequest structure\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdReqRecvInternal(
        req: *mut SceUdcdDeviceRequest,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Queue a send request (IN from host pov)\n\n # Arguments\n\n* `req` - - Pointer to a filled out ::SceUdcdDeviceRequest structure.\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdReqSend(req: *mut SceUdcdDeviceRequest) -> crate::ctypes::c_int;
    #[doc = "Queue a send request (IN from host pov) for an UDCD bus\n\n # Arguments\n\n* `req` - - Pointer to a filled out ::SceUdcdDeviceRequest structure.\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdReqSendInternal(
        req: *mut SceUdcdDeviceRequest,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Stall an endpoint\n\n # Arguments\n\n* `endp` - - The endpoint to stall\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdStall(endp: *mut SceUdcdEndpoint) -> crate::ctypes::c_int;
    #[doc = "Stall an endpoint for an UDCD bus\n\n # Arguments\n\n* `endp` - - The endpoint to stall\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdStallInternal(
        endp: *mut SceUdcdEndpoint,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Start a USB driver.\n\n # Arguments\n\n* `driverName` - - Name of the USB driver to start\n * `size` - - Size of arguments to pass to USB driver start\n * `args` - - Arguments to pass to USB driver start\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdStart(
        driverName: *const crate::ctypes::c_char,
        size: crate::ctypes::c_int,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Starts the current USB driver for an UDCD bus.\n\n # Arguments\n\n* `unused` (direction in) - - Unused\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdStartCurrentInternal(
        unused: crate::ctypes::c_int,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Start a USB driver for an UDCD bus.\n\n # Arguments\n\n* `driverName` - - Name of the USB driver to start\n * `size` - - Size of arguments to pass to USB driver start\n * `args` - - Arguments to pass to USB driver start\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdStartInternal(
        driverName: *const crate::ctypes::c_char,
        size: crate::ctypes::c_int,
        args: *mut crate::ctypes::c_void,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Stop a USB driver.\n\n # Arguments\n\n* `driverName` - - Name of the USB driver to stop\n * `size` - - Size of arguments to pass to USB driver start\n * `args` - - Arguments to pass to USB driver start\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdStop(
        driverName: *const crate::ctypes::c_char,
        size: crate::ctypes::c_int,
        args: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Stops the current USB driver for an UDCD bus.\n\n # Arguments\n\n* `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdStopCurrentInternal(bus: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Stop a USB driver for an UDCD bus.\n\n # Arguments\n\n* `driverName` - - Name of the USB driver to stop\n * `size` - - Size of arguments to pass to USB driver start\n * `args` - - Arguments to pass to USB driver start\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdStopInternal(
        driverName: *const crate::ctypes::c_char,
        size: crate::ctypes::c_int,
        args: *mut crate::ctypes::c_void,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Unregister a USB driver\n\n # Arguments\n\n* `drv` - - Pointer to a filled out USB driver\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdUnregister(drv: *mut SceUdcdDriver) -> crate::ctypes::c_int;
    #[doc = "Unregister a USB driver for an UDCD bus\n\n # Arguments\n\n* `drv` - - Pointer to a filled out USB driver\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn ksceUdcdUnregisterInternal(
        drv: *mut SceUdcdDriver,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Waits until an UDCD bus is initialized\n\n # Arguments\n\n* `timeout` (direction in) - - Timeout\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdWaitBusInitialized(
        timeout: crate::ctypes::c_uint,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for state\n\n # Arguments\n\n* `waitParam` (direction in) - - Wait parameter\n * `timeout` (direction in) - - Timeout\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdWaitState(
        waitParam: *mut SceUdcdWaitParam,
        timeout: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Wait for state for an UDCD bus\n\n # Arguments\n\n* `waitParam` (direction in) - - Wait parameter\n * `timeout` (direction in) - - Timeout\n * `bus` (direction in) - - UDCD bus (default is 2)\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn ksceUdcdWaitStateInternal(
        waitParam: *mut SceUdcdWaitParam,
        timeout: crate::ctypes::c_uint,
        bus: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceUdcd_stub", kind = "static")]
#[cfg(feature = "SceUdcd_stub")]
extern "C" {
    #[doc = "Get device information\n\n # Arguments\n\n* `devInfo` (direction out) - - Device information\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUdcdGetDeviceInfo(devInfo: *mut SceUdcdDeviceInfo) -> crate::ctypes::c_int;
    #[doc = "Get device state\n\n # Arguments\n\n* `state` (direction out) - - Device state\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUdcdGetDeviceState(state: *mut SceUdcdDeviceState) -> crate::ctypes::c_int;
    #[doc = "Get state of a specific USB driver\n\n # Arguments\n\n* `driverName` - - name of USB driver to get status from\n\n # Returns\n\nSCE_UDCD_STATUS_DRIVER_STARTED if the driver has been started, SCE_UDCD_STATUS_DRIVER_REGISTERED if it is stopped"]
    pub fn sceUdcdGetDrvState(driverName: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Register callback\n\n # Arguments\n\n* `cbid` (direction in) - - Callback UID\n * `state` (direction in) - - State\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUdcdRegisterCallback(
        cbid: SceUID,
        state: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Unregister callback\n\n # Arguments\n\n* `cbid` (direction in) - - Callback UID\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUdcdUnregisterCallback(cbid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Wait for state\n\n # Arguments\n\n* `waitParam` (direction in) - - Wait parameter\n * `timeout` (direction in) - - Timeout\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUdcdWaitState(
        waitParam: *mut SceUdcdWaitParam,
        timeout: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceUlobjMgr_stub", kind = "static")]
#[cfg(feature = "SceUlobjMgr_stub")]
extern "C" {}
#[link(name = "SceUlt_stub", kind = "static")]
#[cfg(feature = "SceUlt_stub")]
extern "C" {}
#[link(name = "SceUsbAudioForDriver_stub", kind = "static")]
#[cfg(feature = "SceUsbAudioForDriver_stub")]
extern "C" {}
#[link(name = "SceUsbAudioIn_stub", kind = "static")]
#[cfg(feature = "SceUsbAudioIn_stub")]
extern "C" {
    #[doc = "Close usb audio device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id"]
    pub fn sceUsbAudioInCloseDevice(device_id: SceUInt32) -> SceInt32;
    #[doc = "Get available audio usb devices\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `list` (direction out) - - pointer to array of SceUsbAudioInDeviceListItem\n * `device_count` (direction out) - - connected device count\n * `list_size` (direction in) - - number of items in SceUsbAudioInDeviceListItem array\n\n > **Note:** While function accepts up to 127 as list_size it can only return maximum 7 devices"]
    pub fn sceUsbAudioInGetDeviceIdList(
        list: *mut SceUsbAudioInDeviceListItem,
        device_count: *mut SceUInt32,
        list_size: SceUInt32,
    ) -> SceInt32;
    #[doc = "Get usb audio device info\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id\n * `info` (direction out) - - pointer to SceUsbAudioInDeviceInfo"]
    pub fn sceUsbAudioInGetDeviceInformation(
        device_id: SceUInt32,
        info: *mut SceUsbAudioInDeviceInfo,
    ) -> SceInt32;
    #[doc = "Get usb audio device max volume\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id\n * `volume` (direction out) - - maximum device volume\n\n > **Note:** You should sceUsbAudioInOpenDevice first to use this function"]
    pub fn sceUsbAudioInGetMaxValueOfVolume(
        device_id: SceUInt32,
        volume: *mut SceUInt32,
    ) -> SceInt32;
    #[doc = "Get usb audio device min volume\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id\n * `volume` (direction out) - - minimum device volume\n\n > **Note:** You should sceUsbAudioInOpenDevice first to use this function"]
    pub fn sceUsbAudioInGetMinValueOfVolume(
        device_id: SceUInt32,
        volume: *mut SceUInt32,
    ) -> SceInt32;
    #[doc = "Receive sound data from usb device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id\n * `buffer` (direction out) - - buffer for received data. Should be 0x600 bytes in size.\n\n > **Note:** You should call sceUsbAudioInOpenDevice first to use this function\n > **Note:** Data is in S16_MONO format. Granularity is 768 (thus buffer is 768*2)"]
    pub fn sceUsbAudioInInput(device_id: SceUInt32, buffer: *mut crate::ctypes::c_void)
        -> SceInt32;
    #[doc = "Open usb audio device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id\n * `bits` (direction in) - - Bits per sample. Only 16 allowed\n * `rate` (direction in) - - Bitrate in Hz. Only 48000 allowed"]
    pub fn sceUsbAudioInOpenDevice(
        device_id: SceUInt32,
        bits: crate::ctypes::c_int,
        rate: crate::ctypes::c_int,
    ) -> SceInt32;
    #[doc = "Set usb audio device volume\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` (direction in) - - Device id\n * `volume` (direction in) - - new device volume\n\n > **Note:** You should sceUsbAudioInOpenDevice first to use this function"]
    pub fn sceUsbAudioInSetCurrentValueOfVolume(
        device_id: SceUInt32,
        volume: SceUInt32,
    ) -> SceInt32;
}
#[link(name = "SceUsbdForDriver_stub", kind = "static")]
#[cfg(feature = "SceUsbdForDriver_stub")]
extern "C" {
    #[doc = "Transfer data to/from endpoint\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `pipe_id` - pipe id\n * `buffer` - data\n * `length` - data length\n * `cb` - transfer callback\n * `user_data` - userdata to pass to callback\n\n > **Note:** buffer pointer must be 64b aligned"]
    pub fn ksceUsbdBulkTransfer(
        pipe_id: SceUID,
        buffer: *mut crate::ctypes::c_uchar,
        length: crate::ctypes::c_uint,
        cb: ksceUsbdDoneCallback,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Transfer data to/from endpoint\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `pipe_id` - pipe id\n * `buffer` - data\n * `length` - data length\n * `cb` - transfer callback\n * `user_data` - userdata to pass to callback\n\n > **Note:** buffer pointer must be 64b aligned"]
    pub fn ksceUsbdBulkTransfer2(
        pipe_id: crate::ctypes::c_int,
        buffer: *mut crate::ctypes::c_uchar,
        length: crate::ctypes::c_uint,
        cb: ksceUsbdDoneCallback,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Close communication pipe to endpoint\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `pipe_id` - pipe id"]
    pub fn ksceUsbdClosePipe(pipe_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Transfer data to/from endpoint\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `pipe_id` - pipe id\n * `req` - transfer request\n * `buffer` - data\n * `cb` - transfer callback\n * `user_data` - userdata to pass to callback"]
    pub fn ksceUsbdControlTransfer(
        pipe_id: SceUID,
        req: *const SceUsbdDeviceRequest,
        buffer: *mut crate::ctypes::c_uchar,
        cb: ksceUsbdDoneCallback,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Get device location\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` - device id\n * `location` (direction out) - device location data (port)"]
    pub fn ksceUsbdGetDeviceLocation(device_id: SceUID, location: *mut u8) -> crate::ctypes::c_int;
    #[doc = "Get device speed\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `device_id` - device id\n * `speed` (direction out) - device speed"]
    pub fn ksceUsbdGetDeviceSpeed(
        device_id: crate::ctypes::c_int,
        speed: *mut u8,
    ) -> crate::ctypes::c_int;
    pub fn ksceUsbdHostStart(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceUsbdHostStop(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Transfer data to/from interrupt endpoint\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `pipe_id` - pipe id\n * `buffer` - data\n * `length` - data length\n * `cb` - transfer callback\n * `user_data` - userdata to pass to callback"]
    pub fn ksceUsbdInterruptTransfer(
        pipe_id: SceUID,
        buffer: *mut crate::ctypes::c_uchar,
        length: SceSize,
        cb: ksceUsbdDoneCallback,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Transfer isochronous data to/from endpoint\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `pipe_id` - pipe id\n * `transfer` - transfer request\n * `cb` - transfer callback\n * `user_data` - userdata to pass to callback"]
    pub fn ksceUsbdIsochronousTransfer(
        pipe_id: SceUID,
        transfer: *mut ksceUsbdIsochTransfer,
        cb: ksceUsbdIsochDoneCallback,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Open communication pipe to endpoint\n\n # Returns\n\npipe uid on success, < 0 on error\n\n # Arguments\n\n* `device_id` - device id\n * `endpoint` - endpoint (may be null for default configuration endpoint)"]
    pub fn ksceUsbdOpenPipe(
        device_id: crate::ctypes::c_int,
        endpoint: *mut SceUsbdEndpointDescriptor,
    ) -> SceUID;
    #[doc = "Register USB driver for composite devices\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `driver` - driver struct"]
    pub fn ksceUsbdRegisterCompositeLdd(
        driver: *const SceUsbdCompositeDriver,
    ) -> crate::ctypes::c_int;
    #[doc = "Register USB driver\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `driver` - driver struct"]
    pub fn ksceUsbdRegisterDriver(driver: *const SceUsbdDriver) -> crate::ctypes::c_int;
    pub fn ksceUsbdResume(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Return usb descriptor\n\n # Returns\n\ndescriptor data on success, NULL on error\n\n # Arguments\n\n* `device_id` - device id\n * `start` - pointer to descriptor to start scanning from (may be NULL)\n * `type` - descriptor type"]
    pub fn ksceUsbdScanStaticDescriptor(
        device_id: SceUID,
        start: *mut crate::ctypes::c_void,
        type_: SceUsbdDescriptorType,
    ) -> *mut crate::ctypes::c_void;
    pub fn ksceUsbdSuspend(port: crate::ctypes::c_int) -> crate::ctypes::c_int;
    pub fn ksceUsbdSuspendPhase2(
        port: crate::ctypes::c_int,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "De-register USB driver for composite devices\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `driver` - driver struct"]
    pub fn ksceUsbdUnregisterCompositeLdd(
        driver: *const SceUsbdCompositeDriver,
    ) -> crate::ctypes::c_int;
    #[doc = "De-register USB driver\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `driver` - driver struct"]
    pub fn ksceUsbdUnregisterDriver(driver: *const SceUsbdDriver) -> crate::ctypes::c_int;
    pub fn ksceUsbd_05073925(
        device_id: SceUID,
        unk1: *mut crate::ctypes::c_int,
        unk2: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn ksceUsbd_7938DAC7(pipe_id: SceUID) -> crate::ctypes::c_int;
}
#[link(name = "SceUsbd_stub", kind = "static")]
#[cfg(feature = "SceUsbd_stub")]
extern "C" {
    #[doc = "Attach specified driver to device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `driver_id` (direction in) - driver id (result of Register(Composite)Ldd)\n * `bus` (direction in) - usb port number\n * `device` (direction in) - usb device number\n\n > **Note:** device_id = (bus << 16) + device"]
    pub fn sceUsbdAttach(
        uid: SceUID,
        driver_id: SceUID,
        bus: SceUInt,
        device: SceUInt,
    ) -> crate::ctypes::c_int;
    #[doc = "Attach composite driver to device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `param` (direction in) - parameters"]
    pub fn sceUsbdAttachCompositeLdd(
        uid: SceUID,
        param: *mut SceUsbdAttachCompositeParam,
    ) -> crate::ctypes::c_int;
    #[doc = "Close endpoint communication pipe\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `pipe_id` (direction in) - pipe uid"]
    pub fn sceUsbdClosePipe(uid: SceUID, pipe_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Stop usb subsystem\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` - uid"]
    pub fn sceUsbdEnd(uid: SceUID) -> crate::ctypes::c_int;
    #[doc = "Get usb device descriptors (all)\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `device_id` (direction in) - device id\n * `descriptor` (direction out) - buffer for descriptor data\n * `size` (direction in) - buffer size"]
    pub fn sceUsbdGetDescriptor(
        uid: SceUID,
        device_id: SceUID,
        descriptor: *mut crate::ctypes::c_uchar,
        size: SceSize,
    ) -> crate::ctypes::c_int;
    #[doc = "Get usb device descriptors data size\n\n # Returns\n\nsize on success, < 0 on error\n\n # Arguments\n\n* `uid` - uid\n * `device_id` - device id"]
    pub fn sceUsbdGetDescriptorSize(
        uid: SceUID,
        device_id: crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Get device address\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `device_id` (direction in) - device id\n * `addr` (direction out) - buffer for return value\n\n > **Note:** it is unknown what that function actually returns in addr, observed only 0"]
    pub fn sceUsbdGetDeviceAddress(
        uid: SceUID,
        device_id: SceUID,
        addr: *mut SceUsbdDeviceAddress,
    ) -> crate::ctypes::c_int;
    #[doc = "Get usb devices list\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `num` (direction in) - max number of devices to return (8 max)\n * `info` (direction out) - pointer to receive device info"]
    pub fn sceUsbdGetDeviceList(
        uid: SceUID,
        num: SceSize,
        info: *mut SceUsbdDeviceInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "Get usb device speed\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `device_id` (direction in) - device id\n * `speed` (direction out) - device speed"]
    pub fn sceUsbdGetDeviceSpeed(
        uid: SceUID,
        device_id: SceUID,
        speed: *mut crate::ctypes::c_uint,
    ) -> crate::ctypes::c_int;
    #[doc = "Get isochronous transfer status\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `transfer_id` (direction in) - transfer uid\n * `status` (direction out) - buffer for return value\n\n > **Note:** it is unknown what that function actually returns in addr, observed only 0"]
    pub fn sceUsbdGetIsochTransferStatus(
        transfer_id: SceUID,
        status: *mut SceUsbdIsochTransferStatus,
    ) -> crate::ctypes::c_int;
    #[doc = "Get transfer status\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `transfer_id` (direction in) - transfer uid\n * `status` (direction out) - buffer for return value\n\n > **Note:** it is unknown what that function actually returns in addr, observed only 0"]
    pub fn sceUsbdGetTransferStatus(
        transfer_id: SceUID,
        status: *mut SceUsbdTransferStatus,
    ) -> crate::ctypes::c_int;
    #[doc = "Init usb subsystem\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction out) - Pointer to uid"]
    pub fn sceUsbdInit(uid: *mut SceUID) -> crate::ctypes::c_int;
    #[doc = "Transfer data to/from endpoint isochronously\n\n # Returns\n\ntransfer_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `pipe_id` (direction in) - pipe uid\n * `transfer` (direction in) - data to transfer"]
    pub fn sceUsbdIsochTransferData(
        uid: SceUID,
        pipe_id: SceUID,
        transfer: *mut SceUsbdIsochTransfer,
    ) -> crate::ctypes::c_int;
    #[doc = "Open endpoint communication pipe for default config endpoint\n\n # Returns\n\npipe_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `device_id` (direction in) - device id"]
    pub fn sceUsbdOpenDefaultPipe(uid: SceUID, device_id: SceUID) -> SceUID;
    #[doc = "Open endpoint communication pipe\n\n # Returns\n\npipe_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `pipe` (direction in) - endpoint to open"]
    pub fn sceUsbdOpenPipe(uid: SceUID, pipe: *mut SceUsbdDevicePipe) -> SceUID;
    #[doc = "Receive usb event\n\n # Returns\n\ntransfer_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `event` (direction out) -"]
    pub fn sceUsbdReceiveEvent(
        uid: SceUID,
        event: *mut SceUsbdReceiveEvent,
    ) -> crate::ctypes::c_int;
    #[doc = "Register callback to usb event\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `cbid` (direction in) - callback uid\n * `flag` (direction in) - if 1 - trigger events immediately\n\n > **Note:** there may be only one callback registered through whole system.\n And it's currently taken up by shell."]
    pub fn sceUsbdRegisterCallback(
        cbid: SceUID,
        flag: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Register logical device driver for composite devices\n\n # Returns\n\ndriver_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `name` (direction in) - driver name, 255 max"]
    pub fn sceUsbdRegisterCompositeLdd(uid: SceUID, name: *mut crate::ctypes::c_char) -> SceUID;
    #[doc = "Register logical device driver\n\n # Returns\n\ndriver_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `name` (direction in) - driver name, 255 max"]
    pub fn sceUsbdRegisterLdd(uid: SceUID, name: *mut crate::ctypes::c_char) -> SceUID;
    #[doc = "Reset usb device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `device_id` (direction in) - device id"]
    pub fn sceUsbdResetDevice(uid: SceUID, device_id: SceUID) -> crate::ctypes::c_int;
    #[doc = "Transfer data to/from endpoint\n\n # Returns\n\ntransfer_id on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `data` (direction in) - data to transfer"]
    pub fn sceUsbdTransferData(uid: SceUID, data: *mut SceUsbdTransferData) -> SceUID;
    #[doc = "Remove callback to usb event\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `cbid` (direction in) - callback uid\n\n > **Note:** this checks process id"]
    pub fn sceUsbdUnregisterCallback(cbid: SceUID) -> crate::ctypes::c_int;
    #[doc = "De-register logical device driver\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `uid` (direction in) - uid\n * `name` (direction in) - driver name, 255 max"]
    pub fn sceUsbdUnregisterLdd(
        uid: SceUID,
        name: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceUsbPspcm_stub", kind = "static")]
#[cfg(feature = "SceUsbPspcm_stub")]
extern "C" {}
#[link(name = "SceUsbSerialForDriver_stub", kind = "static")]
#[cfg(feature = "SceUsbSerialForDriver_stub")]
extern "C" {
    #[doc = "Close USB serial device"]
    pub fn ksceUsbSerialClose() -> crate::ctypes::c_int;
    #[doc = "Get receive buffer length\n\n # Returns\n\nReturns length of USB rx buffer"]
    pub fn ksceUsbSerialGetRecvBufferSize() -> crate::ctypes::c_uint;
    #[doc = "Receive Data\n\n # Arguments\n\n* `*buffer` (direction out) - buffer for incoming data\n * `max_len` (direction in) - max data length to receive\n * `unk1` - Unknown\n * `unk2` - Unknown\n > **Note:** max recv length is 0x10000"]
    pub fn ksceUsbSerialRecv(
        buffer: *mut crate::ctypes::c_void,
        max_len: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: crate::ctypes::c_int,
    ) -> SceSize;
    #[doc = "Send data\n\n # Arguments\n\n* `*buffer` (direction in) - data to send over usb\n * `len` (direction in) - int len of serial buffer data\n * `unk1` - Unknown\n * `unk2` - Unknown\n > **Note:** max send length is 0x10000"]
    pub fn ksceUsbSerialSend(
        buffer: *const crate::ctypes::c_void,
        len: SceSize,
        unk1: crate::ctypes::c_int,
        unk2: crate::ctypes::c_int,
    ) -> SceSize;
    #[doc = "Setup USB serial device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `unk` - Unknown"]
    pub fn ksceUsbSerialSetup(unk: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Activate USB serial device\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** The user is responsible for making sure no other UDC driver is active. This activates UDC as a \"PS Vita\" Type D device."]
    pub fn ksceUsbSerialStart() -> crate::ctypes::c_int;
    #[doc = "Get USB device status\n\n # Returns\n\nReturns 1 when serial port is open"]
    pub fn ksceUsbSerialStatus() -> crate::ctypes::c_int;
}
#[link(name = "SceUsbSerial_stub", kind = "static")]
#[cfg(feature = "SceUsbSerial_stub")]
extern "C" {
    #[doc = "Close USB serial device\n\n > **Note:** Wrapper for kernel function sceUsbSerialCloseForDriver()"]
    pub fn sceUsbSerialClose() -> crate::ctypes::c_int;
    #[doc = "Get receive buffer length\n\n # Returns\n\nReturns length of USB rx buffer\n\n > **Note:** Wrapper for kernel function sceUsbSerialGetLenForDriver()"]
    pub fn sceUsbSerialGetRecvBufferSize() -> crate::ctypes::c_uint;
    #[doc = "Receive Data\n\n # Arguments\n\n* `*buffer` (direction out) - buffer for incoming data\n * `max_len` - max data length to receive\n * `unk1` - Unknown\n * `unk2` - Unknown\n > **Note:** max recv length is 0x10000\n > **Note:** Wrapper for kernel function sceUsbSerialRecvForDriver()"]
    pub fn sceUsbSerialRecv(
        buffer: *mut crate::ctypes::c_void,
        max_len: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: crate::ctypes::c_int,
    ) -> crate::ctypes::c_uint;
    #[doc = "Send data\n # Arguments\n\n* `*buffer` (direction in) - data to send over usb\n * `len` - int len of serial buffer data\n * `unk1` - Unknown\n * `unk2` - Unknown\n > **Note:** max send length is 0x10000\n > **Note:** Wrapper for kernel function sceUsbSerialSendForDriver()"]
    pub fn sceUsbSerialSend(
        buffer: *const crate::ctypes::c_void,
        len: crate::ctypes::c_uint,
        unk1: crate::ctypes::c_int,
        unk2: crate::ctypes::c_int,
    ) -> crate::ctypes::c_uint;
    #[doc = "Setup USB serial device\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `unk` - Unknown\n\n > **Note:** Wrapper for kernel function sceUsbSerialSetupForDriver()"]
    pub fn sceUsbSerialSetup(unk: crate::ctypes::c_int) -> crate::ctypes::c_int;
    #[doc = "Activate USB serial device\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** The user is responsible for making sure no other UDC driver is active. This activates UDC as a \"PS Vita\" Type D device.\n\n > **Note:** Wrapper for kernel function sceUsbSerialStartForDriver()"]
    pub fn sceUsbSerialStart() -> crate::ctypes::c_int;
    #[doc = "Close USB serial device\n\n # Returns\n\nReturns 1 when serial port is open\n\n > **Note:** Wrapper for kernel function sceUsbSerialStatusForDriver()"]
    pub fn sceUsbSerialStatus() -> crate::ctypes::c_int;
}
#[link(name = "SceUsbServForDriver_stub", kind = "static")]
#[cfg(feature = "SceUsbServForDriver_stub")]
extern "C" {
    #[doc = "Enable accessory port\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** NID 0xAA6D4409"]
    pub fn ksceUsbServAccessoryActivate() -> crate::ctypes::c_int;
    #[doc = "Disable accessory port\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** NID 0x853CB8E4"]
    pub fn ksceUsbServAccessoryDeactivate() -> crate::ctypes::c_int;
    #[doc = "Prevent PSTV ethernet hibernation\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** NID 0x6D738018, guessed name"]
    pub fn ksceUsbServDisableEtherSuspend() -> crate::ctypes::c_int;
    #[doc = "Disable PSTV ethernet\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** NID 0xD787B191"]
    pub fn ksceUsbServEtherDisable() -> crate::ctypes::c_int;
    #[doc = "Enable PSTV ethernet\n\n # Returns\n\n0 on success, < 0 on error\n\n > **Note:** NID 0x30AE5F66"]
    pub fn ksceUsbServEtherEnable() -> crate::ctypes::c_int;
    #[doc = "Get USB port mode\n\n # Returns\n\nusb port mode (1 = client, 0 = host)\n\n # Arguments\n\n* `usbPort` - usb port number (0,1,2)\n\n > **Note:** NID 0xF0553A69"]
    pub fn ksceUsbServMacGet(usbPort: SceUInt) -> SceBool;
    #[doc = "Set USB port mode\n\n # Returns\n\n0 on success, < 0 on error\n\n # Arguments\n\n* `usbPort` - usb port number (0,1,2)\n * `clientMode` - 0 = host mode, 1 = client mode\n\n > **Note:** NID 0x7AD36284"]
    pub fn ksceUsbServMacSelect(usbPort: SceUInt, clientMode: SceBool) -> crate::ctypes::c_int;
}
#[link(name = "SceUsbServ_stub", kind = "static")]
#[cfg(feature = "SceUsbServ_stub")]
extern "C" {
    #[doc = "Enable accessory port\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceUsbServAccessoryActivate() -> crate::ctypes::c_int;
    #[doc = "Disable accessory port\n\n # Returns\n\n0 on success, < 0 on error"]
    pub fn sceUsbServAccessoryDeactivate() -> crate::ctypes::c_int;
}
#[link(name = "SceUsbstorVStorDriver_stub", kind = "static")]
#[cfg(feature = "SceUsbstorVStorDriver_stub")]
extern "C" {
    #[doc = "Set USB descriptor device information\n\n # Arguments\n\n* `name` (direction in) - - Name\n * `version` (direction in) - - Version\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUsbstorVStorSetDeviceInfo(
        name: *const crate::ctypes::c_char,
        version: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Set image file path\n\n # Arguments\n\n* `path` (direction in) - - Image file path\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUsbstorVStorSetImgFilePath(
        path: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Start USB virtual storage\n\n # Arguments\n\n* `type` (direction in) - - One of ::SceUsbstorVstorType\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUsbstorVStorStart(type_: SceUsbstorVstorType) -> crate::ctypes::c_int;
    #[doc = "Stop USB virtual storage\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceUsbstorVStorStop() -> crate::ctypes::c_int;
}
#[link(name = "SceVideodec_stub", kind = "static")]
#[cfg(feature = "SceVideodec_stub")]
extern "C" {
    #[doc = "# Arguments\n\n* `codec` (direction in) - - See ::SceVideodecType\n * `decoder` (direction out) - - Must be initialized frameBuf.size and frameBuf.pBuf\n * `query` (direction in) - - Should be copy from ::SceVideodecQueryInitInfoHwAvcdec.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvcdecCreateDecoder(
        codec: SceVideodecType,
        decoder: *mut SceAvcdecCtrl,
        query: *const SceAvcdecQueryDecoderInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `decoder` (direction in) -\n * `au` (direction in) - - Must set buffer information(es) and be initialized timestamps with 0xFFFFFFFF\n * `array_picture` (direction out) - - Must set numOfElm and pPicture. See ::SceAvcdecArrayPicture\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvcdecDecode(
        decoder: *const SceAvcdecCtrl,
        au: *const SceAvcdecAu,
        array_picture: *mut SceAvcdecArrayPicture,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `decoder` (direction in) - - A ::SceAvcdecCtrl decoder initialized with ::sceAvcdecCreateDecoder\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvcdecDeleteDecoder(decoder: *mut SceAvcdecCtrl) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `codec` (direction in) - - See ::SceVideodecType\n * `query` (direction in) - - Should be copy from ::SceVideodecQueryInitInfoHwAvcdec.\n * `decoderInfo` (direction out) - - Must be initialized with zeros.\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceAvcdecQueryDecoderMemSize(
        codec: SceVideodecType,
        query: *const SceAvcdecQueryDecoderInfo,
        decoderInfo: *mut SceAvcdecDecoderInfo,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `codec` (direction in) - - See ::SceVideodecType\n * `initInfo` (direction in) - - See ::SceVideodecQueryInitInfoHwAvcdec\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceVideodecInitLibrary(
        codec: SceVideodecType,
        initInfo: *const SceVideodecQueryInitInfoHwAvcdec,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `codec` (direction in) - - See ::SceVideodecType\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceVideodecTermLibrary(codec: SceVideodecType) -> crate::ctypes::c_int;
}
#[link(name = "SceVideoExport_stub", kind = "static")]
#[cfg(feature = "SceVideoExport_stub")]
extern "C" {
    #[doc = "Export video file\n\n # Arguments\n\n* `in_param` (direction in) - - Input param\n * `unk` (direction in) - - Unknown, pass 1\n * `workingMemory` (direction in) - - Working memory\n * `cancelCb` (direction in) - - Cancel callback\n * `progress` (direction in) - - Progress callback\n * `user` (direction in) - - User data passed to the callbacks\n * `unk2` (direction in) - - Unknown, pass 0\n * `out_param` (direction out) - - Output param\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn sceVideoExportFromFile(
        in_param: *const VideoExportInputParam,
        unk: crate::ctypes::c_int,
        workingMemory: *mut crate::ctypes::c_void,
        cancelCb: *mut crate::ctypes::c_void,
        progress: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void, arg2: crate::ctypes::c_int),
        >,
        user: *mut crate::ctypes::c_void,
        unk2: crate::ctypes::c_int,
        out_param: *mut VideoExportOutputParam,
    ) -> crate::ctypes::c_int;
}
#[link(name = "SceVoiceQoS_stub", kind = "static")]
#[cfg(feature = "SceVoiceQoS_stub")]
extern "C" {}
#[link(name = "SceVoice_stub", kind = "static")]
#[cfg(feature = "SceVoice_stub")]
extern "C" {}
#[link(name = "SceVshBridge_stub", kind = "static")]
#[cfg(feature = "SceVshBridge_stub")]
extern "C" {
    #[doc = "# Arguments\n\n* `id` (direction in) - - mount id\n * `path` (direction in) - - mount path\n * `permission` (direction in) - - 1/RO 2/RW\n * `buf` (direction in) - - work buffer\n\n # Returns\n\n0 >= on success, < 0 on error."]
    pub fn _vshIoMount(
        id: crate::ctypes::c_int,
        path: *const crate::ctypes::c_char,
        permission: crate::ctypes::c_int,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Check if a module is loaded.\n\n # Arguments\n\n* `module_name` (direction in) - - The module's name\n * `buffer` (direction in) - - Set a buffer with a size of 8 bytes\n\n # Returns\n\nthe SceUID of the module on success, < 0 on error."]
    pub fn _vshKernelSearchModuleByName(
        module_name: *const crate::ctypes::c_char,
        buffer: *const crate::ctypes::c_void,
    ) -> SceUID;
    #[doc = "Convert an older 0x100 byte eboot.pbp signature \"__sce_ebootpbp\" to a 0x200 byte one used in firmwares >2.00\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `old_eboot_signature` (direction in) - - The pointer of old eboot signature data. size is 0x100\n * `new_eboot_signature` (direction out) - - The pointer of new eboot signature data. size is 0x200\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn _vshNpDrmEbootSigConvert(
        eboot_pbp_path: *const crate::ctypes::c_char,
        old_eboot_signature: *const crate::ctypes::c_void,
        new_eboot_signature: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate eboot.pbp signature \"__sce_discinfo\" for a multi-disc PS1 game\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `sce_discinfo` (direction in) - - The pointer of contents of vs0:/app/NPXS10028/__sce_discinfo\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x100\n * `sw_version` (direction in) - - The pointer of the minimum firmware version the signature can be used on. cannot be lower than current firmware\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn _vshNpDrmEbootSigGenMultiDisc(
        eboot_pbp_path: *const crate::ctypes::c_char,
        sce_discinfo: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
        sw_version: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate eboot.pbp signature \"__sce_ebootpbp\" for a single-disc PS1 game\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_sha256` (direction in) - - The pointer of SHA256 hash of first (data.psar offset + 0x1C0000) bytes into the EBOOT.PBP file\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x200\n * `sw_version` (direction in) - - The pointer of the minimum firmware version the signature can be used on. cannot be lower than current firmware\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn _vshNpDrmEbootSigGenPs1(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_sha256: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
        sw_version: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate eboot.pbp signature \"__sce_ebootpbp\" for a PSP game\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_sha256` (direction in) - - The pointer of SHA256 hash of first (data.psar offset + 0x1C0000) bytes into the EBOOT.PBP file\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x200\n * `sw_version` (direction in) - - The pointer of the minimum firmware version the signature can be used on. cannot be lower than current firmware\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn _vshNpDrmEbootSigGenPsp(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_sha256: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
        sw_version: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    #[doc = "Verify a eboot.pbp signature \"__sce_ebootpbp\"\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_signature` (direction in) - - The pointer of data of __sce_ebootpbp signature. size is 0x200\n * `eboot_signature_magic` (direction in) - - The pointer of a pointer of magic number within __sce_ebootpbp, \"NPUMDSIG\" or \"PSISOSIG\"\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _vshNpDrmEbootSigVerify(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_signature: *const crate::ctypes::c_char,
        eboot_signature_header: *mut *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    #[doc = "Generate an older 0x100 byte eboot.pbp signature \"__sce_ebootpbp\" for a PSP game - this is unused in firmware >2.00\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_sha256` (direction in) - - The pointer of SHA256 hash of first (data.psar offset + 0x1C0000) bytes into the EBOOT.PBP file\n * `eboot_signature` (direction out) - - The pointer of the output eboot signature data. size is 0x100\n\n # Returns\n\neboot_signature size on success, < 0 on error."]
    pub fn _vshNpDrmPspEbootSigGen(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_sha256: *const crate::ctypes::c_void,
        eboot_signature: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "Verify an older 0x100 byte eboot.pbp signature \"__sce_ebootpbp\" from firmware <2.00\n\n # Arguments\n\n* `eboot_pbp_path` (direction in) - - The pointer of the file path of the EBOOT.PBP file\n * `eboot_signature` (direction in) - - The pointer of data of __sce_ebootpbp signature. size is 0x100\n * `eboot_signature_magic` (direction in) - - The pointer of a pointer of magic number within __sce_ebootpbp, \"NPUMDSIG\" or \"PSISOSIG\"\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _vshNpDrmPspEbootVerify(
        eboot_pbp_path: *const crate::ctypes::c_char,
        eboot_signature: *const crate::ctypes::c_char,
        eboot_signature_header: *mut *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
    pub fn _vshSblAimgrGetConsoleId(CID: *mut crate::ctypes::c_char) -> crate::ctypes::c_int;
    #[doc = "Get service/manufacturing information (factory/minimum firmware).\n\n # Arguments\n\n* `info` (direction out) - - The info output pointer\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn _vshSblAimgrGetSMI(info: *mut SceUInt32) -> crate::ctypes::c_int;
    #[doc = "Gets real system firmware information.\n\n # Arguments\n\n* `data` (direction out) - - firmware information."]
    pub fn _vshSblGetSystemSwVersion(data: *mut SceKernelFwInfo) -> crate::ctypes::c_int;
    pub fn vshIdStorageIsDirty() -> crate::ctypes::c_int;
    pub fn vshIdStorageIsFormatted() -> crate::ctypes::c_int;
    pub fn vshIdStorageIsReadOnly() -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `leafnum` (direction in) - - The read target leaf number\n * `buf` (direction out) - - The leaf data buffer pointer, size is 512 byte\n\n # Returns\n\n0 on success, < 0 on error."]
    pub fn vshIdStorageReadLeaf(
        leafnum: SceSize,
        buf: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `leafnum` (direction in) - - The write target leaf number\n * `buf` (direction in) - - The leaf data buffer pointer, size is 512 byte\n\n # Returns\n\n0 on success, < 0 on error.\n\n note - Writing to leaf requires manufacturing mode."]
    pub fn vshIdStorageWriteLeaf(
        leafnum: SceSize,
        buf: *const crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
    #[doc = "# Arguments\n\n* `id` (direction in) - - mount id\n * `force` (direction in) - - Set to 1 to force umount\n * `unk2` (direction in) - - Unknown, set 0\n * `unk3` (direction in) - - Unknown, set 0\n\n # Returns\n\n0 >= on success, < 0 on error."]
    pub fn vshIoUmount(
        id: crate::ctypes::c_int,
        force: crate::ctypes::c_int,
        unk2: crate::ctypes::c_int,
        unk3: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
    pub fn vshMemoryCardGetCardInsertState() -> crate::ctypes::c_int;
    pub fn vshMsifGetMsInfo(info: *mut SceMsInfo) -> crate::ctypes::c_int;
    pub fn vshRemovableMemoryGetCardInsertState() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsCEX() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsDEX() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsDolce() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsGenuineDolce() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsGenuineVITA() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsTest() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsTool() -> crate::ctypes::c_int;
    pub fn vshSblAimgrIsVITA() -> crate::ctypes::c_int;
    pub fn vshSblSsIsDevelopmentMode() -> crate::ctypes::c_int;
    pub fn vshSysconHasWWAN() -> crate::ctypes::c_int;
    pub fn vshSysconIduModeClear() -> crate::ctypes::c_int;
    pub fn vshSysconIduModeSet() -> crate::ctypes::c_int;
    pub fn vshSysconIsDownLoaderMode() -> crate::ctypes::c_int;
    pub fn vshSysconIsIduMode() -> crate::ctypes::c_int;
    pub fn vshSysconIsMCEmuCapable() -> crate::ctypes::c_int;
    pub fn vshSysconIsShowMode() -> crate::ctypes::c_int;
    pub fn vshSysconShowModeClear() -> crate::ctypes::c_int;
    pub fn vshSysconShowModeSet() -> crate::ctypes::c_int;
}
#[link(name = "SceWlanBtForDriver_stub", kind = "static")]
#[cfg(feature = "SceWlanBtForDriver_stub")]
extern "C" {}
#[link(name = "SceWlanBt_stub", kind = "static")]
#[cfg(feature = "SceWlanBt_stub")]
extern "C" {}
#[link(name = "vitasdk-utils", kind = "static")]
#[cfg(feature = "vitasdk-utils")]
extern "C" {
    #[doc = "vitasdk_delete_thread_reent delete the internal reent data for the specified thread\n # Arguments\n\n* `thid` - - The UID for the thread to delete reent data\n # Returns\n\nnon-zero if reent data is deleted"]
    pub fn vitasdk_delete_thread_reent(thid: SceUID) -> crate::ctypes::c_int;
    #[doc = "vitasdk_get_pthread_data - Get pointer to memory to store pthread metadata\n # Arguments\n\n* `thid` - - The thread UID where the TLS will be based on\n # Returns\n\nA pointer to a memory location within the TLS"]
    pub fn vitasdk_get_pthread_data(thid: SceUID) -> *mut crate::ctypes::c_void;
    #[doc = "vitasdk_get_tls_data - Get pointer to memory location to store TLS data\n # Arguments\n\n* `thid` - - The thread UID to access TLS\n # Returns\n\nA pointer to a memory location containing the pointer to TLS data"]
    pub fn vitasdk_get_tls_data(thid: SceUID) -> *mut crate::ctypes::c_void;
}
#[doc = "Structure representing all ARM registers"]
pub type ArmCpuRegisters = SceArmCpuRegisters;
pub type __gnuc_va_list = u32;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type int_fast8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type int_least8_t = i8;
pub type intmax_t = crate::ctypes::c_longlong;
pub type ksceUsbdDoneCallback = ::core::option::Option<
    unsafe extern "C" fn(result: i32, count: i32, arg: *mut crate::ctypes::c_void),
>;
pub type ksceUsbdIsochDoneCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: i32,
        req: *mut ksceUsbdIsochTransfer,
        arg: *mut crate::ctypes::c_void,
    ),
>;
pub type SceAppMgrApplicationMode = crate::ctypes::c_uint;
pub type SceAppMgrErrorCode = crate::ctypes::c_uint;
pub type SceAppMgrInfoBarColor = crate::ctypes::c_uint;
pub type SceAppMgrInfoBarTransparency = crate::ctypes::c_uint;
pub type SceAppMgrInfoBarVisibility = crate::ctypes::c_uint;
pub type SceAppMgrSystemEventType = crate::ctypes::c_uint;
pub type SceAppUtilAppEventType = crate::ctypes::c_uint;
pub type SceAppUtilAppParamId = crate::ctypes::c_uint;
pub type SceAppUtilBgdlStatusType = crate::ctypes::c_uint;
pub type SceAppUtilBootAttribute = crate::ctypes::c_uint;
pub type SceAppUtilErrorCode = crate::ctypes::c_uint;
pub type SceAppUtilSaveDataRemoveMode = crate::ctypes::c_uint;
pub type SceAppUtilSaveDataSaveMode = crate::ctypes::c_uint;
pub type SceAppUtilSaveDataSlotId = crate::ctypes::c_uint;
pub type SceAppUtilSaveDataSlotStatus = crate::ctypes::c_uint;
pub type SceAtracDecoderStatus = crate::ctypes::c_uint;
pub type SceAtracErrorCode = crate::ctypes::c_uint;
pub type SceAtracLoopStatus = crate::ctypes::c_uint;
pub type SceAudiodecCelpBitrate = crate::ctypes::c_uint;
pub type SceAudiodecErrorCode = crate::ctypes::c_uint;
pub type SceAudiodecMpegVersion = crate::ctypes::c_uint;
pub type SceAudiodecType = crate::ctypes::c_uint;
pub type SceAudioencCelpBitrate = crate::ctypes::c_uint;
pub type SceAudioencCelpErrorCode = crate::ctypes::c_uint;
pub type SceAudioencErrorCode = crate::ctypes::c_uint;
pub type SceAudioInErrorCode = crate::ctypes::c_uint;
pub type SceAudioInParam = crate::ctypes::c_uint;
pub type SceAudioInPortType = crate::ctypes::c_uint;
#[doc = "Argument 'mode' to specify to ::sceAudioOutSetAlcMode"]
pub type SceAudioOutAlcMode = crate::ctypes::c_uint;
#[doc = "Flags to use as 'ch' argument for ::sceAudioOutSetVolume"]
pub type SceAudioOutChannelFlag = crate::ctypes::c_uint;
#[doc = "Config type values to specify to ::sceAudioOutGetConfig"]
pub type SceAudioOutConfigType = crate::ctypes::c_uint;
pub type SceAudioOutErrorCode = crate::ctypes::c_uint;
pub type SceAudioOutMode = crate::ctypes::c_uint;
pub type SceAudioOutParam = crate::ctypes::c_uint;
pub type SceAudioOutPortType = crate::ctypes::c_uint;
pub type SceAvcdecErrorCode = crate::ctypes::c_uint;
pub type SceAvcdecPixelFormat = crate::ctypes::c_uint;
#[doc = "Color Space Mode values to specify to ::sceAVConfigSetDisplayColorSpaceMode"]
pub type SceAVConfigColorSpaceMode = crate::ctypes::c_uint;
pub type SceAvPlayerAlloc = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut crate::ctypes::c_void,
        alignment: u32,
        size: u32,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceAvPlayerAllocFrame = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut crate::ctypes::c_void,
        alignment: u32,
        size: u32,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceAvPlayerCloseFile = ::core::option::Option<
    unsafe extern "C" fn(p: *mut crate::ctypes::c_void) -> crate::ctypes::c_int,
>;
pub type SceAvPlayerErrorCode = crate::ctypes::c_uint;
pub type SceAvPlayerEventCallback = ::core::option::Option<
    unsafe extern "C" fn(
        p: *mut crate::ctypes::c_void,
        argEventId: i32,
        argSourceId: i32,
        argEventData: *mut crate::ctypes::c_void,
    ),
>;
pub type SceAvPlayerFree = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut crate::ctypes::c_void, ptr: *mut crate::ctypes::c_void),
>;
pub type SceAvPlayerFreeFrame = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut crate::ctypes::c_void, ptr: *mut crate::ctypes::c_void),
>;
pub type SceAvPlayerHandle = crate::ctypes::c_int;
pub type SceAvPlayerOpenFile = ::core::option::Option<
    unsafe extern "C" fn(
        p: *mut crate::ctypes::c_void,
        filename: *const crate::ctypes::c_char,
    ) -> crate::ctypes::c_int,
>;
pub type SceAvPlayerReadOffsetFile = ::core::option::Option<
    unsafe extern "C" fn(
        p: *mut crate::ctypes::c_void,
        buffer: *mut u8,
        position: u64,
        length: u32,
    ) -> crate::ctypes::c_int,
>;
pub type SceAvPlayerSizeFile =
    ::core::option::Option<unsafe extern "C" fn(p: *mut crate::ctypes::c_void) -> u64>;
pub type SceAvPlayerStreamType = crate::ctypes::c_uint;
pub type SceAvPlayerTrickSpeeds = crate::ctypes::c_int;
#[doc = "Error Codes"]
pub type SceBgAppUtilErrorCode = crate::ctypes::c_uint;
pub type SceBool = crate::ctypes::c_int;
pub type SceBtCallback = ::core::option::Option<
    unsafe extern "C" fn(
        r0: crate::ctypes::c_int,
        r1: crate::ctypes::c_int,
        r2: crate::ctypes::c_int,
        r3: crate::ctypes::c_int,
    ),
>;
pub type SceBtErrorCode = crate::ctypes::c_uint;
pub type SceBtHidRequest = _SceBtHidRequest;
pub type SceByte = crate::ctypes::c_uchar;
pub type SceByte8 = crate::ctypes::c_uchar;
#[doc = "Enumeration for the camera anti-flickering modes."]
pub type SceCameraAntiFlicker = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera backlight modes."]
pub type SceCameraBacklight = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera device types."]
pub type SceCameraDevice = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera effects."]
pub type SceCameraEffect = crate::ctypes::c_uint;
#[doc = "Camera error codes."]
pub type SceCameraErrorCode = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera exposure compensations."]
pub type SceCameraExposureCompensation = crate::ctypes::c_int;
#[doc = "Enumeration for the camera output formats."]
pub type SceCameraFormat = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera framerates."]
pub type SceCameraFrameRate = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera gain modes."]
pub type SceCameraGain = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera ISO speed modes."]
pub type SceCameraISO = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera nightmode modes."]
pub type SceCameraNightmode = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera process priorities."]
pub type SceCameraPriority = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera resolutions."]
pub type SceCameraResolution = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera reverse modes."]
pub type SceCameraReverse = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera saturations."]
pub type SceCameraSaturation = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera sharpnesses."]
pub type SceCameraSharpness = crate::ctypes::c_uint;
#[doc = "Enumeration for the camera white balance modes."]
pub type SceCameraWhiteBalance = crate::ctypes::c_uint;
pub type SceChar8 = i8;
pub type SceClassCallback = ::core::option::Option<
    unsafe extern "C" fn(item: *mut crate::ctypes::c_void) -> crate::ctypes::c_int,
>;
#[doc = "A handle for a managed memory space."]
pub type SceClibMspace = *mut crate::ctypes::c_void;
pub type SceCommonDialogBgColor = SceCommonDialogColor;
pub type SceCommonDialogErrorCode = crate::ctypes::c_uint;
pub type SceCommonDialogResult = crate::ctypes::c_uint;
pub type SceCommonDialogStatus = crate::ctypes::c_uint;
pub type SceCompatCacheMode = crate::ctypes::c_uint;
pub type SceCompatPeripheralMode = crate::ctypes::c_uint;
pub type SceCreateUidObjOpt = SceGUIDKernelCreateOpt;
#[doc = "Enumeration for the digital controller buttons.\n > **Note:** - L1/R1/L3/R3 only can bind using ::sceCtrlPeekBufferPositiveExt2 and ::sceCtrlReadBufferPositiveExt2\n > **Note:** - Values bigger than 0x00010000 can be intercepted only with shell privileges\n > **Note:** - Vita's L Trigger and R Trigger are mapped to L1 and R1 when using ::sceCtrlPeekBufferPositiveExt2 and ::sceCtrlReadBufferPositiveExt2"]
pub type SceCtrlButtons = crate::ctypes::c_uint;
pub type SceCtrlErrorCode = crate::ctypes::c_uint;
#[doc = "Enumeration for the controller types."]
pub type SceCtrlExternalInputMode = crate::ctypes::c_uint;
#[doc = "Controller mode."]
pub type SceCtrlPadInputMode = crate::ctypes::c_uint;
pub type SceCTypeFlag = crate::ctypes::c_uint;
#[doc = "Logging level for sceDbgLoggingHandler."]
pub type SceDbgLogLevel = crate::ctypes::c_uint;
pub type SceDisplayErrorCode = crate::ctypes::c_uint;
pub type SceDisplayPixelFormat = crate::ctypes::c_uint;
pub type SceDisplaySetBufSync = crate::ctypes::c_uint;
pub type SceDouble = f64;
pub type SceDouble64 = f64;
pub type SceDsiErrorCode = crate::ctypes::c_uint;
pub type SceDsiHead = crate::ctypes::c_uint;
#[doc = "Event flag creation attributes"]
pub type SceEventFlagAttributes = crate::ctypes::c_uint;
#[doc = "Event flag wait types"]
pub type SceEventFlagWaitTypes = crate::ctypes::c_uint;
pub type SceExcpHandlingCode = crate::ctypes::c_uint;
pub type SceExcpKind = crate::ctypes::c_uint;
pub type SceExcpmgrExceptionHandler = ::core::option::Option<
    unsafe extern "C" fn(context: *mut SceExcpmgrExceptionContext, code: SceExcpHandlingCode),
>;
pub type SceFiberEntry =
    ::core::option::Option<unsafe extern "C" fn(argOnInitialize: SceUInt32, argOnRun: SceUInt32)>;
pub type SceFiberErrorCode = crate::ctypes::c_uint;
pub type SceFiosKernelOverlayDH = i32;
pub type SceFiosKernelOverlayID = i32;
pub type SceFiosOverlayID = i32;
pub type SceFiosOverlayType = crate::ctypes::c_uint;
pub type SceFloat = f32;
pub type SceFloat32 = f32;
pub type SceFontErrorCode = crate::ctypes::c_uint;
pub type SceFontFamilyCode = crate::ctypes::c_uint;
pub type SceFontHandle = *mut crate::ctypes::c_void;
pub type SceFontLanguageCode = crate::ctypes::c_uint;
pub type SceFontLibHandle = *mut crate::ctypes::c_void;
pub type SceFontPixelFormatCode = crate::ctypes::c_uint;
pub type SceFontStyleCode = crate::ctypes::c_uint;
pub type SceGpioErrorCode = crate::ctypes::c_uint;
pub type SceGpioPortMasks = crate::ctypes::c_uint;
pub type SceGpioPortMode = crate::ctypes::c_uint;
pub type SceGxmAttributeFormat = crate::ctypes::c_uint;
pub type SceGxmBlendFactor = crate::ctypes::c_uint;
pub type SceGxmBlendFunc = crate::ctypes::c_uint;
pub type SceGxmColorBaseFormat = crate::ctypes::c_uint;
#[doc = "Supported color formats"]
pub type SceGxmColorFormat = crate::ctypes::c_uint;
pub type SceGxmColorMask = crate::ctypes::c_uint;
pub type SceGxmColorSurfaceDitherMode = crate::ctypes::c_uint;
pub type SceGxmColorSurfaceGammaMode = crate::ctypes::c_uint;
pub type SceGxmColorSurfaceScaleMode = crate::ctypes::c_uint;
pub type SceGxmColorSurfaceType = crate::ctypes::c_uint;
pub type SceGxmColorSwizzle1Mode = crate::ctypes::c_uint;
pub type SceGxmColorSwizzle2Mode = crate::ctypes::c_uint;
pub type SceGxmColorSwizzle3Mode = crate::ctypes::c_uint;
pub type SceGxmColorSwizzle4Mode = crate::ctypes::c_uint;
pub type SceGxmCullMode = crate::ctypes::c_uint;
pub type SceGxmDepthFunc = crate::ctypes::c_uint;
pub type SceGxmDepthStencilForceLoadMode = crate::ctypes::c_uint;
pub type SceGxmDepthStencilForceStoreMode = crate::ctypes::c_uint;
pub type SceGxmDepthStencilFormat = crate::ctypes::c_uint;
pub type SceGxmDepthStencilSurfaceType = crate::ctypes::c_uint;
pub type SceGxmDepthWriteMode = crate::ctypes::c_uint;
pub type SceGxmDisplayQueueCallback =
    ::core::option::Option<unsafe extern "C" fn(callbackData: *const crate::ctypes::c_void)>;
pub type SceGxmEdgeEnableFlags = crate::ctypes::c_uint;
pub type SceGxmErrorCode = crate::ctypes::c_uint;
pub type SceGxmFragmentProgramMode = crate::ctypes::c_uint;
pub type SceGxmIndexFormat = crate::ctypes::c_uint;
pub type SceGxmIndexSource = crate::ctypes::c_uint;
pub type SceGxmLineFillLastPixelMode = crate::ctypes::c_uint;
pub type SceGxmMemoryAttribFlags = crate::ctypes::c_uint;
pub type SceGxmMidSceneFlags = crate::ctypes::c_uint;
pub type SceGxmMultisampleMode = crate::ctypes::c_uint;
pub type SceGxmOutputRegisterFormat = crate::ctypes::c_uint;
pub type SceGxmOutputRegisterSize = crate::ctypes::c_uint;
pub type SceGxmParameterCategory = crate::ctypes::c_uint;
pub type SceGxmParameterSemantic = crate::ctypes::c_uint;
pub type SceGxmParameterType = crate::ctypes::c_uint;
pub type SceGxmPassType = crate::ctypes::c_uint;
pub type SceGxmPolygonMode = crate::ctypes::c_uint;
pub type SceGxmPrecomputedWordCount = crate::ctypes::c_uint;
pub type SceGxmPrimitiveType = crate::ctypes::c_uint;
pub type SceGxmProgramType = crate::ctypes::c_uint;
pub type SceGxmRegionClipMode = crate::ctypes::c_uint;
pub type SceGxmRenderTargetFlags = crate::ctypes::c_uint;
pub type SceGxmSceneFlags = crate::ctypes::c_uint;
pub type SceGxmShaderPatcherBufferAllocCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userData: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceGxmShaderPatcherBufferFreeCallback = ::core::option::Option<
    unsafe extern "C" fn(userData: *mut crate::ctypes::c_void, mem: *mut crate::ctypes::c_void),
>;
pub type SceGxmShaderPatcherHostAllocCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userData: *mut crate::ctypes::c_void,
        size: SceSize,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceGxmShaderPatcherHostFreeCallback = ::core::option::Option<
    unsafe extern "C" fn(userData: *mut crate::ctypes::c_void, mem: *mut crate::ctypes::c_void),
>;
pub type SceGxmShaderPatcherId = *mut SceGxmRegisteredProgram;
pub type SceGxmShaderPatcherUsseAllocCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userData: *mut crate::ctypes::c_void,
        size: SceSize,
        usseOffset: *mut crate::ctypes::c_uint,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceGxmShaderPatcherUsseFreeCallback = ::core::option::Option<
    unsafe extern "C" fn(userData: *mut crate::ctypes::c_void, mem: *mut crate::ctypes::c_void),
>;
pub type SceGxmStencilFunc = crate::ctypes::c_uint;
pub type SceGxmStencilOp = crate::ctypes::c_uint;
pub type SceGxmTextureAddrMode = crate::ctypes::c_uint;
pub type SceGxmTextureBaseFormat = crate::ctypes::c_uint;
pub type SceGxmTextureFilter = crate::ctypes::c_uint;
pub type SceGxmTextureFormat = crate::ctypes::c_uint;
pub type SceGxmTextureGammaMode = crate::ctypes::c_uint;
pub type SceGxmTextureMipFilter = crate::ctypes::c_uint;
pub type SceGxmTextureNormalizeMode = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzle1Mode = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzle2Mode = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzle2ModeAlt = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzle3Mode = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzle4Mode = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzleYUV420Mode = crate::ctypes::c_uint;
pub type SceGxmTextureSwizzleYUV422Mode = crate::ctypes::c_uint;
pub type SceGxmTextureType = crate::ctypes::c_uint;
pub type SceGxmTransferColorKeyMode = crate::ctypes::c_uint;
pub type SceGxmTransferFlags = crate::ctypes::c_uint;
pub type SceGxmTransferFormat = crate::ctypes::c_uint;
pub type SceGxmTransferType = crate::ctypes::c_uint;
pub type SceGxmTwoSidedMode = crate::ctypes::c_uint;
pub type SceGxmViewportMode = crate::ctypes::c_uint;
pub type SceGxmVisibilityTestMode = crate::ctypes::c_uint;
pub type SceGxmVisibilityTestOp = crate::ctypes::c_uint;
pub type SceGxmWBufferMode = crate::ctypes::c_uint;
pub type SceGxmWClampMode = crate::ctypes::c_uint;
pub type SceGxmYuvProfile = crate::ctypes::c_uint;
#[doc = "GXT error codes"]
pub type SceGxtErrorCode = crate::ctypes::c_uint;
pub type SceHttpAddHeaderMode = crate::ctypes::c_uint;
pub type SceHttpAuthInfoCallback = ::core::option::Option<
    unsafe extern "C" fn(
        request: crate::ctypes::c_int,
        authType: SceHttpAuthType,
        realm: *const crate::ctypes::c_char,
        username: *mut crate::ctypes::c_char,
        password: *mut crate::ctypes::c_char,
        needEntity: crate::ctypes::c_int,
        entityBody: *mut *mut crate::ctypes::c_uchar,
        entitySize: *mut crate::ctypes::c_uint,
        save: *mut crate::ctypes::c_int,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceHttpAuthType = crate::ctypes::c_uint;
pub type SceHttpCookieRecvCallback = ::core::option::Option<
    unsafe extern "C" fn(
        request: crate::ctypes::c_int,
        url: *const crate::ctypes::c_char,
        cookieHeader: *const crate::ctypes::c_char,
        headerLen: crate::ctypes::c_uint,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceHttpCookieSendCallback = ::core::option::Option<
    unsafe extern "C" fn(
        request: crate::ctypes::c_int,
        url: *const crate::ctypes::c_char,
        cookieHeader: *const crate::ctypes::c_char,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceHttpErrorCode = crate::ctypes::c_uint;
pub type SceHttpMethods = crate::ctypes::c_uint;
pub type SceHttpProxyMode = crate::ctypes::c_uint;
pub type SceHttpRedirectCallback = ::core::option::Option<
    unsafe extern "C" fn(
        request: crate::ctypes::c_int,
        statusCode: crate::ctypes::c_int,
        method: *mut crate::ctypes::c_int,
        location: *const crate::ctypes::c_char,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceHttpsCallback = ::core::option::Option<
    unsafe extern "C" fn(
        verifyEsrr: crate::ctypes::c_uint,
        sslCert: *const *mut crate::ctypes::c_void,
        certNum: crate::ctypes::c_int,
        userArg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceHttpsErrorCode = crate::ctypes::c_uint;
pub type SceHttpsFlag = crate::ctypes::c_uint;
pub type SceHttpSslVersion = crate::ctypes::c_uint;
pub type SceHttpsSslErrorCode = crate::ctypes::c_uint;
pub type SceHttpStatusCode = crate::ctypes::c_uint;
pub type SceHttpUriBuildType = crate::ctypes::c_uint;
pub type SceHttpVersion = crate::ctypes::c_uint;
pub type SceI2cErrorCode = crate::ctypes::c_uint;
pub type SceIftuErrorCode = crate::ctypes::c_uint;
pub type SceIftuPixelformat = crate::ctypes::c_uint;
pub type SceImeDialogButton = crate::ctypes::c_uint;
pub type SceImeDialogDialogMode = crate::ctypes::c_uint;
pub type SceImeDialogErrorCode = crate::ctypes::c_uint;
pub type SceImeDialogTextboxMode = crate::ctypes::c_uint;
pub type SceImeEnterLabel = crate::ctypes::c_uint;
pub type SceImeErrorCode = crate::ctypes::c_uint;
pub type SceImeEvent = crate::ctypes::c_uint;
pub type SceImeEventHandler = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut crate::ctypes::c_void, e: *const SceImeEventData),
>;
pub type SceImeLanguage = crate::ctypes::c_uint;
pub type SceImeOption = crate::ctypes::c_uint;
pub type SceImeTextFilter = ::core::option::Option<
    unsafe extern "C" fn(
        outText: *mut SceWChar16,
        outTextLength: *mut SceUInt32,
        srcText: *const SceWChar16,
        srcTextLength: SceUInt32,
    ) -> SceInt32,
>;
pub type SceImeType = crate::ctypes::c_uint;
#[doc = "Error Codes"]
pub type SceIncomingDialogErrorCode = crate::ctypes::c_uint;
#[doc = "Dialog status"]
pub type SceIncomingDialogStatus = crate::ctypes::c_uint;
pub type SceInt = i32;
pub type SceInt16 = i16;
pub type SceInt32 = i32;
pub type SceInt64 = i64;
pub type SceInt8 = i8;
pub type SceIntPtr = crate::ctypes::c_int;
#[doc = "Access modes for st_mode in ::SceIoStat.\n\n > **Note:** System always requires RW access.\n For safe homebrew system software will force system permission field to RW.\n For unsafe homebrew, you need to set it yourself `( mode | SCE_S_IWSYS | SCE_S_IRSYS)`"]
pub type SceIoAccessMode = crate::ctypes::c_uint;
pub type SceIoDevType = crate::ctypes::c_uint;
#[doc = "File modes, used for the st_attr parameter in ::SceIoStat."]
pub type SceIoFileMode = crate::ctypes::c_uint;
pub type SceIoMode = crate::ctypes::c_uint;
pub type SceIoSeekMode = crate::ctypes::c_uint;
#[doc = "Dynamically allocated encoder context.\n\n See sceJpegArmEncoderGetContextSize() for required allocation size.\n The address must be 4 byte aligned."]
pub type SceJpegArmEncoderContext = *mut crate::ctypes::c_void;
#[doc = "JPEG Header Modes"]
pub type SceJpegArmEncoderHeaderMode = crate::ctypes::c_uint;
#[doc = "Pixel Formats"]
pub type SceJpegArmEncoderPixelFormat = crate::ctypes::c_uint;
#[doc = "Error Codes"]
pub type SceJpegArmErrorCode = crate::ctypes::c_uint;
#[doc = "Error Codes"]
pub type SceJpegEncArmErrorCode = crate::ctypes::c_uint;
pub type SceJpegEncErrorCode = crate::ctypes::c_uint;
pub type SceJpegEncoderContext = *mut crate::ctypes::c_void;
pub type SceJpegEncoderHeaderMode = crate::ctypes::c_uint;
pub type SceJpegEncoderInitParamOption = crate::ctypes::c_uint;
pub type SceJpegEncoderPixelFormat = crate::ctypes::c_uint;
pub type SceKernelAllocMemBlockAttr = crate::ctypes::c_uint;
pub type SceKernelAssertLevel = crate::ctypes::c_uint;
#[doc = "Callback function prototype"]
pub type SceKernelCallbackFunction = ::core::option::Option<
    unsafe extern "C" fn(
        notifyId: crate::ctypes::c_int,
        notifyCount: crate::ctypes::c_int,
        notifyArg: crate::ctypes::c_int,
        userData: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelClock = SceUInt64;
pub type SceKernelCoredumpStateFinishCallback = ::core::option::Option<
    unsafe extern "C" fn(
        task_id: crate::ctypes::c_int,
        pid: SceUID,
        result: crate::ctypes::c_int,
        path: *const crate::ctypes::c_char,
        path_len: SceSize,
        unk: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelCoredumpStateUpdateCallback = ::core::option::Option<
    unsafe extern "C" fn(
        task_id: crate::ctypes::c_int,
        pid: SceUID,
        progress: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelCoredumpTriggerFunc = ::core::option::Option<
    unsafe extern "C" fn(
        pid: SceUID,
        update_func: SceKernelCoredumpStateUpdateCallback,
        finish_func: SceKernelCoredumpStateFinishCallback,
        param: *mut SceCoredumpTriggerParam,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelDebugInfoFlags = crate::ctypes::c_uint;
pub type SceKernelDebugLevel = crate::ctypes::c_uint;
pub type SceKernelDebugMessageContext = SceKernelDebugInfo;
pub type SceKernelDmacId = crate::ctypes::c_uint;
pub type SceKernelDmaOpCallback = ::core::option::Option<
    unsafe extern "C" fn(
        opid: SceKernelDmaOpId,
        stat: SceUInt32,
        pUserData: *mut crate::ctypes::c_void,
        pTag: *mut SceKernelDmaOpTag,
    ),
>;
pub type SceKernelDmaOpFlag = crate::ctypes::c_uint;
pub type SceKernelDmaOpId = SceInt32;
pub type SceKernelDmaOpSyncMode = crate::ctypes::c_uint;
pub type SceKernelErrorCode = crate::ctypes::c_uint;
pub type SceKernelFwInfo = SceKernelSystemSwVersion;
pub type SceKernelGetSystemSwVersionFunc =
    ::core::option::Option<unsafe extern "C" fn() -> crate::ctypes::c_int>;
pub type SceKernelHeapAttr = crate::ctypes::c_uint;
#[doc = "Threadmgr types"]
pub type SceKernelIdListType = crate::ctypes::c_uint;
pub type SceKernelIntrHandler = ::core::option::Option<
    unsafe extern "C" fn(
        unk: crate::ctypes::c_int,
        userCtx: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelIntrOptHandlersCb1 = ::core::option::Option<
    unsafe extern "C" fn(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelIntrOptHandlersCb2 = ::core::option::Option<
    unsafe extern "C" fn(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
        arg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceKernelIntrOptHandlersCb3 = ::core::option::Option<
    unsafe extern "C" fn(
        intr_code: crate::ctypes::c_int,
        subintr_code: crate::ctypes::c_int,
        handler: SceKernelSubIntrHandler,
        register_arg: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
#[doc = "Interrupt status\n\n This opaque value is used to hold the interruptability status\n (whether the CPU can be interrupted) on entry to functions that\n temporarily suspend interrupts. For readers familiar with the\n Windows NT kernel, this is similar in spirit to the IRQL value.\n\n The only usage that can be made of this value is to compare it\n against zero to check whether a function call failed, if applicable.\n See the description of functions using this datatype for more details."]
pub type SceKernelIntrStatus = crate::ctypes::c_int;
pub type SceKernelMemBlockType = SceUInt32;
pub type SceKernelMemoryAccessType = crate::ctypes::c_uint;
pub type SceKernelMemoryRefPerm = crate::ctypes::c_uint;
pub type SceKernelMemoryType = crate::ctypes::c_uint;
pub type SceKernelModel = crate::ctypes::c_uint;
pub type SceKernelModuleState = crate::ctypes::c_uint;
pub type SceKernelMutexAttribute = crate::ctypes::c_uint;
pub type SceKernelPaddrList = SceKernelPAVector;
pub type SceKernelPowerTickType = crate::ctypes::c_uint;
pub type SceKernelPreloadInhibit = crate::ctypes::c_uint;
pub type SceKernelProcessPrioritySystem = crate::ctypes::c_uint;
pub type SceKernelProcessPriorityUser = crate::ctypes::c_uint;
pub type SceKernelProcessType = SceUInt32;
#[doc = "RW Spinlock\n\n (Refer to the regular spinlock description for more details\n about the spinlock synchronisation primitive)\n\n\n The RWSpinlock works similarly to a RWLock - multiple threads/CPUs\n can access the protected data at the same time as long as only reads\n are performed. When acquired for writing, a single thread/CPU at a time\n is allowed to own the RWSpinlock and is thus free to modify the data.\n Modifying data protected by a RWSpinlock while holding it for reading is\n undefined behaviour and will lead to data corruption and system instability.\n\n RW Spinlocks may be acquired by up to ?128? readers at a time. It is\n also possible to recursively acquire a RWSpinlock for reading. Recursively\n acquiring a RWSpinlock for writing is not allowed and will deadlock."]
pub type SceKernelRWSpinlock = crate::ctypes::c_int;
#[doc = "Regular Spinlock\n\n Spinlocks are a simple mutual exclusion mechanism implemented\n using atomic primitives (LDREX/STREX). Unlike other kernel\n synchronisation primitives, spinlocks can be acquired under\n any context, including an IRQ or exception handler.\n\n Since threads/CPUs trying to acquire a spinlock loop until\n the lock is free, this synchronisation primitive should only\n be used when the data to protect may be accessed under a context\n in which entering WAITING state is not allowed (e.g. IRQ handler).\n\n Spinlocks cannot be acquired recursively. Attempting to recursively\n acquire a regular spinlock will deadlock.\n\n\n The regular Spinlock works similarly to a mutex - only one thread\n or CPU may own the Spinlock at a time."]
pub type SceKernelSpinlock = crate::ctypes::c_int;
pub type SceKernelSubIntrHandler = ::core::option::Option<
    unsafe extern "C" fn(
        subintr_arg: *mut crate::ctypes::c_void,
        register_arg: *mut crate::ctypes::c_void,
        intr_priority: crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int,
>;
#[doc = "64-bit system clock type."]
pub type SceKernelSysClock = SceUInt64;
pub type SceKernelSysrootSelfIndex = crate::ctypes::c_uint;
pub type SceKernelThreadEntry = ::core::option::Option<
    unsafe extern "C" fn(args: SceSize, argp: *mut crate::ctypes::c_void) -> crate::ctypes::c_int,
>;
pub type SceKernelTime = SceUInt32;
pub type SceKernelWaitableAttribute = crate::ctypes::c_uint;
pub type SceKernelWorkQueueWorkFunction = ::core::option::Option<
    unsafe extern "C" fn(args: *mut crate::ctypes::c_void) -> crate::ctypes::c_int,
>;
#[doc = "Usage permission dialog result"]
pub type SceLocationDialogResult = crate::ctypes::c_uint;
#[doc = "Usage permission dialog display status"]
pub type SceLocationDialogStatus = crate::ctypes::c_uint;
#[doc = "Location error codes"]
pub type SceLocationErrorCode = crate::ctypes::c_uint;
#[doc = "Location handle datatype"]
pub type SceLocationHandle = SceUInt32;
#[doc = "Callback notification function for direction information"]
pub type SceLocationHeadingInfoCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: SceInt32,
        handle: SceLocationHandle,
        heading: *const SceLocationHeadingInfo,
        userdata: *mut crate::ctypes::c_void,
    ),
>;
#[doc = "Direction measurement method"]
pub type SceLocationHeadingMethod = crate::ctypes::c_uint;
#[doc = "Location information callback notification function"]
pub type SceLocationLocationInfoCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: SceInt32,
        handle: SceLocationHandle,
        location: *const SceLocationLocationInfo,
        userdata: *mut crate::ctypes::c_void,
    ),
>;
#[doc = "Location measurement method"]
pub type SceLocationLocationMethod = crate::ctypes::c_uint;
#[doc = "location usage permission status for individual application"]
pub type SceLocationPermissionApplicationStatus = crate::ctypes::c_uint;
#[doc = "location usage permission status"]
pub type SceLocationPermissionStatus = crate::ctypes::c_uint;
pub type SceLong64 = i64;
pub type SceMode = crate::ctypes::c_int;
pub type SceMotionErrorCode = crate::ctypes::c_uint;
pub type SceMotionMagFieldStability = crate::ctypes::c_uint;
pub type SceMsgDialogButtonId = crate::ctypes::c_uint;
pub type SceMsgDialogButtonType = crate::ctypes::c_uint;
pub type SceMsgDialogEnvFlag = crate::ctypes::c_uint;
pub type SceMsgDialogErrorCode = crate::ctypes::c_uint;
pub type SceMsgDialogFontSize = crate::ctypes::c_uint;
pub type SceMsgDialogMode = crate::ctypes::c_uint;
pub type SceMsgDialogProgressBarTarget = crate::ctypes::c_uint;
pub type SceMsgDialogProgressBarType = crate::ctypes::c_uint;
pub type SceMsgDialogSystemMessageType = crate::ctypes::c_uint;
pub type SceName = *mut crate::ctypes::c_char;
pub type SceNetCheckDialoErrorCode = crate::ctypes::c_uint;
pub type SceNetCheckDialogMode = crate::ctypes::c_uint;
pub type SceNetCheckDialogPS3ConnectAction = crate::ctypes::c_uint;
pub type SceNetCtlCallback = ::core::option::Option<
    unsafe extern "C" fn(
        event_type: crate::ctypes::c_int,
        arg: *mut crate::ctypes::c_void,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceNetCtlInfoType = crate::ctypes::c_uint;
pub type SceNetCtlState = crate::ctypes::c_uint;
#[doc = "Flags to specify as argument to ::sceNetDumpRead()"]
pub type SceNetDumpType = crate::ctypes::c_uint;
#[doc = "Flags to specify as argument to ::sceNetEmulationGet() / ::sceNetEmulationSet()"]
pub type SceNetEmulationFlag = crate::ctypes::c_uint;
#[doc = "Flags to specify as argument to ::sceNetEpollControl()"]
pub type SceNetEpollControlFlag = crate::ctypes::c_uint;
#[doc = "Events for ::SceNetEpollEvent"]
pub type SceNetEpollEventType = crate::ctypes::c_uint;
#[doc = "Net Error Codes"]
pub type SceNetErrorCode = crate::ctypes::c_uint;
#[doc = "Codes to specify to ::SceNetIcmpHeader structure"]
pub type SceNetIcmpCode = crate::ctypes::c_uint;
#[doc = "Types to specify to ::SceNetIcmpHeader structure"]
pub type SceNetIcmpType = crate::ctypes::c_uint;
#[doc = "Specific kernel and libnet error codes"]
pub type SceNetKernelErrorCode = crate::ctypes::c_uint;
#[doc = "libnet specific error codes"]
pub type SceNetLibnetErrorCode = crate::ctypes::c_uint;
#[doc = "MSG Flags"]
pub type SceNetMsgFlag = crate::ctypes::c_uint;
#[doc = "Net Protocols"]
pub type SceNetProtocol = crate::ctypes::c_uint;
#[doc = "Flags to specify as argument to ::sceNetResolverAbort()"]
pub type SceNetResolverAbortFlag = crate::ctypes::c_uint;
#[doc = "Resolver specific error codes"]
pub type SceNetResolverErrorCode = crate::ctypes::c_uint;
#[doc = "Flags to specify as argument to ::sceNetResolverStartNtoa() / ::sceNetResolverStartAton()"]
pub type SceNetResolverFlag = crate::ctypes::c_uint;
pub type SceNetResolverFunctionAllocate = ::core::option::Option<
    unsafe extern "C" fn(
        size: crate::ctypes::c_uint,
        rid: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
        user: *mut crate::ctypes::c_void,
    ) -> *mut crate::ctypes::c_void,
>;
pub type SceNetResolverFunctionFree = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut crate::ctypes::c_void,
        rid: crate::ctypes::c_int,
        name: *const crate::ctypes::c_char,
        user: *mut crate::ctypes::c_void,
    ),
>;
#[doc = "Flags to specify as argument to ::sceNetShutdown"]
pub type SceNetShutdownFlag = crate::ctypes::c_uint;
#[doc = "Flags to specify as argument to ::sceNetSocketAbort()"]
pub type SceNetSocketAbortFlag = crate::ctypes::c_uint;
#[doc = "Socket Options"]
pub type SceNetSocketOption = crate::ctypes::c_uint;
#[doc = "Socket types"]
pub type SceNetSocketType = crate::ctypes::c_uint;
#[doc = "flags for ::SceNetSockInfo structure"]
pub type SceNetSockInfoFlag = crate::ctypes::c_uint;
#[doc = "state for ::SceNetSockInfo structure"]
pub type SceNetSockInfoState = crate::ctypes::c_uint;
pub type SceNgsCallbackFunc =
    ::core::option::Option<unsafe extern "C" fn(callback_info: *const SceNgsCallbackInfo)>;
pub type SceNgsHPatch = SceUInt32;
pub type SceNgsHRack = SceUInt32;
pub type SceNgsHSynSystem = SceUInt32;
pub type SceNgsHVoice = SceUInt32;
pub type SceNgsModuleCallbackFunc = SceNgsCallbackFunc;
pub type SceNgsModuleID = SceUInt32;
pub type SceNgsParamsErrorCallbackFunc = SceNgsCallbackFunc;
pub type SceNgsRackReleaseCallbackFunc = SceNgsCallbackFunc;
pub type SceNgsSulphaUpdateCallback = *mut crate::ctypes::c_void;
pub type SceNID = crate::ctypes::c_uint;
#[doc = "Error Codes"]
pub type SceNotificationUitlErrorCode = crate::ctypes::c_uint;
#[doc = "BGDL-type notification event handler function"]
pub type SceNotificationUtilProgressEventHandler =
    ::core::option::Option<unsafe extern "C" fn(eventId: crate::ctypes::c_int)>;
#[doc = "Options for _sceNpDrmPackageDecrypt"]
pub type _sceNpDrmPackageDecrypt_opt = _sceNpDrmPackageDecrypt;
pub type SceOff = SceInt64;
pub type _ScePerfArmPmonEventCode = crate::ctypes::c_uint;
pub type ScePID = crate::ctypes::c_int;
#[doc = "Callback function prototype"]
pub type ScePowerCallback = ::core::option::Option<
    unsafe extern "C" fn(
        notifyId: crate::ctypes::c_int,
        notifyCount: crate::ctypes::c_int,
        powerInfo: crate::ctypes::c_int,
        userData: *mut crate::ctypes::c_void,
    ),
>;
pub type ScePowerCallbackType = crate::ctypes::c_uint;
pub type ScePowerConfigurationMode = crate::ctypes::c_uint;
pub type ScePowerErrorCode = crate::ctypes::c_uint;
pub type SceProductCode = crate::ctypes::c_uint;
pub type SceProductMode = crate::ctypes::c_char;
#[doc = "Avalible types for ::ScePromoterUtilityImportParams"]
pub type ScePromoterUtilityPackageType = crate::ctypes::c_uint;
pub type ScePspnetAdhocctlAdhocType = crate::ctypes::c_uint;
pub type ScePspnetAdhocctlErrorCode = crate::ctypes::c_uint;
pub type ScePspnetAdhocErrorCode = crate::ctypes::c_uint;
pub type ScePspnetAdhocEvent = crate::ctypes::c_uint;
pub type ScePspnetAdhocFlags = crate::ctypes::c_uint;
pub type ScePspnetAdhocPtpState = crate::ctypes::c_uint;
pub type ScePvfAllocFunc = ::core::option::Option<
    unsafe extern "C" fn(userData: ScePvfPointer, size: ScePvfU32) -> ScePvfPointer,
>;
pub type ScePvfBool = ScePvfU32;
pub type ScePvfBoolValue = crate::ctypes::c_uint;
pub type ScePvfCharCode = ScePvfU16;
pub type ScePvfDataAccessMode = crate::ctypes::c_uint;
pub type ScePvfError = ScePvfS32;
pub type ScePvfErrorCode = crate::ctypes::c_uint;
pub type ScePvfFamilyCode = crate::ctypes::c_uint;
pub type ScePvfFloat32 = f32;
pub type ScePvfFontCacheLockFunc =
    ::core::option::Option<unsafe extern "C" fn(cacheInstance: ScePvfPointer) -> ScePvfS32>;
pub type ScePvfFontChcheFindFunc = ::core::option::Option<
    unsafe extern "C" fn(
        chcheInstance: ScePvfPointer,
        hashValue: ScePvfU32,
        key: ScePvfPointer,
        result: *mut ScePvfBool,
    ) -> ScePvfPointer,
>;
pub type ScePvfFontChcheReadFromCacheFunc = ::core::option::Option<
    unsafe extern "C" fn(
        cacheInstance: ScePvfPointer,
        cacheSlot: ScePvfPointer,
        data0: ScePvfPointer,
    ) -> ScePvfS32,
>;
pub type ScePvfFontChcheUnlockFunc =
    ::core::option::Option<unsafe extern "C" fn(cacheInstance: ScePvfPointer) -> ScePvfS32>;
pub type ScePvfFontChcheWriteKeyValueToCacheFunc = ::core::option::Option<
    unsafe extern "C" fn(
        cacheInstance: ScePvfPointer,
        chcheSlot: ScePvfPointer,
        key: ScePvfPointer,
    ) -> ScePvfS32,
>;
pub type ScePvfFontChcheWriteToCacheFunc = ::core::option::Option<
    unsafe extern "C" fn(
        cacheInstance: ScePvfPointer,
        cacheSlot: ScePvfPointer,
        data0: ScePvfPointer,
        size: ScePvfInt,
    ) -> ScePvfS32,
>;
pub type ScePvfFontId = *mut crate::ctypes::c_void;
pub type ScePvfFontIndex = ScePvfS32;
pub type ScePvfFontVendorCountryCode = crate::ctypes::c_uint;
pub type ScePvfFreeFunc =
    ::core::option::Option<unsafe extern "C" fn(userData: ScePvfPointer, ptr: ScePvfPointer)>;
pub type ScePvfHandle = *mut crate::ctypes::c_void;
pub type ScePvfImageByfferPixelFormatType = crate::ctypes::c_uint;
pub type ScePvfInt = ScePvfS32;
pub type ScePvfLanguageCode = crate::ctypes::c_uint;
pub type ScePvfLibId = *mut crate::ctypes::c_void;
pub type ScePvfPointer = *mut crate::ctypes::c_void;
pub type ScePvfReallocFunc = ::core::option::Option<
    unsafe extern "C" fn(
        userData: ScePvfPointer,
        old_ptr: ScePvfPointer,
        size: ScePvfU32,
    ) -> ScePvfPointer,
>;
pub type ScePvfRegionCode = crate::ctypes::c_uint;
pub type ScePvfS32 = crate::ctypes::c_int;
pub type ScePvfStyleCode = crate::ctypes::c_uint;
pub type ScePvfSubstyle = crate::ctypes::c_uint;
pub type ScePvfU16 = crate::ctypes::c_ushort;
pub type ScePvfU32 = crate::ctypes::c_uint;
pub type ScePvfU8 = crate::ctypes::c_uchar;
pub type ScePVoid = *mut crate::ctypes::c_void;
#[doc = "Enumeration for the gpu live metrics groups"]
pub type SceRazorGpuLiveMetricsGroup = crate::ctypes::c_uint;
#[doc = "Enumeration for the gpu live results entry types"]
pub type SceRazorLiveTraceMetricEntryType = crate::ctypes::c_uint;
#[doc = "Enumeration for the gpu live results job types"]
pub type SceRazorLiveTraceMetricJobType = crate::ctypes::c_uint;
pub type SceRtcDayOfWeek = crate::ctypes::c_uint;
pub type SceRtcErrorCode = crate::ctypes::c_uint;
pub type SceSblSmCommId = crate::ctypes::c_int;
pub type SceSByte = crate::ctypes::c_schar;
pub type SceSByte8 = crate::ctypes::c_schar;
pub type SceScreenshotErrorCode = crate::ctypes::c_uint;
pub type SceShaccCgCallbackAbsolutePath = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *const crate::ctypes::c_char,
        includedFrom: *const SceShaccCgSourceLocation,
        compileOptions: *const SceShaccCgCompileOptions,
    ) -> *const crate::ctypes::c_char,
>;
pub type SceShaccCgCallbackDefaults = crate::ctypes::c_uint;
pub type SceShaccCgCallbackFileDate = ::core::option::Option<
    unsafe extern "C" fn(
        file: *const SceShaccCgSourceFile,
        includedFrom: *const SceShaccCgSourceLocation,
        compileOptions: *const SceShaccCgCompileOptions,
        timeLastStatusChange: *mut i64,
        timeLastModified: *mut i64,
    ) -> SceInt32,
>;
pub type SceShaccCgCallbackLocateFile = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *const crate::ctypes::c_char,
        includedFrom: *const SceShaccCgSourceLocation,
        searchPathCount: SceUInt32,
        searchPaths: *const *const crate::ctypes::c_char,
        compileOptions: *const SceShaccCgCompileOptions,
        errorString: *mut *const crate::ctypes::c_char,
    ) -> *const crate::ctypes::c_char,
>;
pub type SceShaccCgCallbackOpenFile = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *const crate::ctypes::c_char,
        includedFrom: *const SceShaccCgSourceLocation,
        compileOptions: *const SceShaccCgCompileOptions,
        errorString: *mut *const crate::ctypes::c_char,
    ) -> *mut SceShaccCgSourceFile,
>;
pub type SceShaccCgCallbackReleaseFile = ::core::option::Option<
    unsafe extern "C" fn(
        file: *const SceShaccCgSourceFile,
        compileOptions: *const SceShaccCgCompileOptions,
    ),
>;
pub type SceShaccCgCallbackReleaseFileName = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *const crate::ctypes::c_char,
        compileOptions: *const SceShaccCgCompileOptions,
    ),
>;
pub type SceShaccCgDiagnosticLevel = crate::ctypes::c_uint;
pub type SceShaccCgLocale = crate::ctypes::c_uint;
pub type SceShaccCgParameter = *const crate::ctypes::c_void;
pub type SceShaccCgTargetProfile = crate::ctypes::c_uint;
pub type SceShellUtilEventHandler = ::core::option::Option<
    unsafe extern "C" fn(
        result: crate::ctypes::c_int,
        mode: SceShellUtilLockMode,
        type_: SceShellUtilLockType,
        userData: *mut crate::ctypes::c_void,
    ),
>;
pub type SceShellUtilLockMode = crate::ctypes::c_uint;
pub type SceShellUtilLockType = crate::ctypes::c_uint;
pub type SceShort16 = i16;
pub type SceShutterSoundErrorCode = crate::ctypes::c_uint;
pub type SceShutterSoundType = crate::ctypes::c_uint;
pub type SceSize = crate::ctypes::c_uint;
pub type SceSSize = crate::ctypes::c_int;
pub type SceSslCert = crate::ctypes::c_void;
pub type SceSslCertName = crate::ctypes::c_void;
pub type SceSslErrorCode = crate::ctypes::c_uint;
pub type SceSysclibPrntCallback = ::core::option::Option<
    unsafe extern "C" fn(argp: *mut crate::ctypes::c_void, ch: crate::ctypes::c_int),
>;
pub type SceSysconCallback = ::core::option::Option<
    unsafe extern "C" fn(enable: crate::ctypes::c_int, argp: *mut crate::ctypes::c_void),
>;
pub type SceSysconCmd = crate::ctypes::c_uint;
pub type SceSysconCmdExecAsyncCallback = ::core::option::Option<
    unsafe extern "C" fn(
        packet: *mut SceSysconPacket,
        argp: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
pub type SceSysconControl = crate::ctypes::c_uint;
pub type SceSysconResetType = crate::ctypes::c_uint;
pub type SceSysEventHandler = ::core::option::Option<
    unsafe extern "C" fn(
        resume: crate::ctypes::c_int,
        eventid: crate::ctypes::c_int,
        args: *mut crate::ctypes::c_void,
        opt: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
#[doc = "Errorcodes for SceSysmodule"]
pub type SceSysmoduleErrorCode = crate::ctypes::c_uint;
#[doc = "Available internal modules ID for ::sceSysmoduleLoadModuleInternal"]
pub type SceSysmoduleInternalModuleId = crate::ctypes::c_uint;
#[doc = "Available modules ID for ::sceSysmoduleLoadModule"]
pub type SceSysmoduleModuleId = crate::ctypes::c_uint;
pub type SceSysroot = SceUIDSysrootObject;
#[doc = "Date display format"]
pub type SceSystemParamDateFormat = crate::ctypes::c_uint;
#[doc = "Assignment of enter button"]
pub type SceSystemParamEnterButtonAssign = crate::ctypes::c_uint;
#[doc = "System param id"]
pub type SceSystemParamId = crate::ctypes::c_uint;
#[doc = "Language settings"]
pub type SceSystemParamLang = crate::ctypes::c_uint;
#[doc = "Time display format"]
pub type SceSystemParamTimeFormat = crate::ctypes::c_uint;
pub type SceSysTimerCallback = ::core::option::Option<
    unsafe extern "C" fn(timer: SceSysTimerId, pUserData: *mut crate::ctypes::c_void),
>;
pub type SceSysTimerClockSource = crate::ctypes::c_uint;
pub type SceSysTimerId = SceInt32;
pub type SceSysTimerType = crate::ctypes::c_uint;
pub type SceThreadStatus = crate::ctypes::c_uint;
#[doc = "Touch error codes"]
pub type SceTouchErrorCode = crate::ctypes::c_uint;
#[doc = "Port numbers of touch panels\n\n [`crate::sceTouchRead`]\n [`crate::sceTouchPeek`]"]
pub type SceTouchPortType = crate::ctypes::c_uint;
#[doc = "Info field of ::SceTouchReport structure\n\n [`crate::SceTouchReport`]"]
pub type SceTouchReportInfo = crate::ctypes::c_uint;
#[doc = "Sampling port setting of the touch panel\n\n [`crate::sceTouchSetSamplingState`]"]
pub type SceTouchSamplingState = crate::ctypes::c_uint;
#[doc = "Days of the week for use in repeatDays member of ::SceTriggerUtilEventParamDaily"]
pub type SceTriggerUtilDays = crate::ctypes::c_uint;
#[doc = "Error Codes"]
pub type SceTriggerUtilErrorCode = crate::ctypes::c_uint;
pub type SceUChar8 = u8;
#[doc = "SceUdcdDeviceRequest Flags"]
pub type SceUdcdDeviceRequestAttr = crate::ctypes::c_uint;
#[doc = "Error codes"]
pub type SceUdcdErrorCode = crate::ctypes::c_uint;
#[doc = "Class Descriptor Types"]
pub type SceUdcdHidDescriptor = crate::ctypes::c_uint;
#[doc = "HID Interface Class Protocol Codes"]
pub type SceUdcdHidProtocol = crate::ctypes::c_uint;
#[doc = "Class-Specific Requests"]
pub type SceUdcdHidRequest = crate::ctypes::c_uint;
#[doc = "Protocol Selection"]
pub type SceUdcdProtocol = crate::ctypes::c_uint;
pub type SceUdcdRetcode = crate::ctypes::c_int;
pub type SceUdcdStatus = crate::ctypes::c_uint;
pub type SceUdcdStatusDriver = crate::ctypes::c_uint;
#[doc = "Enumeration for Device and/or Interface Class codes"]
pub type SceUdcdUsbClass = crate::ctypes::c_uint;
#[doc = "Enumeration for descriptor types"]
pub type SceUdcdUsbDt = crate::ctypes::c_uint;
#[doc = "Enumeration for standard requests"]
pub type SceUdcdUsbReq = crate::ctypes::c_uint;
pub type SceUID = crate::ctypes::c_int;
pub type SceUInt = u32;
pub type SceUInt16 = u16;
pub type SceUInt32 = u32;
pub type SceUInt64 = u64;
pub type SceUInt8 = u8;
pub type SceUIntPtr = crate::ctypes::c_uint;
pub type SceUIntVAddr = SceUIntPtr;
pub type SceULong64 = u64;
pub type SceUpdateMode = crate::ctypes::c_char;
pub type SceUsbAudioInErrorCode = crate::ctypes::c_uint;
pub type SceUsbdDescriptorType = crate::ctypes::c_uint;
pub type SceUsbdErrorCode = crate::ctypes::c_uint;
pub type SceUsbdReqtype = crate::ctypes::c_uint;
pub type SceUsbdRequest = crate::ctypes::c_uint;
pub type SceUsbservErrorCode = crate::ctypes::c_uint;
pub type SceUsbstorVstorType = crate::ctypes::c_uint;
pub type SceUShort16 = u16;
pub type SceVideodecErrorCode = crate::ctypes::c_uint;
pub type SceVideodecType = crate::ctypes::c_uint;
pub type SceVoid = crate::ctypes::c_void;
pub type SceWChar16 = u16;
pub type SceWChar32 = u32;
pub type SulphaNgsModuleQueryType = SceUInt32;
#[doc = "Structure containing a threads register states."]
pub type ThreadCpuRegisters = SceThreadCpuRegisters;
pub type time_t = crate::ctypes::c_long;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type uint_fast8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type uint_least8_t = u8;
pub type uintmax_t = crate::ctypes::c_ulonglong;
pub type va_list = u32;
pub type wchar_t = crate::ctypes::c_uint;
