use std::{
    collections::{btree_map, BTreeMap, BTreeSet, HashSet},
    fmt, fs,
    io::{self, Read, Seek, Write},
    mem,
    path::{Path, PathBuf},
};

use serde::Deserialize;

/// Blacklisted stub libs containing conflicting symbol definitions.
const CONFLICTING_STUB_LIBS: [&str; 4] = [
    // Defines `__aeabi_uidiv`, which is also defined by compiler_builtins.
    "SceSysclibForDriver_stub",
    // Defines `__aeabi_unwind_cpp_pr0` and probably other symbols that seem
    // to collide with std.
    "SceLibc_stub",
    // This one overrides pthread_getspecific and friends, which makes the app
    // crash when using thread locals...
    "SceLibMonoBridge_stub",
    // Conflicts with compiler_builtins
    "SceRtabi_stub",
];

#[derive(Default)]
pub struct VitaDb {
    pub imports_by_firmware: BTreeMap<String, VitaImports>,
}

impl VitaDb {
    pub fn load(db: &Path) -> Self {
        let mut out = VitaDb {
            imports_by_firmware: BTreeMap::new(),
        };

        for version_dir in db.read_dir().unwrap() {
            for yml in version_dir.unwrap().path().read_dir().unwrap() {
                let yml = yml.unwrap().path();
                log::debug!("Loading: {}", yml.display());
                let rdr = io::BufReader::new(fs::File::open(yml).unwrap());
                out.add_imports(serde_yaml::from_reader(rdr).unwrap());
            }
        }

        out
    }

    pub fn split_conflicting(&mut self) -> Self {
        self.split_filter(|imports, mod_name, _, lib_name, lib| {
            let stub_lib = stub_lib_name(
                mod_name,
                lib_name,
                lib.stub_name.as_deref(),
                lib.kernel,
                &imports.firmware,
            )
            .to_string();
            CONFLICTING_STUB_LIBS.contains(&stub_lib.as_str())
        })
    }

    pub fn split_kernel(&mut self) -> Self {
        self.split_filter(|_, _, _, _, lib| lib.kernel)
    }

    fn split_filter<F>(&mut self, mut f: F) -> Self
    where
        F: FnMut(&VitaImports, &str, &VitaImportsModule, &str, &VitaImportsLib) -> bool,
    {
        let mut split = VitaDb::default();
        self.imports_by_firmware.retain(|_, imports| {
            split.add_imports(imports.split_filter(&mut f));
            !imports.is_empty()
        });
        split
    }

    pub fn stub_lib_names(&self) -> impl Iterator<Item = String> + '_ {
        self.imports_by_firmware.values().flat_map(|imports| {
            imports.modules.iter().flat_map(|(module_name, module)| {
                module.libraries.iter().map(|(lib_name, lib)| {
                    stub_lib_name(
                        module_name,
                        lib_name,
                        lib.stub_name.as_deref(),
                        lib.kernel,
                        &imports.firmware,
                    )
                    .to_string()
                })
            })
        })
    }

    pub fn add_imports(&mut self, imports: VitaImports) {
        if imports.is_empty() {
            return;
        }
        let entry = self.imports_by_firmware.entry(imports.firmware.clone());
        match entry {
            btree_map::Entry::Occupied(o) => o.into_mut().merge_from(imports),
            btree_map::Entry::Vacant(v) => {
                v.insert(imports);
            }
        }
    }

    pub fn update_manifest_features(&self, vitasdk_sys_manifest: &Path) {
        const FEATURES_MARKER: &str = "# Automatically generated by build-util:";

        let mut manifest = fs::OpenOptions::new()
            .read(true)
            .write(true)
            .open(vitasdk_sys_manifest)
            .expect("unable to open manifest");

        let marker_position = {
            let mut manifest_string = String::new();
            manifest
                .read_to_string(&mut manifest_string)
                .expect("unable to read manifest");

            manifest_string
                .find(FEATURES_MARKER)
                .expect("features marker not found in manifest")
        };

        manifest
            .seek(io::SeekFrom::Start(u64::try_from(marker_position).unwrap()))
            .expect("unable to seek manifest");

        writeln!(manifest, "{}", FEATURES_MARKER).expect("unable to write to manifest");

        let stub_libs: BTreeSet<_> = self.stub_lib_names().collect();

        write_all_stubs_feature(&mut manifest, &stub_libs).expect("unable to write to manifest");
        write_stub_features(&mut manifest, &stub_libs).expect("unable to write to manifest");

        let stream_position = manifest
            .stream_position()
            .expect("unable to get current stream position");
        manifest
            .set_len(stream_position)
            .expect("unable update manifest length");
    }

    pub fn check_missing_manifest_features(&self, vitasdk_sys_manifest: &Path) {
        let predicate = missing_features_filter(vitasdk_sys_manifest);
        let missing_features: Vec<_> = self.stub_lib_names().filter(predicate).collect();
        log::warn!("Missing features: {missing_features:#?}\nIf you need any of those features, please open an issue so we can update vitasdk-sys.");
    }
}

pub fn missing_features_filter(vitasdk_sys_manifest: &Path) -> impl FnMut(&String) -> bool {
    #[derive(serde::Deserialize)]
    struct CargoManifest {
        #[serde(default)]
        features: Features,
    }

    #[derive(Default, serde::Deserialize)]
    struct Features {
        #[serde(default, rename = "all-stubs")]
        all_stubs: Vec<String>,
    }

    let manifest =
        fs::read_to_string(vitasdk_sys_manifest).expect("Unable to load vitasdk's Cargo.toml");
    let manifest: CargoManifest =
        toml::from_str(&manifest).expect("Unable to parse vitasdk's Cargo.toml");
    let stubs: HashSet<_> = manifest.features.all_stubs.into_iter().collect();

    move |stub_lib| !stubs.contains(stub_lib)
}

pub fn missing_libs_filter() -> impl FnMut(&String) -> bool {
    let lib_dir = PathBuf::from(std::env::var_os("VITASDK").unwrap()).join("arm-vita-eabi/lib");
    assert!(lib_dir.is_dir());
    move |stub_lib| !lib_dir.join(format!("lib{stub_lib}.a")).exists()
}

#[derive(Deserialize)]
pub struct VitaImports {
    pub version: i32,
    pub firmware: String,
    pub modules: BTreeMap<String, VitaImportsModule>,
}

impl VitaImports {
    pub fn clone_emptied(&self) -> Self {
        VitaImports {
            version: self.version,
            firmware: self.firmware.clone(),
            modules: BTreeMap::new(),
        }
    }

    pub fn take(&mut self) -> Self {
        let empty = self.clone_emptied();
        mem::replace(self, empty)
    }

    pub fn is_empty(&self) -> bool {
        self.modules.is_empty()
    }

    pub fn add_module<S: Into<String>>(&mut self, name: S, module: VitaImportsModule) {
        if !module.is_empty() {
            let old = self.modules.insert(name.into(), module);
            assert!(old.is_none());
        }
    }

    pub fn merge_from(&mut self, other: Self) {
        assert_eq!(self.version, other.version);
        assert_eq!(self.firmware, other.firmware);
        self.modules.extend(other.modules);
    }

    fn split_filter<F>(&mut self, mut f: F) -> Self
    where
        F: FnMut(&VitaImports, &str, &VitaImportsModule, &str, &VitaImportsLib) -> bool,
    {
        let empty = self.clone_emptied();
        let mut split = self.clone_emptied();
        self.modules.retain(|module_name, module| {
            split.add_module(
                module_name,
                module.split_filter(|module, lib_name, lib| {
                    f(&empty, module_name, module, lib_name, lib)
                }),
            );
            !module.is_empty()
        });
        split
    }
}

#[derive(Deserialize)]
pub struct VitaImportsModule {
    pub nid: u32,
    pub libraries: BTreeMap<String, VitaImportsLib>,
}

impl VitaImportsModule {
    pub fn clone_emptied(&self) -> Self {
        VitaImportsModule {
            nid: self.nid,
            libraries: BTreeMap::new(),
        }
    }

    pub fn take(&mut self) -> Self {
        let empty = self.clone_emptied();
        mem::replace(self, empty)
    }

    pub fn add_lib<S: Into<String>>(&mut self, name: S, lib: VitaImportsLib) {
        if !lib.is_empty() {
            let old = self.libraries.insert(name.into(), lib);
            assert!(old.is_none());
        }
    }

    pub fn is_empty(&self) -> bool {
        self.libraries.is_empty()
    }

    fn split_filter<F>(&mut self, mut f: F) -> Self
    where
        F: FnMut(&VitaImportsModule, &str, &VitaImportsLib) -> bool,
    {
        let empty = self.clone_emptied();
        let mut split = self.clone_emptied();
        self.libraries.retain(|lib_name, lib| {
            split.add_lib(lib_name, lib.split_filter(|lib| f(&empty, lib_name, lib)));
            !lib.is_empty()
        });
        split
    }
}

#[derive(Deserialize)]
pub struct VitaImportsLib {
    pub kernel: bool,
    pub nid: u32,
    pub version: Option<u32>,
    #[serde(rename = "stubname", default)]
    pub stub_name: Option<String>,
    #[serde(rename = "functions", default)]
    pub function_nids: BTreeMap<String, u32>,
    #[serde(rename = "variables", default)]
    pub variable_nids: BTreeMap<String, u32>,
}

impl VitaImportsLib {
    fn clone_emptied(&self) -> Self {
        VitaImportsLib {
            kernel: self.kernel,
            nid: self.nid,
            version: self.version,
            stub_name: self.stub_name.clone(),
            function_nids: BTreeMap::new(),
            variable_nids: BTreeMap::new(),
        }
    }

    pub fn take(&mut self) -> Self {
        let empty = self.clone_emptied();
        mem::replace(self, empty)
    }

    pub fn is_empty(&self) -> bool {
        self.function_nids.is_empty() && self.variable_nids.is_empty()
    }

    fn split_filter<F>(&mut self, mut f: F) -> Self
    where
        F: FnMut(&VitaImportsLib) -> bool,
    {
        let mut split = self.clone_emptied();
        if f(self) {
            mem::swap(self, &mut split);
        }
        split
    }
}

pub(crate) fn stub_lib_name<'a>(
    mod_name: &'a str,
    lib_name: &'a str,
    stub_name: Option<&'a str>,
    kernel: bool,
    firmware: &'a str,
) -> impl fmt::Display + 'a {
    struct StubLibName<'a> {
        name: &'a str,
        firmware: &'a str,
    }

    impl fmt::Display for StubLibName<'_> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str(self.name)?;
            if self.firmware != "3.60" {
                f.write_str("_")?;
                self.firmware.split('.').try_for_each(|s| f.write_str(s))?;
            }
            f.write_str("_stub")
        }
    }

    if let Some(stubname) = stub_name {
        StubLibName {
            name: stubname,
            firmware,
        }
    } else if kernel {
        StubLibName {
            name: lib_name,
            firmware,
        }
    } else {
        StubLibName {
            name: mod_name,
            firmware,
        }
    }
}

fn write_all_stubs_feature(sink: &mut dyn Write, stub_libs: &BTreeSet<String>) -> io::Result<()> {
    writeln!(sink, "all-stubs = [")?;

    for stub_lib in stub_libs
        .iter()
        .filter(|stub_lib| !CONFLICTING_STUB_LIBS.contains(&stub_lib.as_str()))
    {
        writeln!(sink, "  \"{stub_lib}\",")?;
    }

    writeln!(sink, "]")
}

fn write_stub_features(sink: &mut dyn Write, stub_libs: &BTreeSet<String>) -> io::Result<()> {
    for stub_lib in stub_libs {
        writeln!(sink, "{stub_lib} = []")?;
    }
    Ok(())
}
